<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="yen.20170108171605.1"><vh>@settings</vh>
<v t="yen.20170108171605.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="yen.20170108171605.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="yen.20200517131340.1"><vh>About blogger</vh>
<v t="yen.20200529224039.1"><vh>create credential token</vh></v>
<v t="yen.20200517142620.1"><vh>blog content</vh></v>
<v t="yen.20200517131657.1"><vh>python ref</vh></v>
<v t="yen.20200517233837.1"><vh>Blogger 按鈕</vh>
<v t="yen.20200518055330.1"><vh>@button add_to_kblogger</vh>
<v t="yen.20200611222850.1"><vh>@edit ./../../blogger.dat</vh></v>
</v>
<v t="yen.20200608205522.1"><vh>@button add_to_mblogger</vh>
<v t="yen.20200611222924.1"><vh>@edit ./../../blogger.dat</vh></v>
</v>
<v t="leo.20200907150705.1"><vh>@button add_to_c4f</vh>
<v t="leo.20200907150705.2"><vh>@edit ./../../blogger.dat</vh></v>
</v>
<v t="yen.20200518110700.1"><vh>@button edit_to_kblogger</vh></v>
<v t="yen.20200608205624.1"><vh>@button edit_to_mblogger</vh></v>
<v t="leo.20200907071233.1"><vh>@button edit_to_c4f</vh></v>
</v>
<v t="yen.20200517195613.1"><vh>wordpress ref</vh>
<v t="yen.20200517200253.1"><vh>new post</vh></v>
<v t="yen.20200517200409.1"><vh>edit post</vh></v>
<v t="yen.20200517200437.1"><vh>get post </vh></v>
</v>
<v t="yen.20200517233108.1"><vh>markdown to html</vh></v>
<v t="yen.20200517132439.1"><vh>@path ./../downloads/</vh>
<v t="yen.20200517131915.1"><vh>@edit blogger_api_add_1.py</vh></v>
<v t="yen.20200517194513.1"><vh>googleapiclient.sample_tools.init</vh></v>
<v t="yen.20200517195040.1"><vh>@edit blogger_api_add_2.py</vh></v>
</v>
</v>
<v t="yen.20170108171733.1"><vh>@path ../</vh>
<v t="leo.20180115150519.1"><vh>@edit index.html</vh></v>
<v t="yen.20170108171733.3"><vh>@edit README.md</vh></v>
<v t="yen.20170108171733.4"><vh>@edit .gitignore</vh></v>
<v t="leo.20170908162839.1"><vh>沒有 disqus 論壇</vh>
<v t="yen.20170108171733.2"><vh>@button local-blog</vh></v>
</v>
<v t="leo.20170908162904.1"><vh>有 disqus 論壇</vh>
<v t="leo.20170709224430.1"><vh>@button github-blog</vh></v>
</v>
<v t="yen.20170108171733.5"><vh>Pelican 設定</vh>
<v t="leo.20170709020600.1"><vh>共用</vh></v>
<v t="yen.20170108171733.7"><vh>@edit pelicanconf.py</vh></v>
<v t="leo.20170709015947.1"><vh>遠端</vh></v>
<v t="leo.20170709015955.1"><vh>@edit publishconf.py</vh></v>
<v t="leo.20170709015940.1"><vh>近端</vh></v>
<v t="yen.20170108171733.6"><vh>@edit local_publishconf.py</vh></v>
</v>
<v t="yen.20170224232341.1"><vh>編輯 template</vh>
<v t="leo.20180115093448.1"><vh>@path theme/attila/templates</vh>
<v t="leo.20180715212936.1"><vh>@edit article.html</vh></v>
<v t="leo.20180115093536.1"><vh>@edit base.html</vh></v>
<v t="leo.20180115093657.1"><vh>@edit search.html</vh></v>
<v t="leo.20180115093715.1"><vh>@edit archives.html</vh></v>
<v t="leo.20180715212745.1"><vh>@edit categories.html</vh></v>
<v t="leo.20180715212902.1"><vh>@edit index.html</vh></v>
<v t="leo.20180115093726.1"><vh>@path partials</vh>
<v t="leo.20180115093749.1"><vh>@edit navigation.html</vh></v>
</v>
<v t="leo.20180115142025.1"><vh>保留之前舊的設定檔案</vh></v>
</v>
</v>
<v t="leo.20170710015511.1"><vh>編輯 plugin</vh>
<v t="leo.20170710015523.1"><vh>@path plugin</vh>
<v t="leo.20170710015523.2"><vh>@path tipue_search</vh>
<v t="leo.20170710015523.3"><vh>@edit tipue_search.py</vh></v>
</v>
</v>
</v>
<v t="yen.20170108171733.71"><vh>@path markdown</vh>
<v t="yen.20170108171733.81"><vh>@path pages</vh>
<v t="yen.20170108171733.82"><vh>@edit pages_1.md</vh></v>
</v>
</v>
<v t="leo.20170710022054.1"><vh>可以另建節點存放 markdown 目錄下的 md 檔案</vh></v>
<v t="leo.20170710022041.1"><vh>@path markdown</vh>
<v t="leo.20180115115910.1"><vh>2020</vh>
<v t="leo.20180423103639.1"><vh>lab.mde.tw</vh>
<v t="yen.20200518070950.1"><vh>@clean 20200509.md</vh>
<v t="yen.20200518101418.1"><vh>CMSiMDE 網站與網誌</vh>
<v t="yen.20200518115111.1"><vh>6590225703398928368</vh></v>
</v>
</v>
<v t="yen.20200518071032.1"><vh>@clean 20200511.md</vh>
<v t="yen.20200518105911.1"><vh>以 ssh 進行倉儲維護</vh></v>
<v t="yen.20200518115329.1"><vh>2997506218729024138</vh></v>
</v>
<v t="yen.20200512160924.1"><vh>@clean 20200512.md</vh>
<v t="yen.20200518105955.1"><vh>啟動批次檔案</vh></v>
<v t="yen.20200518115347.1"><vh>5322926909051095601</vh></v>
</v>
<v t="yen.20200516092143.1"><vh>@clean 20200516.md</vh>
<v t="yen.20200518110043.1"><vh>機械設計工程師的網站</vh></v>
<v t="yen.20200518115404.1"><vh>6098447557568577337</vh></v>
</v>
<v t="yen.20200516203207.1"><vh>@clean 20200516-1.md</vh>
<v t="yen.20200518110131.1"><vh>虛擬主機網路設定</vh></v>
<v t="yen.20200518115421.1"><vh>8033965979441713500</vh></v>
</v>
<v t="yen.20200518115509.1"><vh>@clean 20200518.md</vh>
<v t="yen.20200518120231.1"><vh>按鈕與節點標題</vh></v>
<v t="yen.20200521095531.1"><vh>8878835997100511576</vh></v>
</v>
<v t="yen.20200528095926.1"><vh>@clean 20200528.md</vh>
<v t="yen.20200529220132.1"><vh>網際內容管理課程目標</vh></v>
<v t="leo.20210317102957.1"><vh>mblog</vh>
<v t="leo.20210317023310.1"><vh>4247626056991609910</vh></v>
</v>
<v t="leo.20210317023355.1"><vh>kblog</vh>
<v t="leo.20210317023351.1"><vh>7326071056728571682</vh></v>
</v>
</v>
<v t="yen.20200608161509.1"><vh>@clean 20200608.md</vh>
<v t="yen.20200608161548.1"><vh>Ubuntu 伺服器</vh></v>
<v t="yen.20200608204806.1"><vh>Ｍ機械設計與精密機械網誌</vh>
<v t="yen.20200608161847.1"><vh>8317144543287169393</vh></v>
</v>
<v t="yen.20200608205920.1"><vh>KMOLab 網誌</vh>
<v t="yen.20200608210003.1"><vh>5378024409689048629</vh></v>
</v>
</v>
<v t="yen.20200611213634.1"><vh>@clean 20200611.md</vh>
<v t="yen.20200611214052.1"><vh>代理主機維護策略</vh></v>
<v t="yen.20200611221718.1"><vh>Mblogger</vh>
<v t="yen.20200611223454.1"><vh>4144488991109518272</vh></v>
</v>
<v t="yen.20200611221647.1"><vh>Kblogger</vh></v>
<v t="yen.20200611221636.1"><vh>3903152963873891868</vh></v>
</v>
<v t="leo.20200630103549.1"><vh>@clean 20200630.md</vh>
<v t="leo.20200630104028.1"><vh>使用 Leo Editor</vh></v>
<v t="leo.20200630113832.1"><vh>KMOLab</vh>
<v t="leo.20200630113823.1"><vh>5283100330867011098</vh></v>
</v>
<v t="leo.20200630114610.1"><vh>MBlogger</vh>
<v t="leo.20200630115346.1"><vh>321264145816016956</vh></v>
</v>
<v t="leo.20200907071201.1"><vh>C4F Blogger</vh>
<v t="leo.20200907151131.1"><vh>2954087361983949396</vh></v>
</v>
</v>
<v t="leo.20210210102942.1"><vh>@clean 20210210.md</vh>
<v t="leo.20210210103150.1"><vh>2021 開春</vh>
<v t="leo.20210210040142.1"><vh>kblogger</vh>
<v t="leo.20210210114545.1"><vh>7144358748564329698</vh></v>
</v>
<v t="leo.20210210040226.1"><vh>mblogger</vh>
<v t="leo.20210210034636.1"><vh>7059676961344698606</vh></v>
</v>
</v>
</v>
<v t="leo.20210210041040.1"><vh>@clean 20210210-1.md</vh>
<v t="leo.20210210041539.1"><vh>資料儲存的永續性</vh></v>
<v t="leo.20210210090621.1"><vh>kblogger</vh>
<v t="leo.20210210090616.1"><vh>8984536477325368541</vh></v>
</v>
<v t="leo.20210210090743.1"><vh>mblogger</vh>
<v t="leo.20210210090739.1"><vh>9047840174442464443</vh></v>
</v>
</v>
<v t="leo.20210210113926.1"><vh>@clean 20210210-2.md</vh>
<v t="leo.20210210114619.1"><vh>Pelican and Blogger</vh></v>
<v t="leo.20210210122050.1"><vh>kblogger</vh>
<v t="leo.20210210122043.1"><vh>4028954074708761875</vh></v>
</v>
<v t="leo.20210210122111.1"><vh>mblogger</vh>
<v t="leo.20210210122108.1"><vh>1017934646200675480</vh></v>
</v>
</v>
<v t="leo.20210211095825.1"><vh>@clean 20210211.md</vh>
<v t="leo.20210211100816.1"><vh>Fossil SCM on Ubuntu</vh></v>
<v t="leo.20210211110222.1"><vh>kblog</vh>
<v t="leo.20210211110217.1"><vh>5532982030328039326</vh></v>
</v>
<v t="leo.20210211110243.1"><vh>mblog</vh>
<v t="leo.20210211110239.1"><vh>7184156228296520978</vh></v>
</v>
</v>
<v t="leo.20210211133326.1"><vh>@clean 20210211-1.md</vh>
<v t="leo.20210211134529.1"><vh>Fossil SCM 使用案例</vh></v>
<v t="leo.20210211141444.1"><vh>kblog</vh>
<v t="leo.20210211141441.1"><vh>4819583018228146647</vh></v>
</v>
<v t="leo.20210211141512.1"><vh>mblog</vh>
<v t="leo.20210211141509.1"><vh>7197980596693849809</vh></v>
</v>
</v>
<v t="leo.20210212104928.1"><vh>@clean 20210212.md</vh>
<v t="leo.20210212045441.1"><vh>Fossil SCM 與 Github 整合</vh></v>
<v t="leo.20210212070247.1"><vh>kblog</vh>
<v t="leo.20210212070240.1"><vh>6431823803723457102</vh></v>
</v>
<v t="leo.20210212070300.1"><vh>mblog</vh>
<v t="leo.20210212070342.1"><vh>8811682943280171936</vh></v>
</v>
</v>
<v t="leo.20210216053228.1"><vh>@clean 20210216.md</vh>
<v t="leo.20210219033033.1"><vh>2021 課程規劃</vh></v>
<v t="leo.20210219033115.1"><vh>kblog</vh>
<v t="leo.20210219033110.1"><vh>7475536814986982700</vh></v>
</v>
<v t="leo.20210219033133.1"><vh>mblog</vh>
<v t="leo.20210219033130.1"><vh>427109942903154379</vh></v>
</v>
</v>
<v t="leo.20210219075408.1"><vh>@clean 20210219.md</vh>
<v t="leo.20210219075856.1"><vh>2021 Pelican 設定修改</vh></v>
<v t="leo.20210219082223.1"><vh>kblog</vh>
<v t="leo.20210219082217.1"><vh>4906733030754918917</vh></v>
</v>
<v t="leo.20210219082242.1"><vh>mblog</vh>
<v t="leo.20210219082240.1"><vh>1393216202742162615</vh></v>
</v>
</v>
<v t="leo.20210222144701.1"><vh>@clean 20210222.md</vh>
<v t="leo.20210222151517.1"><vh>2021 工作流程</vh></v>
<v t="leo.20210222162542.1"><vh>kblog</vh>
<v t="leo.20210222162539.1"><vh>6045688493427353593</vh></v>
</v>
<v t="leo.20210222162607.1"><vh>mblog</vh>
<v t="leo.20210222162602.1"><vh>7673398879237838185</vh></v>
</v>
</v>
<v t="leo.20210224100246.1"><vh>@clean 20210224.md</vh>
<v t="leo.20210224101026.1"><vh>2021nuklear</vh></v>
<v t="leo.20210224102437.1"><vh>kblog</vh>
<v t="leo.20210224102432.1"><vh>6352829255600809999</vh></v>
</v>
<v t="leo.20210224102509.1"><vh>mblog</vh>
<v t="leo.20210224102501.1"><vh>3638907969329314948</vh></v>
</v>
</v>
<v t="leo.20210306102210.1"><vh>@clean 20210306.md</vh>
<v t="leo.20210306102233.1"><vh>2021 cmsimde 修改</vh></v>
<v t="leo.20210306110554.1"><vh>kblog</vh>
<v t="leo.20210306110551.1"><vh>3499065018744387110</vh></v>
</v>
<v t="leo.20210306110613.1"><vh>mblog</vh>
<v t="leo.20210306110610.1"><vh>3332700928136370365</vh></v>
</v>
</v>
<v t="leo.20210306152423.1"><vh>@clean 20210306-1.md</vh>
<v t="leo.20210306152445.1"><vh>2001年讀書心得</vh></v>
<v t="leo.20210306153302.1"><vh>kblog</vh>
<v t="leo.20210306153256.1"><vh>2745474791922165974</vh></v>
</v>
<v t="leo.20210306153329.1"><vh>mblog</vh>
<v t="leo.20210306153326.1"><vh>8048058378627697211</vh></v>
</v>
</v>
<v t="leo.20210314151746.1"><vh>@@clean 20210314.md</vh>
<v t="leo.20210314151949.1"><vh>Fossil SCM 研究</vh></v>
</v>
</v>
</v>
</v>
<v t="yen.20170108171733.83"><vh>產生 .key 與 .crt 指令</vh></v>
</v>
<v t="yen.20170108171930.1"><vh>@button https server</vh></v>
<v t="yen.20170108171939.1"><vh>@button ipv6 https server</vh></v>
</vnodes>
<tnodes>
<t tx="leo.20170709015940.1"></t>
<t tx="leo.20170709015947.1"></t>
<t tx="leo.20170709020600.1"></t>
<t tx="leo.20170709224430.1">@language python
import os

os.system("pelican markdown -o blog -s publishconf.py")
g.es("admin pelican Github 執行完畢")


</t>
<t tx="leo.20170710015511.1"></t>
<t tx="leo.20170710015523.1"></t>
<t tx="leo.20170710015523.2"></t>
<t tx="leo.20170710022041.1"></t>
<t tx="leo.20170710022054.1"></t>
<t tx="leo.20170908162839.1"></t>
<t tx="leo.20170908162904.1"></t>
<t tx="leo.20180115093448.1"></t>
<t tx="leo.20180115093726.1"></t>
<t tx="leo.20180115115910.1"></t>
<t tx="leo.20180115142025.1"></t>
<t tx="leo.20180423103639.1"></t>
<t tx="leo.20200630103549.1">@language md
---
Title: 使用 Leo Editor
Date: 2020-06-30 11:00
Category: Leo Editor
Tags: leo editor
Slug: how-to-use-leo-editor
Author: yen
---

[Leo Editor] 的使用可以從 LEO_EDITOR 的環境變數設定開始, 讓多元的大綱管理流程, 成為您程式開發與資料管理上的一大利器.

&lt;!-- PELICAN_END_SUMMARY --&gt;

[Leo Editor]: https://leoeditor.com/

@others</t>
<t tx="leo.20200630104028.1">Leo Editor 與 SciTE
----

當使用 [KMOLab] 所建立的 Windows 64 位元操作系統環境下的可攜系統時, 只要在 start.bat 中, 加入 LEO_EDITOR 環境變數的設定, 使用者就可以將大綱中的 Python 程式, C 程式, Dart 程式或 Lua 程式碼, 直接帶到 [SciTE] 編輯器中執行.

&lt;pre class="brush: jscript"&gt;
REM 設定 Leo 所用的編輯器
set LEO_EDITOR=%Disk%:\wscite\SciTE.exe
&lt;/pre&gt;

[KMOLab]: http://lab.kmol.info/blog/index.html

對於比較簡單的 Python 程式段, 則可以直接在大綱對應的內文區, 直接透過 Ctrl + b 按鈕執行, 而比較複雜需要獨立執行的 Python 程式段, 則建議利用執行緒執行，以免拖累 [Leo Editor] 本體的執行.

&lt;pre class="brush: python"&gt;
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 5443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("5443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;

Leo Editor 的入門不容易
----

從 [Leo Editor] 的[開發歷史]來看, 自 1995 年啟動, 歷經使用 Borland C 與 Tkinter 等階段, 直到 2012 年採 Qt 作為圖形介面之後, 才開始穩定下來. 現在更有 [LeoVue] 與 [LeoInteg] 等兩個專案, 分別利用 Javascript 與 Typescript, 將 [Leo Editor] 帶進網際與 Visual Studio Code 的應用領域.

假如再加上最近 Qt 喊出的使用授權大變更, 接下來的 [Leo Editor] 開發可能即將面臨一波更大的轉變.

[Leo Editor] 的入門之所以不容易, 源自於其早期訂下的長遠目標, 因為試圖結合大綱編輯器與 [Literate Programming] 本來就是一條艱困的程式開發道路. 而且 [Leo Editor] 程式設計的思維大量依賴 Python 語法與 [Vim 原理], 同一個 [Leo Editor] 版本在不同操作系統的使用流程, 又因為各種原因而導致有許多獨門克服方法. 即便是同時使用 Mac, Linux 與 Windows 的老手, 都可能因為 [Leo Editor] 程式碼的快速改版而經常碰壁, 更別提初學者面對各種使用門檻時的無奈與慌亂.

[開發歷史]: https://leoeditor.com/history.html
[LeoVue]: https://github.com/kaleguy/leovue
[LeoInteg]: https://github.com/boltex/leointeg
[Literate Programming]: https://en.wikipedia.org/wiki/Literate_programming
[Vim 原理]: https://leoeditor.com/vim-theory.html
[SciTE]: https://www.scintilla.org/SciTE.html

但是又何奈
----

[KMOLab] 使用 [Leo Editor] 的時間已經超過 10 年, 期間仍然找不到其他替代工具. 只能利用 [SciTE] 來補足 [Leo Editor] 在 parse 大檔案過程效率的不足.</t>
<t tx="leo.20200630113823.1"></t>
<t tx="leo.20200630113832.1"></t>
<t tx="leo.20200630114610.1"></t>
<t tx="leo.20200630115346.1"></t>
<t tx="leo.20200907071201.1"></t>
<t tx="leo.20200907071233.1">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../mdecourse_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    #blog_id = blogs["items"][0]["id"]
    # blog_id for https://twcode4future.blogspot.com/
    blog_id = "3166335304502587571"
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 M Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
</t>
<t tx="leo.20200907150705.1">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../mdecourse_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    #blog_id = blogs["items"][0]["id"]
    # blog_id for https://twcode4future.blogspot.com/
    blog_id = "3166335304502587571"
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 C4FBlogger!")
except(client.AccessTokenRefreshError):
    g.es("error")

</t>
<t tx="leo.20200907151131.1"></t>
<t tx="leo.20210210034636.1"></t>
<t tx="leo.20210210040142.1"></t>
<t tx="leo.20210210040226.1"></t>
<t tx="leo.20210210041040.1">@language md
---
Title: 資料儲存的永續性
Date: 2021-02-10 11:10
Category: Weblog
Tags: 202102
Slug: data-sustainablity
Author: yen
---

假如將時間倒轉 20 年, 看看當時的電腦程式課程在教些什麼? 大家是如何上課, 結果應該會讓現在這些初出茅廬, 剛剛成年的大一生非常驚訝. 是的, 當年並沒有人手一機, 上課是需要抄筆記的......

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210210041539.1">而且當時全球科技界正度過所謂的千禧年之禍, 利用電腦程式產生中文字仍處於 Big-5 的陰影下, 倚天中文仍然到處可見, 即使處在所謂的數位科技前緣, 某些人手上已經有小而美的易利信手機, 口袋裡也放著一個由 HTC 打造的頗有重量 HP [PDA], 但所謂數位資料的永續性, 距離仍然很遠, 因此二十年多年後, 當時能留下與上課有關的數位資料非常有限.

[PDA]: https://en.wikipedia.org/wiki/Personal_digital_assistant
[Openshift]: https://en.wikipedia.org/wiki/Heroku
[Heroku]: https://en.wikipedia.org/wiki/Heroku

之後就在 Google 逐漸成熟, 而 Facebook 騰空出世 7 年後的 2011年, Red Hat 推出可以免費使用的 [Openshift], 不僅能夠伺服 PHP 與 Python, 還可免費存放各種數位資料, 當時以為資料終於可以永續存放的假象, 到 2016 年夢想逐漸破滅, 還好 2016 年之後有 Github 接手, Heroku 也很意外地從 2007 年活到現在, 目前, Github 與 Heroku (只能儲存 500 MB), 加上 Gitlab 的同步資料備份與 Google Drive 上的大檔案存放, 全球網友前撲後繼用隱私換取數位資料免費存放的所謂永續性,  似乎終於有了眉目.

目前教育版的 Google Drive 仍不限容量, 但也許未來的某一天這樣的所謂永續仍會畫上休止符, 大家仍必須有所因應.

資料存至 Google Drive
----

從 &lt;https://github.com/mdecourse/cd2020pj1/blob/master/myflaskapp.py&gt; 可以看出如何利用 Google Drive API, 在網際環境中將數位檔案送到特定伺服器之外, 還能利用 AJAX 存備份至特定 Google Drive 目錄.

&lt;pre class="brush: python"&gt;
@app.route('/saveToDB' , methods=['POST'])
@login_required
def saveToDB():

    """axuploader.js 將檔案上傳後, 將上傳檔案名稱數列, 以 post 回傳到 Flask server.
    
    截至這裡, 表示檔案已經從 client 上傳至 server, 可以再設法通過認證, 將 server 上的檔案上傳到對應的 Google Drive, 並且在上傳後的 GDrive 目錄, 設定特定擷取權限 (例如: 只允許 @gm 用戶下載.
    以下則可將 server 上傳後的擷取目錄與 GDrive 各檔案 ID 存入資料庫, 而檔案擷取則分為 server 擷取與 GDrive 擷取等兩種 url 連結設定
    """

    if request.method == "POST":
        files = request.form["files"]
        # split files string
        files = files.split(",")
        # files 為上傳檔案名稱所組成的數列
        for i in range(len(files)):
            # 逐一將已經存在 server downloads 目錄的檔案, 上傳到 GDrive uploaded 目錄
            fileName = files[i]
            fileLocation = _curdir + "/downloads/" + fileName
            mimeType = mimetypes.MimeTypes().guess_type(fileLocation)[0]
            # for GDrive v2
            #gdriveID = uploadToGdrive(fileName, mimeType)
            # for GDrive v3
            gdriveID = uploadToGdrive3(fileName, mimeType)
            fileSize = str(round(os.path.getsize(fileLocation)/(1024*1024.0), 2)) + " MB"
            date = datetime.datetime.now().strftime("%b %d, %Y - %H:%M:%S")
            user = session.get("user")
            print(user + "|" + str(fileSize) + "|" + str(mimeType) + "|"  + gdriveID)
            # 逐一將上傳檔案名稱存入資料庫, 同時存入mimeType, fileSize 與 gdriveID
            # 資料庫欄位
            #g.db.execute('insert into grouping (user , date, fileName, mimeType, fileSize, memo) values (?, ?, ?, ?, ?, ?)',(user, date, fileName, mimeType, fileSize, "memo"))
            #g.db.commit()
            #flash('已經新增一筆 upload 資料!')
    return "Uploaded fileName and gdriveID save to database"
def uploadToGdrive(fileName, mimeType):
    gauth = GoogleAuth()
    # 必須使用 desktop 版本的 client_secrets.json
    gauth.LoadClientConfigFile("./../gdrive_desktop_client_secrets.json")
    drive = GoogleDrive(gauth)
    
    '''
    # View all folders and file in your Google Drive
    fileList = drive.ListFile({'q': "'root' in parents and trashed=false"}).GetList()
    for file in fileList:
      print('Title: %s, ID: %s' % (file['title'], file['id']))
      # Get the folder ID that you want
      # 檔案會上傳到根目錄下的 uploaded  目錄中
      if(file['title'] == "uploaded"):
          fileID = file['id']
    '''
    # GDrive 上 uploaded 目錄的 fileID
    with open("./../gdrive_uploaded_id.txt", 'r') as content_file:
        fileID = content_file.read()
    
    # 由上述目錄外的檔案讀取 uploaded 目錄對應 ID
    #fileID = "your_folder_file_ID"
    # 上傳檔案名稱為輸入變數
    #fileName = "DemoFile.pdf"
    filePath = _curdir + "/downloads/"
    # parents 為所在 folder, 亦即 uploaded 目錄, fileID 為 uploaded 目錄的 ID
    file1 = drive.CreateFile({"mimeType": mimeType, "parents": [{"kind": "drive#fileLink", "id": fileID}], "title":  fileName})
    file1.SetContentFile(filePath + fileName)
    file1.Upload() # Upload the file.
    # 傳回與上傳檔案對應的 GDrive ID, 將會存入資料庫 gdiveID 欄位
    return file1['id']
    #print('Created file %s with mimeType %s' % (file1['title'], file1['mimeType']))   
    #print("upload fileID:" + str(file1['id']))
    # 以下為下載檔案測試
    # file2 = drive.CreateFile({'id': file1['id']})
    #file2.GetContentFile('./test/downloaded_ModernC.pdf') # Download file as 'downloaded_ModernC.pdf under directory test'.
    
    '''
    file1.Trash()  # Move file to trash.
    file1.UnTrash()  # Move file out of trash.
    file1.Delete()  # Permanently delete the file.
    '''
def uploadToGdrive3(fileName, mimeType):
    # get upload folder id
    # GDrive 上 uploaded 目錄的 fileID
    with open("./../gdrive_uploaded_id.txt", 'r') as content_file:
        folderID = content_file.read()

    creds = None
    with open('./../gdrive_write_token.pickle', 'rb') as token:
        creds = pickle.load(token)
    # 讀進既有的 token, 建立 service
    driveService = build('drive', 'v3', credentials=creds)

    metadata = {
        'name': fileName,
        'mimeType': mimeType,
        # 注意: 必須提供數列格式資料
        'parents': [folderID]
        }

    filePath = _curdir + "/downloads/" + fileName
    media = MediaFileUpload(filePath,
                                            mimetype=mimeType,
                                            chunksize=1024*1024,
                                            resumable=True
                                            )

    gdFile = driveService.files().create(
        body=metadata,
        media_body=media,
        fields='id'
    ).execute()
    fileID = gdFile.get("id")

    return fileID
&lt;/pre&gt;

上述程式利用較新的 GDrive V3 上傳資料之前, 可攜系統必須安裝 google-api-python-client:

&lt;pre class="brush:python"&gt;
# for uploadToGDrive3
# pip install google-api-python-client
# https://github.com/googleapis/google-api-python-client
import pickle
from googleapiclient.discovery import build
from apiclient.http import MediaFileUpload
&lt;/pre&gt;

[Fossil SCM]: https://fossil-scm.org
[BD-R or BD-RE]: https://en.wikipedia.org/wiki/Blu-ray_Disc_recordable

Github, Gitlab 與 Fossil SCM
----

針對 Github 與 Gitlab 的操作, 可以參考 &lt;https://git-scm.com/book/en/v2&gt;, 但是 [Fossil SCM] 的參考資料則相對較少, 以下將針對 [Fossil SCM] 的應用稍加說明, 為了因應未來上述各種網際免費數位儲存資料系統的更迭, 在近端配置 [Fossil SCM], 並用 [BD-R or BD-RE] (25GB) 進行備份, 也是一個不錯的資料永續儲存方案.

[Fossil SCM] 的使用非常簡單, 只要配合操作系統從 &lt;https://fossil-scm.org/home/uv/download.html&gt; 下載相應版本, 並讓系統可以執行 fossil.exe (以 Windows 10 為例) 即可, 唯一要注意的是若操作過程牽涉兩個不同操作系統, 必須透過 fossil version 查驗雙方的版本是否相同.

有關 [Fossil SCM] 的先前參考資料, 可參閱 [Fossil SCM 簡介].

Ubuntu 安裝 fossil scm
----

使用 sudo apt install fossil 安裝 [Fossil SCM] 所取得的版本可以利用 fossil version 檢查. 若版本並非最新版本或與 Windows 10 所用的版本相同, 可以至 &lt;https://fossil-scm.org/home/uv/download.html&gt; 下載最新的 fossil 後, 以 sudo cp /home/user/fossil /usr/bin/, 然後再透過 fossil version 查驗是否已經更新為最新版本.

安裝 stunnel4
----

由於 [Fossil SCM] 並無 https 啟動功能的設置, 因此在實作上必須透過 stunnel SSL 代理主機啟動 https 伺服功能.

首先安裝 stunnel4:

sudo apt install stunnel4

接下來將系統環境設為 HTTPS:

sudo vi /etc/environment

加入 HTTPS=on

並且在 /etc/default/stunnel4 中加入 ENABLED=1

然後透過 sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt, 在 /etc/stunnel/ 目錄中建立所需的 localhost.key 與 localhost.crt

同時建立 /etc/stunnel/stunnel.conf 如下:

&lt;pre class="brush: jscript"&gt;
[https]
accept = your_IPv4_ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021
&lt;/pre&gt;

實際配置下, 使用 :::443 並無法讓 stunnel 綁定至系統的 ipv6 網址, 必須使用:

&lt;pre class="brush: jscript"&gt;
[https]
accept = 140.xxx.xxx.xxx:443
accept = 2001:288:6004:xx::1:443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021
&lt;/pre&gt;

似乎 stunnel 會自動取最後的 :443 作為 port, 而無需如 https://[ipv6 address]:443 中以 [] 隔開 ipv6 網址與埠號.

execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021 設定的意思為 stunnel 代理啟動的指令為 fossil http, 指定 /home/yser/repository/ 作為倉儲目錄, 可以透過 URL 加上倉儲名稱伺服多個 repo.fossil 倉儲, 隨後的 --https 表示要使用 https 協定擷取資料, --nojail 表示不要使用 root 權限啟動, 且不進入 jail 模式, --notfound cd2021 表示內定  https URL 擷取的倉儲為 /home/user/repository/cd2021.fossil

啟動-停止-重新啟動 stunnel4.service
----

sudo systemctl start stunnel4.service

sudo systemctl stop stunnel4.service

sutod systemctl restart stunnel4.service


[Fossil SCM 簡介]: http://mde.tw/2017springcd/blog/intro-fossil-scm.html
</t>
<t tx="leo.20210210090616.1"></t>
<t tx="leo.20210210090621.1"></t>
<t tx="leo.20210210090739.1"></t>
<t tx="leo.20210210090743.1"></t>
<t tx="leo.20210210102942.1">@language md
---
Title: 2021 開春
Date: 2021-02-10 11:00
Category: Weblog
Tags: 202102
Slug: starting-2021
Author: yen
---

2021 年伊始, 機器學習的程式從原先簡單的演化, 進展到能夠有效控制具有亂數的決策系統, 科技的發展讓人類的工作更加兩極化, 一方可持續開發指使電腦軟硬體從事工作, 而另一方則幾乎必須完全按照電腦軟硬體的指示與命令行事.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210210103150.1">這樣的發展似乎已經沒了退路.</t>
<t tx="leo.20210210113926.1">@language md
---
Title: Pelican 與 Blogger 內容同步2
Date: 2021-02-10 11:20
Category: Weblog
Tags: 202102
Slug: sync-pelican-and-blogger-content2
Author: yen
---

[cmsimde] 中的 Pelican blog 內容建議採用 config 目錄中的 pelican.leo 進行管理, 主要的資料管理架構採用 [Leo Editor] 中的 [@clean] 標題指令, 能夠與內文指令 [@others] 配合, 利用階層式的文章管理, 區隔網誌摘要與各段內容.

[cmsimde]: https://github.com/mdecourse/cmsimde
[@clean]: https://leoeditor.com/directives.html#clean-path
[@others]: https://leoeditor.com/directives.html#part-2-all-and-others

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others

</t>
<t tx="leo.20210210114545.1"></t>
<t tx="leo.20210210114619.1">Google Developer Console
----

為了能夠將 [Pelican blog] 在 [Leo Editor] 中的網誌文章推向 [Blogger], 必須要從 [Google developer console] 取得
與 [Blogger] 擷取權限對應的 secret json 檔案. 實際操作流程如下:

進入 Library - &gt; ENABLE APIS AND SERVICES -&gt; 啟用 Blogger API v3

設定 OAuth consent screen 

新增 Credentials -&gt; Desktop-type Oauth 2.0 client -&gt; Download JSON 即可取得 secret.json 檔案.


[Google developer console]: https://console.developers.google.com
[Pelican blog]: https://blog.getpelican.com/
[Blogger]: https://www.blogger.com
[Leo Editor]: https://leoeditor.com/

將 secrets.json 轉為 token.dat
----

轉換前必須確定系統已經安裝 google_auth_oauthlib

pip install google_auth_oauthlib

接著利用下列程式將 secrets.json 轉為 token.dat, 隨後使用者就可利用此一  token.dat 將 [Leo Editor] 中的網誌文章內容傳送到對應的 [Blogger].

下列程式在轉換過程會透過操作系統的內定瀏覽器讓使用者登入與 secrets.json 對應的帳號, 一旦通過認證就可以完成 secrets.json 轉為 token.dat 的流程.

&lt;pre class="brush: python"&gt;
# get secrets: https://console.developers.google.com
# https://developers.google.com/blogger/docs/3.0/using
# pip install google_auth_oauthlib
# under Mac command + b to execute
import pickle
import os
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request


SCOPES = ['https://www.googleapis.com/auth/blogger', ]

# we check if the file tBo store the credentials exists
if not os.path.exists('./../../yen_gm_blogger_token.dat'):

    flow = InstalledAppFlow.from_client_secrets_file('./../../yen_gm_blogger_secrets.json', SCOPES)
    credentials = flow.run_local_server()

    with open('yen_gm_blogger_token.dat', 'wb') as credentials_dat:
        pickle.dump(credentials, credentials_dat)
else:
    with open('yen_gm_blogger_token.dat', 'rb') as credentials_dat:
        credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
g.es(service)
&lt;/pre&gt;

將 Pelican 文章轉往 Blogger
----

將 Pelican 文章轉投 Blogger 的過程包含新增與編輯, 新增的程式碼如下:

&lt;pre class="brush: python"&gt;
@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 KBlogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

完成上述文章轉投至 Blogger 之後, [Blogger] 會傳回該文章的 post id, 而新增程式會將此 id 放在該筆 @clean 文章節點的最末端, 由於該  post id 節點只有標題而無內文, 因此即便內縮成為 @clean 的子節點, 也不會在文章中增加任何資料, 但若該網誌內容同步推向一個以上的 [Blogger], 則使用者需要將該 post if 內縮外, 還需要在此 post id 節點的上屬節點增加標註, 說明該 post id 所屬的網誌標題或代號.

至於當該文章內容經過編修後, 使用者若希望將新內容推向遠端同步 [Blogger], 則必須將原先新增的 [Blogger] post id 移至該 @clean 文章的最末端, 以便讓程式可以更新與此 post id 對應的 [Blogger] 文章內容.

可用於編輯 [Blogger] 文章的程式碼如下:
    
&lt;pre class="brush: python"&gt;
@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 K Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;
</t>
<t tx="leo.20210210122043.1"></t>
<t tx="leo.20210210122050.1"></t>
<t tx="leo.20210210122108.1"></t>
<t tx="leo.20210210122111.1"></t>
<t tx="leo.20210211095825.1">@language md
---
Title: Fossil SCM on Ubuntu
Date: 2021-02-11 11:00
Category: Weblog
Tags: 202102
Slug: fossil-scm-on-ubuntu
Author: yen
---

[Fossil SCM] 是一套完整的[軟體組態管理系統] ([Software Configuration Management]), 以 ANSI C 編寫, 其中利用 [TCL] 作為 Scripting 語言. 接下來將要說明如何在 Ubuntu 20.04 中安裝與配置 [Fossil SCM].

[Fossil SCM]: https://www.fossil-scm.org
[TCL]: https://en.wikipedia.org/wiki/Tcl
[軟體組態管理系統]: https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86
[Software Configuration Management]: https://en.wikipedia.org/wiki/Software_configuration_management

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210211100816.1">這裡所要介紹的 [Fossil SCM] 為 &lt;http://fossil.kmol.info&gt; (只配置 IPv6 網路協定), http 網際伺服器前端採用 [nginx], https 代理伺服器採用 [stunnel], 主要伺服的 [Software Configuration Management] 套件則為 [Fossil SCM].

安裝 [nginx]
----

在 Ubuntu 20.04 中安裝 [nginx] 非常簡單, 只要執行 sudo apt install nginx 即可.

[nginx] 的基本設定檔案位於 /etc/nginx/sites-available/default

安裝 [nginx] 有兩個目的, 一方面回應 &lt;http://fossil.kmol.info&gt;, 也就是 port 80 的 WWW 伺服器. 而另外一方面則是配合 &lt;https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx&gt; 以手動模式取得 [stunnel] https 伺服所需要的 fullchain.pem 與 privkey.prm 等兩個檔案.

安裝 [Fossil SCM]
----

在 Ubuntu 20.04 安裝 [Fossil SCM] 也非常簡單, 只要執行 sudo apt install fossil 即可. 但是所安裝的版本可能不是最新版, 由於安裝的 fossil 執行檔案位於 /usr/bin/fossil, 假如希望與 Windows 10 64 位元操作系統中的 [Fossil SCM] 對應, 可以至 &lt;https://fossil-scm.org/home/uv/download.html&gt; 下載 Linux 最新版本的 fossil, 然後以 sudo cp fossil /urs/bin/ 即可. 若要查驗 [Fossil SCM] 的版本, 可以使用 fossil version 指令.

[Fossil SCM] 整個系統就只有一個 fossil 執行檔案, 而倉儲檔案則只全部壓縮在一個 [SQLite] 資料庫檔案中.

接下來為了配置一套可以伺服多個 [Fossil SCM] 倉儲的 Ubuntu 20.04 系統, 在 /home/user/ 目錄下建立 repository 目錄, 之後的所有要從遠端擷取的 [Fossil SCM] 倉儲都可以放在此一用戶目錄下. 至於要在此目錄下建立一個內定的 [Fossil SCM] 倉儲, 可以進入 /home/user/repository 目錄後 (這裡的 user 為 Ubuntu 20.04 下的用戶帳號名稱), 以 fossil init cd2021.fossil 建立一個 [Fossil SCM] 倉儲, 執行完後系統就會直接在命令列中顯示用來管理此一倉儲的用戶 (會使用建立倉儲的帳號, 也就是 user) 登入管理的密碼.

使用者可以選擇將此一與 user 對應的管理密碼記起來, 或者之後再使用 sqlite3 指令進入 cd2021.fossil 查詢.

假如使用者需要在 Ubuntu 環境中直接對 [Fossil SCM] 倉儲改版, 則建議在 /home/user/repository 目錄中再建立一個 wd 目錄 (為 working directory 的縮寫), 之後可以將位於 /home/user/repository 目錄中的各個 .fossil 內容, 在 /home/user/repository/wd 目錄中展開, 若以 /home/user/repository/cd2021.fossil 為例, 展開後將位於 /home/user/repository/wd/cd2021.

安裝 [stunnel]
----

安裝 [stunnel] 也很簡單, 只要執行 sudo apt install stunnel4 即可, 安裝後若要隨系統開機啟動, 則需要 sudo vi /etc/default/stunnel4, 並在檔案中加入 ENABLED=1 後存檔.

另外, 還需要 sudo vi /etc/environment, 並在檔案中加入 HTTPS=on 後存檔.

接下來為了由 [stunnel] 代理 [Fossil SCM] 的 https 伺服, 必須加入 /etc/stunnel/stunnel.conf

&lt;pre class="brush: jscript"&gt;
[https]
accept = 140.130.your_ipv4.ip:443
accept = 2001:288:6004:your:ipv6::ip:443
cert = /etc/stunnel/fullchain.pem
key = /etc/stunnel/privkey.pem
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021
&lt;/pre&gt;

上述的 fullchain.pem 與 privkey.pem 由於尚未配置 [certbot], 必須要取得合法的數位簽章檔案後, 再利用:

sudo systemctl start stunnel4.service 

啟動 [stunnel].

sudo systemctl stop stunnel4.service

關閉 [stunnel], 或利用:

sudo systemctl restart stunnel4.service

重新啟動 [stunnel].

擷取 fullchain.pem 與 privkey.pem
----

這個步驟主要按照 &lt;https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx&gt; 中的指令操作, 由於 Ubuntu 20.04 已經內建 snap, 因此只要執行:

sudo snap install core; sudo snap refresh core

sudo snap install --classic certbot

sudo ln -s /snap/bin/certbot /usr/bin/certbot

sudo certbot certonly --nginx

就可以在 /etc/letsencrypt/live/fossil.kmol.info/ 目錄中找到 fullchain.pem 與 privkey.pem 等兩個數位簽章檔案, 接著將此兩個檔案複製至 /etc/stunnel/ 目錄, 以便配合 /etc/stunnel/stunnel.conf 隨電腦開機啟動.

因為 [certbot] 的數位簽章每 90 天都要更新一次, 屆時若要手動更新可以先模擬執行:

sudo certbot renew --dry-run

nginx http 跳轉 https
----

最後一個步驟是讓 [nginx] 所伺服的 &lt;http://fossil.kmol.info&gt; 能夠自動跳轉到 [Fossil SCM] 與 [stunnel] 結合的 &lt;https://fossil.kmol.info&gt;

修改 /etc/nginx/sites-available/default 中的設定如下:

&lt;pre class="brush: jscript"&gt;
server {
listen 80;
server_name fossil.kmol.info;
rewrite ^/(.*)$ https://fossil.kmol.info/$1 permanent;
}
&lt;/pre&gt;


[nginx]: https://nginx.org/
[stunnel]: https://www.stunnel.org/
[SQLite]: https://www.sqlite.org
[certbot]: https://certbot.eff.org/
</t>
<t tx="leo.20210211110217.1"></t>
<t tx="leo.20210211110222.1"></t>
<t tx="leo.20210211110239.1"></t>
<t tx="leo.20210211110243.1"></t>
<t tx="leo.20210211133326.1">@language md
---
Title: Fossil SCM 使用案例
Date: 2021-02-11 11:10
Category: Weblog
Tags: 202102
Slug: fossil-scm-use-case
Author: yen
---

請注意: &lt;http://fossil.kmol.info&gt; 僅支援 IPv6 網路協定.

[Fossil SCM] 的 &lt;https://fossil-scm.org/home/doc/trunk/www/embeddeddoc.wiki&gt; 可以與靜態網頁結合應用, 唯一必須注意的是 &lt;https://fossil-scm.org/home/doc/trunk/www/defcsp.md&gt; 議題.

[Fossil SCM]: https://www.fossil-scm.org

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210211134529.1">[Fossil SCM] documentation 功能
----
先前已經建議 [Fossil SCM] 的倉儲可以放在 /home/user/repository/ 目錄中, 以這裡的範例分別為 /home/user/repository/cd2021.fossil 與 /home/user/repository/lab.fossil, 而這兩個倉儲的展開內容分別位於 /home/user/repository/wd/cd2021 與 /home/user/repository/wd/lab 等目錄.

透過 [Fossil SCM] 的 &lt;https://fossil-scm.org/home/help/http&gt; 指令與 [stunnel] 的結合運用可以伺服為:

&lt;http://fossil.kmol.info/cd2021/doc/trunk/index.html&gt;

與

&lt;http://fossil.kmol.info/lab/doc/trunk/index.html&gt;

而這兩個 [Fossil SCM] 倉儲的靜態網頁與 &lt;https://mde.tw/cd2021&gt; 及 &lt;https://mde.tw/lab&gt; 內容保持同步. 且 [Fossil SCM] 的靜態網頁可以直接將網址中的 trunk (表示為最新版本) 換為 [Fossil SCM] 倉儲內容的對應版本號, 就可以直接顯示各舊版本的靜態網頁內容, 這一個功能至今連 &lt;https://pages.github.com/&gt; 或 &lt;https://docs.gitlab.com/ee/user/project/pages/&gt; 都還無法直接在網際介面中完成.

[Fossil SCM] open, add 與 commit
----

之前已經提過, 建立 [Fossil SCM] 倉儲的方法:

fossil init cd2021.fossil

而這個指令若直接在 /home/user/repository/ 目錄中執行, 則可以建立 cd2021.fossil 空倉儲.

這裡的規劃是將這些倉儲以 fossil open 指令, 在 /home/user/repository/wd 目錄中設法展開內容, 而且以倉儲的名稱作為展開後的目錄, 並將展開內容置入.

例如:

/home/user/repository/cd2021.fossil 可以透過:

在 /home/user/repository/wd/cd2021/ 目錄中執行 fossil open ./../../cd2021.fossil 而將內容展開.

而 /home/user/repository/lab.fossil 則在 /home/user/repository/wd/lab 目錄中展開內容.

若從 Github 以:

git clone --recurse-submodules https://github.com/mdecourse/cd2021.git 

將 cd2021 倉儲內容取下, 而且放入 /home/user/repository/wd/cd2021/ 目錄中.

使用者就可以在 /home/user/repository/wd/cd2021/ 目錄中執行:

fossil add .

fossil commit -m "add cd2021 git repository content"

則 [Fossil SCM] 會將 /home/user/repository/wd/cd2021/ 已經改版的內容壓進 /home/user/repository/cd2021.fossil 倉儲中, 並透過 [Fossil SCM] http 將靜態網頁以 project documentation 功能伺服到 &lt;https://fossil.kmol.info/cd2021/doc/trunk/index.html&gt;.

而根據網站內容, 必須將 https://fonts.googleapis.com 放入 settings - default-csp 設定欄位中, [Fossil SCM] doc 網站才會允許 default-csp 設定的網站進行跨網站擷取所需的資料.

採取相同的操作步驟, 就可以將 &lt;https://mde.tw/lab&gt; 網站資料同步至 &lt;http://fossil.kmol.info/lab/doc/trunk/index.html&gt;

[stunnel]: https://www.stunnel.org/</t>
<t tx="leo.20210211141441.1"></t>
<t tx="leo.20210211141444.1"></t>
<t tx="leo.20210211141509.1"></t>
<t tx="leo.20210211141512.1"></t>
<t tx="leo.20210212045441.1">一開始, 利用 &lt;https://github.com/mdecourse/cmstemplate&gt; 作為樣板, 建立一個 &lt;https://github.com/mdecourse/fosgit&gt; 倉儲, 並且分別在 Ubuntu 與 Windows 10 中進行操作, 目標是分別利用 [Fossil SCM] 與 Github 管理 &lt;https://mde.tw/fosgit&gt; 與 &lt;http://fossil.kmol.info/fosgit/doc/trunk/index.html&gt; 兩個網站的對應倉儲.

建立 fosgit 倉儲
----

在 Github 登入後, 新增 fosgit 倉儲時, 在上方 template 選單, 選擇以 &lt;https://github.com/mdecourse/cmstemplate&gt; 作為 template, 意即要直接利用 CMSiMDE 建立一個動態網站與靜態網站, 名稱為 fosgit.

完成後的倉儲位於 &lt;https://github.com/mdecourse/fosgit&gt;, 透過 Github 的設定將 main 分支設為 Github Pages 的 root, 接著就可以設法將倉儲以:

git clone --recurse-submodules https://github.com/mdecourse/fosgit.git

取下倉儲資料到 Ubuntu 或 Windows 10 操作系統中, 之所以需要使用 --recurse-submodules 選項的原因是 cmstemplate 倉儲帶有子模組, 使用者可以直接透過上述指令取下包含子模組的倉儲所有資料.

Ubuntu 端操作
----

由於 fosgit 倉儲在 [Fossil SCM] 端希望透過 &lt;http://fossil.kmol.info/fosgit&gt; 進行管理, 為了方便, 可以直接以 ssh 登入 fossil.kmol.info 主機進行操作.

首先就是在 /home/user/repository/ 目錄中, 以  fossil init fosgit.fossil 建立 fosgit.fossil 空的倉儲檔案.

接著進入 /home/user/repository/wd/ 目錄中, 以 git clone --recurse-submodules https://github.com/mdecourse/fosgit.git 將 Github 端的倉儲 clone 至 /home/user/repository/wd/fosgit 目錄.

Fossil SCM .fslckout
----
由於 Ubuntu [Fossil SCM] 倉儲的內容存在 .fslckout 檔案中, 因此  /home/user/repository/wd/fosgit 目錄中雖然已經有與 Github 遠端倉儲對應的 .git 目錄, 但還需要能與 &lt;http://fossil.kmol.info/fosgit&gt; 對應的 .fslckout, 為了取得此一資料檔案. 可以進入 fossil.kmol.info 主機中的 /home/user/repository/ 目錄, 以 fossil init fosgit.fossil 建立, 隨後則進入 /home/user/repository/wd/fosgit 目錄執行 fossil open ./../../fosgit.fossil, 將 fosgit.fossil 對應的 .fslckout 放入  /home/user/repository/wd/fosgit 目錄.

這時, 因為 &lt;http://fossil.kmol.info/fosgit&gt; settings 已經勾選 dotfiles (V), 因此 [Fossil SCM] 倉儲會導入 .git 目錄, 同時 [Fossil SCM] 的版本資料 .fslckout (或隨後的 _FOSSIL_) 也會被 Github 納管.

[Fossil SCM] addremove 指令
----

上述的規劃, 若從 cmsimde/ 目錄中執行 python wsgi.py, 可以在近端對倉儲內容作變更, 其中可能包括刪除倉儲中的某些檔案. 這時若要讓系統自動將已經刪除的檔案納入版次管理, 可以使用 [git addremove] 指令.

[git addremove]: https://fossil-scm.org/home/help/addremove</t>
<t tx="leo.20210212070240.1"></t>
<t tx="leo.20210212070247.1"></t>
<t tx="leo.20210212070300.1"></t>
<t tx="leo.20210212070342.1"></t>
<t tx="leo.20210212104928.1">@language md
---
Title: Fossil SCM 與 Github 整合
Date: 2021-02-12 11:00
Category: Weblog
Tags: 202102
Slug: fossil-scm-and-github-integration
Author: yen
---

請注意: &lt;http://fossil.kmol.info&gt; 僅支援 IPv6 網路協定.

為了實際了解 [Fossil SCM] 與 Github 的同一倉儲內容資料, 應該如何整合, 特別建立了一個 fosgit 倉儲作為測試.

[Fossil SCM]: https://www.fossil-scm.org

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210216053228.1">@language md
---
Title: 2021 Spring 課程規劃
Date: 2021-02-16 11:00
Category: Weblog
Tags: 202102
Slug: 2021-spring-course-planning
Author: yen
---

請注意: &lt;http://fossil.kmol.info&gt; 僅支援 IPv6 網路協定.

每年的 Spring [KMOLab] 共開兩門課程, 網際內容管理與協同產品設計實習, 基本的課程規劃仍以承接 Fall 的計算機程式及電腦輔助設計實習為主.

[Fossil SCM]: https://www.fossil-scm.org
[Github]: https://github.com/
[Gitlab]: https://gitlab.com/
[Heroku]: https://www.heroku.com/
[Blogger]: https://www.blogger.com/
[KMOLab]: http://mde.tw

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others
</t>
<t tx="leo.20210219033033.1">重新導入 [Fossil SCM]
----

2021 年除了使用各種免費雲端儲存空間與分散式版次管理系統外, 特別又將能簡易配置在自架伺服器上的 [Fossil SCM] 拿了出來. 主要原因是 [Fossil SCM] 在功能提升與 IPv6 的環境下已經有大幅進步. 因此各種課程相關資料除了放在 [Github], [Gitlab] 與 [Heroku] (只限存 500 MB), 也將同步存入近端工作站室中的實體或虛擬主機 [Fossil SCM] 系統中. (例如: &lt;http://mde.tw/cd2021&gt; 與 &lt;http://fossil.kmol.info/cd2021/doc/trunk/index.html&gt; 為同步資料, 其倉儲分別為 &lt;https://github.com/mdecourse/cd2021&gt; 與 &lt;http://fossil.kmol.info/cd2021&gt;)

五專部網際內容管理課程規劃
----

Spring 的網際內容管理課程分別開設在五專一精密機械工程科與四技一機械設計工程系, 因為五專一是高中一年級入學的下學期課程, 上學期只上過計算機概論, 因此五專的網際內容管理課程就從 [Blogger] 的網際內容管理系統導入作為開端.

[Blogger] 是與 Google 帳號整合的 Blog 系統, 而 Blog 則是一種依照發佈時間排序的內容記錄, 五專課程一開始就是要求每一位學員利用學校配發的"學號@gm.nfu.edu.tw"建立自己的網際內容管理課程網誌, 並且將上學期的計算機概論課程摘要一一紀錄, 除了讓學員熟悉如何使用 [Blogger] 之外, 也讓學員能夠多多練習英文與中文打字, 尤其是除了中文注音輸入之外, 至少再學一套較有未來性的中文輸入法.

五專的網際內容管理系統除了 [Blogger] 之外, 將從如何整理各學員的 [Blogger] 網際連結切入, 讓學員對於 [HTML] 與 [全球資訊網] 能有初步認識, 其中將會包含如何利用 [CMSiMDE] 在  [Github] , [Gitllab], [Heroku] 與 [Fossil SCM] 中建立個人課程網頁系統. 並且讓學員逐步熟悉電腦與網路的設定與應用, 同時透過 Windows 10 64 位元操作系統上的可攜程式環境, 讓學員了解英文與程式應用的重要性.

四技部網際內容管理課程規劃
----

四技部的網際內容管理, 除了包含上述五專部的課程內容之外, 將要從 [nfulist] 程式的架構導入, 讓學員應用近端與雲端程式擷取學校教務主機中的資料. 其次還希望各學員能夠在自己的電腦上配置學校所能取得的合法 CAD 與 CAE 套件, 並且有能力採用網際程式 API 的模式延伸這些封閉套件的功能, 至少有能力可以根據 &lt;http://mde.tw/cad2020/content/HW1_SW.html&gt; 的導引, 結合初步的網際協同程式 &lt;https://github.com/mdecourse/cd2020pj1&gt;, 開發各種與機械協同設計相關的網際延伸應用, 或者設法[改寫 CMSiMDE].

協同產品設計實習課程規劃
----

2021 年的協同產品設計實習所採用的規劃是三段式協同的步驟, 從兩人一組, 四人一組到最後八人一組的設計流程, 讓各學員實際了解協同設計的基本元素是人, 工具與時間, 傳統的設計工具若沒有網路的串連, 較難產生同步協同效益, 但是網路與同步協同模式也帶來許多問題.

2020 年的疫情讓全球各企業許多員工被迫必須[在家上班], 而 work from home 的模式包含協同產品設計流程中的同步與非同步協同, 幾乎所有的成員溝通都必須透過網路與視訊工具達成. (例如: &lt;http://mde.tw/cd2020/content/Covid-19.html&gt; 與 &lt;http://mde.tw/cd2020/content/Online%20course.html&gt;), 而這個學期的協同產品設計實習重點除了 [Onshape], [Coppeliasim], [Webots] 與 [Fossil SCM] 外, 也將納入 [Ethercalc] 的 [API 應用] 以及 [Jitsi] 視訊會議系統的使用.

[HTML]: https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/HTML_basics
[全球資訊網]: https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91
[CMSiMDE]: https://github.com/mdecourse/cmsimde
[nfulist]: https://github.com/mdecourse/nfulist
[改寫 CMSiMDE]: http://mde.tw/wcm2021/content/CMSiMDE.html
[在家上班]: https://en.wikipedia.org/wiki/Telecommuting
[Onshape]: https://onshape.com
[Coppeliasim]: https://www.coppeliarobotics.com/
[Webots]: https://cyberbotics.com/
[Ethercalc]: https://github.com/audreyt/ethercalc
[API 應用]: http://mde.tw/cd2021/content/Programming.html
[Jitsi]: https://meet.pdis.tw/
</t>
<t tx="leo.20210219033110.1"></t>
<t tx="leo.20210219033115.1"></t>
<t tx="leo.20210219033130.1"></t>
<t tx="leo.20210219033133.1"></t>
<t tx="leo.20210219075408.1">@language md
---
Title: 2021 Pelican 設定修改
Date: 2021-02-19 11:00
Category: Weblog
Tags: 202102
Slug: 2021-kmolab-pelican-setup-modification
Author: yen
---

請注意: &lt;http://fossil.kmol.info&gt; 僅支援 IPv6 網路協定.

利用 [Leo Editor] 開啟 [CMSiMDE] 中的 config/pelican.leo, 然後利用 control + i 插入一個新的節點, 將節點標題改為 @clean 20210219.md, 表示要利用 @clean 指令在 markdown 目錄中新增一個 20210219.md 的 Markdown 格式檔案.

[Fossil SCM]: https://www.fossil-scm.org
[Github]: https://github.com/
[Gitlab]: https://gitlab.com/
[Heroku]: https://www.heroku.com/
[Blogger]: https://www.blogger.com/
[KMOLab]: http://mde.tw
[Leo Editor]: https://leoeditor.com/
[CMSiMDE]: https://github.com/mdecourse/cmsimde
[Pelican Blog]: https://blog.getpelican.com/

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210219075856.1">接著從先前的網誌中複製網誌文章的標頭格式資料, 修改標題與日期, 並且留意 slug 中必須要採用唯一的檔案名稱, 然後就可以先寫網誌的摘要, 之後再利用 @others 標註將隨後子節點中的內文區全部整合到 20200219.md 檔案中.

然後就可以開始寫特定主題的網誌內容.

slug 名稱必須唯一
----

假如你曾經見過網路上的網路文章除了英文標題外, 隨後還有一串不短的數字, 這一串數字就是與前面的文章主題結合, 然後可能用做該文章儲存的檔案名稱, 主要用來確認該主題加上數字的字串在系統中具有唯一性.

所謂同步
----

其實在各網誌間的所謂同步, 並非及時同步, 而是在各種可能的情況下儘量讓多方的資料內容保持相同. 那麼在完全同步之間的影響因素就是時間, 因為將資料從一系統轉到另一個系統需要時間. 以 [CMSiMDE] 上的 [Pelican Blog] 轉到 [Blogger], 需要在 [Leo Editor] 以程式按鈕執行, 而實際操作過程需要將滑鼠停留在網誌文章節點, 然後點擊新增 [Blogger] 或編輯 [Blogger] 的程式按鈕, 一旦 [Pelican Blog] 的網誌文章正確存入對應的 [Blogger] 系統後, [Blogger] 會傳回 blog id, 並且透過程式安排將此一 blog id 存為該網誌文章的子節點標題, 而且是沒有內容的文章標題, 因此這些用來標註所屬 [Blogger] 與 blog id 的資料並不會影響 @others 導入子節點文章內容的功能.

由於目前的程式只會從網誌文章的最後一個節點存取 blog id, 因此若將同一篇網誌文章同步公開到多麼 [Blogger], 新增或編輯時除了要注意滑鼠是否停留在文章主節點外, 還必須在新增與編輯過程手動搬遷這些 blog id.
</t>
<t tx="leo.20210219082217.1"></t>
<t tx="leo.20210219082223.1"></t>
<t tx="leo.20210219082240.1"></t>
<t tx="leo.20210219082242.1"></t>
<t tx="leo.20210222144701.1">@language md
---
Title: 2021 工作流程
Date: 2021-02-22 11:00
Category: Weblog
Tags: 202102
Slug: 2021-kmolab-prefered-working-flow
Author: yen
---

請注意: &lt;http://fossil.kmol.info&gt; 僅支援 IPv6 網路協定.

2021 年起的工作流程已經逐步確立, 其中為了因應 G Suite for Education 改名為 Google Workspace for Education 後, 免費的 GDrive 已經不再提供 unlimited 使用, 因此 @gm 上的儲存空間將只提供當學期所使用的下載服務.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210222151517.1">其實在網際網路上, 本來就沒有免費使用的服務, 差別只在於連線上網過程所使用的各種資源, 到底是誰在付出代價?

2018 年起 [KMOLab] 所開設的課程已經全面使用 [CMSiMDE] 建立動態與靜態網站, 其中的動態網站主要用於近端或網際的網站內容編輯, 而靜態網站則使用  [Github], [Gitlab], [Heroku] 與 [Fossil SCM] 進行同步伺服, 意即每一個與 [KMOLab] 有關的課程內容資料, 遠端可以有四個同步備份, 而近端則是工作目錄所在電腦, 則可以具有與遠端版本相同或相近的多個分散式備分內容.

雲端的同步資料中只有 [Heroku] 可以執行 Python, 但能夠免費使用的總容量限制在 500 MB 以內, 因此大多僅用於 Python 網際程式開發測試或跳板之用.

至於 [Github] 與 [Gitlab] 的競爭其實已經告一段落, 等塵埃落定, 勝出的一方將會與 Google 蹲點 10 年的 GDrive 商品一樣 (2012-2022), 不再提供用來打擊對手的優渥免費教育使用方案.

這樣的認知其實在受到 [Openshift] 中途拆免費使用者的台之後, 相比之下, GDrive 仍然維持每個帳號大約 15GB 的免費儲存量, 好像已經厚道, 但, 真正的原因可能是: 普羅大眾的網際儲存大數據, 仍然具有價值.

期望 [Github] 不要改變使用方針
----

以目前的情況來看, [Github] 對於上課專用的小 project, 在  2026 年之前免費存放 50 MB (目前的 limit 為 100MB) 以下的檔案, 然後總倉儲容量不要超過 1 GB ([Github] 目前[最大容忍量]為 5GB), 應該沒有太大問題, 另外一個限制則是每個目錄下最多只能有 1000 個檔案.

[KMOLab] 建立倉儲可以將 &lt;https://github.com/mdecourse/cmstemplate&gt; 當作 template 直接建立靜態網站與動態網站, 其中的靜態網站以 Github Pages 建立, 而動態網站則需要 Python 3 加上 flask flask_cors lxml bs4 markdown pelican leo 等模組.

針對將 [Github] 中的倉儲同步至 [Gitlab], 也同時要啟用 Gitlab Pages, 則倉儲中額外需要 &lt;https://raw.githubusercontent.com/mdecourse/cad2020/master/.gitlab-ci.yml&gt; 進行設定. 而雙方倉儲的同步設定位於近端, 可以利用 git remote add 指令輕易達成, 一般是將推送到 [Gitlab] 的 git remote add 名稱設為 gitlab, 只要提交推送至 [Github] 後, 以 git push gitlab 就可以將同步資料的版本送到 [Gitlab].

至於將靜態網站資料送到 [Heroku] 的設定, 則是透過 &lt;https://github.com/mdecourse/cad2020/blob/master/index.php&gt; 將倉儲的靜態內容以 PHP 伺服進行跳址傳送.

同步至 [Fossil SCM] 倉儲
----

將 [Github] 倉儲同步至 [Fossil SCM] 倉儲的目的, 其實就是考量若上述三個免費雲端儲存服務都面臨停用後, 在只有自架主機的情況下, 可以只使用 [Fossil SCM] 管理版本資料, 或者自行安裝 &lt;https://gitlab.com/gitlab-org/gitlab&gt;, 仍然可以在近端主機或遠端主機環境下的 [Fossil SCM] 與 [Gitlab] 倉儲維持與先前相同的工作流程.f

在此為了避免 [Github] 與 [Fossil SCM] 倉儲雙向同步下, 可能造成 __FOSSIL__ 或 .fslckout 檔案的合併問題, 特別讓 [Fossil SCM] 倉儲保有 [Github] 倉儲的版本資料 (也就是 .git 目錄內容), 但 [Github] 倉儲則不儲存 __FOSSIL__ 或 .fslckout 檔案.

實際的作法是以 [Github] 倉儲中的改版為主, 在 [Fossil SCM] 倉儲端僅透過 git pull 取得最新的 [Github] 倉儲內容, 然後再勾選 [Fossil SCM] 倉儲端設定的 dotfiles 選項, [Fossil SCM] 倉儲就能納入 [Github] 倉儲的版本資料.

基本的操作流程如下:

github 利用 cmstemplate 建立 [CMSiMDE] 倉儲
github 端完成靜態 Github Pages 設定
fossil 端, 在對應的 wd 目錄, 以 git clone --recurse-submodules 取下 github 端的倉儲內容
fossil 端 wd 中設法利用 fossil open 開啟從 fossil init 所建立的 fossil 倉儲
將 fossil 空白的 __FOSSIL__ 或 .fslckout 檔案複製至 wd/倉儲名稱目錄下
利用 fossil add . 或 fossil addremove 將 git pull 從遠端取回的版本資料進行新增
再利用 fossil push 與 autosync 功能, 將改版資料送到 fossil 端.
最後則將 fossil 端的 default-csp 欄位設為 https://fonts.googleapis.com, 以便讓靜態網頁可以正常透過 doc/trunk/index.html 取得.



[最大容忍量]: https://docs.github.com/en/github/managing-large-files/what-is-my-disk-quota
[Fossil SCM]: https://www.fossil-scm.org
[Github]: https://github.com/
[Gitlab]: https://gitlab.com/
[Heroku]: https://www.heroku.com/
[Blogger]: https://www.blogger.com/
[KMOLab]: http://mde.tw
[Leo Editor]: https://leoeditor.com/
[CMSiMDE]: https://github.com/mdecourse/cmsimde
[Pelican Blog]: https://blog.getpelican.com/
[KMOLab]: http://mde.tw
[Openshift]: https://en.wikipedia.org/wiki/OpenShift

</t>
<t tx="leo.20210222162539.1"></t>
<t tx="leo.20210222162542.1"></t>
<t tx="leo.20210222162602.1"></t>
<t tx="leo.20210222162607.1"></t>
<t tx="leo.20210224100246.1">@language md
---
Title: 2021 nuklear
Date: 2021-02-24 11:00
Category: Weblog
Tags: 202102
Slug: 2021-kmolab-using-nuklear
Author: yen
---

[Nuklear] 是一套以 C 建立的 GUI 套件, 這裡希望透過 [Msys2] 導入. 所完成的程式可以在 Windows 10 與 Ubuntu 中執行.

[Nuklear]: https://github.com/Immediate-Mode-UI/Nuklear
[Msys2]: https://www.msys2.org/

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210224101026.1">安裝 nuklear
----

從 [Nuklear] 取得 nuklear.h 放入 Y:\msys64\mingw64\include 目錄便完成安裝.

Msys2 加裝 glew 與 glfw
----

啟動 Y:\msys64\mingw64.exe, 然後執行:

pacman -S mingw-w64-x86_64-glew

pacman -S mingw-w64-x86_64-glfw

直接進入 Y:\tmp\Nuklear\demo\glfw_opengl2, 以

gcc main.c -std=c99 -pedantic -O2 -o demo.exe -lglfw3 -lopengl32 -lm -lGLU32

建立 demo.exe 配合 Y:\msys64\mingw64\bin 目錄中的 glfw3.dll 就可以執行.

若是在 IPv6 協定機器中, pacman 安裝需要透過 proxy server, 可在  Y:\msys64\etc\wgetrc 中以

https_proxy = http://[2001:288:6004:XX::69]:3128/
http_proxy = http://[2001:288:6004:XX::69]:3128/
ftp_proxy = http://[2001:288:6004:XX::69]:3128/

進行設定.</t>
<t tx="leo.20210224102432.1"></t>
<t tx="leo.20210224102437.1"></t>
<t tx="leo.20210224102501.1"></t>
<t tx="leo.20210224102509.1"></t>
<t tx="leo.20210306102210.1">@language md
---
Title: 2021 cmsimde 修改
Date: 2021-03-06 11:00
Category: Weblog
Tags: 202103
Slug: 2021-kmolab-cmsimde-modification-add-three-bats
Author: yen
---

[cmsimde] 由 [KMOLab] 編寫, 是一套用於課程教學使用的網際內容管理系統, 從 2013 年底起配合各相關課程的內容與教學進度拼湊而成. 原始的內容分頁方式採自 [cmsimple], 也就是利用 content.htm 中的 H1~H3 標註分頁, 經過多年的修修改改, 其中納入 [Pelican] 與 [Reveal.js] 的應用. 

[cmsimde]: https://github.com/mdecourse/cmsimde
[KMOLab]: http://mde.tw
[cmsimple]: https://www.cmsimple.org/en/
[Pelican]: https://blog.getpelican.com/
[Reveal.js]: https://revealjs.com/


&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210306102233.1">由於使用過程牽涉動態網站與靜態網站的分散式版次管理, 使用者必須在命令提示字元中進出 cmsimde 目錄, 因此經常造成初學者弄亂倉儲中 [cmsimde] 子模組的版次, 而無法讓 [Github Pages] 中的靜態網頁正常轉檔. 這時可以採[刪除重建子模組] ([操作影片]) 或[重新 checkout cmsime 版本] 的方式進行修正. 有鑑於學員發生錯誤的次數實在太多, 因此促成本次的 [cmsimde] 用法修改.

[Github Pages]: https://pages.github.com/
[刪除重建子模組]: http://mde.tw/cad2020/content/W5Video.html
[操作影片]: https://drive.google.com/file/d/1TvkSOMRAUaGE4xL2b_5xOb4xbm8O_pi0/view
[重新 checkout cmsime 版本]: http://mde.tw/cp2020/content/cmsimde%20%E5%95%8F%E9%A1%8C.html

在倉儲目錄開啟動態網站
----

要修正上述使用者可能在 cmsimde 子模組目錄進行倉儲改版推送所造成的問題, 就是不需要讓使用者以命令列進出 cmsimde 目錄, 只要使用者是透過 [cmstemplate], 以 [Github] [template] 功能建立倉儲, 就無需處理 git submodule add 指令與 up_dir 目錄內容的複製. 或許就能避開上述可能造成的問題.

要讓使用者在倉儲目錄開啟 [cmsimde] 動態網站, 只需要新增一個 cms.bat, 內容為:

&lt;pre class="brush=js"&gt;
python cmsimde/wsgi.py
&lt;/pre&gt;

但由於是在倉儲目錄中執行此一 batch file, 所以用來建立 https 數位簽章用的 localhost.crt 與 localhost.key 檔案必須透過下列 portablegit/bin/sh.exe Shell 指令完成:

&lt;pre class="brush: javascript"&gt;
openssl req -x509 -nodes -days 365 -newkey rsa:4096 -keyout localhost.key -out localhost.crt
&lt;/pre&gt;

也就是 localhost.crt 與 localhost.key 必須從 cmsimde 子模組的根目錄移至 up_dir 目錄中, 並且也將 cms.bat 放入 up_dir 目錄.

另外又建立 up.bat 用於手動以 git submodule add 時, 必須將 up_dir 目錄內容複製至倉儲根目錄的流程:

&lt;pre class="brush: javascript"&gt;
@echo off
robocopy up_dir ./../ /E
&lt;/pre&gt;

最後針對採 openssh 對 [Github] 推送的需要 (無需輸入使用者的帳號與密碼), 建立一個 acp.bat (Add, Commit, Push):

&lt;pre class="brush: javascript"&gt;
echo off
set message=%1
git add .
git commit -m %message%
git push
&lt;/pre&gt;

執行時只需要將提交訊息字串放在 acp.bat 執行指令後面即可.

[cmstemplate]: https://github.com/mdecourse/cmstemplate
[Github]: https://github.com/
[template]: https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-template-repository</t>
<t tx="leo.20210306110551.1"></t>
<t tx="leo.20210306110554.1"></t>
<t tx="leo.20210306110610.1"></t>
<t tx="leo.20210306110613.1"></t>
<t tx="leo.20210306152423.1">@language md
---
Title: 2001年讀書心得
Date: 2021-03-06 12:00
Category: Weblog
Tags: 202103
Slug: 2021-kmolab-wth-is-this
Author: yen
---

現在還寫得出這種文章嗎?哈!! 當然不行, 絕對不可能!!

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20210306152445.1">2001 年在當時校長要求全校一級主管寫的大學教育政策白皮書讀後心得報告

科技大學的本質在教導學生獲得知識的能力，二十一世紀知識經濟最大的特色，在於必須將知識迅速化為商品，由於市場全球化的影響，未能即時將本身所擁有的知識，快速轉化為商品，並被市場接受的企業，終將難逃被時代淘汰的命運，企業如此，教育界也正面臨同樣的挑戰。

教育部將大學的競爭力，視為國家競爭力的重要指標，全國各大學面對社會多元化的需求與全民終身學習的發展趨勢，如何在「大學教育政策白皮書」的基本方針下，強化各校的競爭力，建立各校的重點特色，便成為各大學今後所賴以生存的重要關鍵。

事實上，「大學教育政策白皮書」中所提到的觀點，或許是台灣一般大學與科技大學所共同面臨的問題，但，就基本體制上，仍然要有所區分，方能貫徹彼此的教育目標，為社會的現在與未來，提供充足的人力資源。吾人以為，一般大學的最高目標在追求學術的卓越，而科技大學則必須掌握技術的領先，學術強調的是其具備未來的主導性，卓越的學術指的是高瞻遠矚，是未來有用的技術；而技術的領先是要培養能馬上為企業所用的科技尖兵，是能馬上將知識轉化為商品的創新發明家。也許，隨著科技進化的速度日益增快，學術與技術的區隔，也就變得越來越小，但一般大學與科技大學應有的角色與定位，仍不失為各大學爭取重點特色時，所應強調的重點。

最後，談到本校在通過改名為科技大學後，如何在「大學教育政策白皮書」的指導方針下，爭取市場定位，並積極發展出屬於自己的特色，吾人以為，必須要先從小處做起，慢慢往大處做；必須要先由內做起，然後再漸漸往外落實。小處在哪裡，必須先用科學化與合理化來管理學校的每一個角落，然後才能談替企業診斷，為財團解憂。必須要先在校內建立起知識經濟的體系，然後才有可能與社會上全民學習的脈動相結合。未來，全球化經濟發展的趨勢或許很難臆測，但本校單類多科的包袱，如何逐步轉化為本校的重點特色，將是一項嚴酷的考驗，成敗的關鍵，就看現在。</t>
<t tx="leo.20210306153256.1"></t>
<t tx="leo.20210306153302.1"></t>
<t tx="leo.20210306153326.1"></t>
<t tx="leo.20210306153329.1"></t>
<t tx="leo.20210314151746.1">@language md
---
Title: Fossil SCM 研究
Date: 2021-03-14 12:00
Category: Fossil_SCM
Tags: 202103
Slug: 2021-kmol-fossil-scm-study
Author: yen
---

[Fossil SCM] 是一套分散式版次管理系統, 專門為了管理 [SQLite] 而寫.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others
</t>
<t tx="leo.20210314151949.1">[Fossil SCM] 利用 C89 ANSI C 所寫, 其中使用 [Tcl] 作為 command language.

當然寫到這裡, 仍然很難體會 [Tcl] 究竟在 [Fossil SCM] 的開發中扮演什麼角色? 但是在 1990 年代 [Python] 啟動開發之際, 也仰賴 [Tcl], 可見這套所謂的 Tool Command Language 在 1980-1990 年代具有舉足輕重的地位.

從 &lt;https://en.wikipedia.org/wiki/Tcl&gt; 可以得知, Tcl is commonly used embedded into C applications, for rapid prototyping, scripted applications, GUIs, and testing.

Tcl 發展歷史
----

&lt;http://www.tcl.tk/about/history.html&gt;

編譯 Tcl
----

&lt;https://wiki.tcl-lang.org/page/Building+Tcl+and+Tk+for+Windows+with+MSYS2&gt;

&lt;https://github.com/waddella/Tclbuild&gt;

&lt;http://wookie.tcl.tk/14828&gt;


[Fossil SCM]: https://fossil-scm.org
[SQLite]: https://www.sqlite.org
[Tcl]: https://www.tcl-lang.org/
[Python]: https://www.python.org
</t>
<t tx="leo.20210317023310.1"></t>
<t tx="leo.20210317023351.1"></t>
<t tx="leo.20210317023355.1"></t>
<t tx="leo.20210317102957.1"></t>
<t tx="yen.20170108171605.1"></t>
<t tx="yen.20170108171605.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="yen.20170108171605.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="yen.20170108171733.1"></t>
<t tx="yen.20170108171733.2">@language python
import os

os.system("pelican markdown -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="yen.20170108171733.5"></t>
<t tx="yen.20170108171733.71"></t>
<t tx="yen.20170108171733.81"></t>
<t tx="yen.20170108171733.83">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt

</t>
<t tx="yen.20170108171930.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 5443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("5443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170108171939.1">@language python
import os
import subprocess
import threading
import socket
import http.server, ssl

class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6
  
def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '::1'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170224232341.1"></t>
<t tx="yen.20200512160924.1">@language md
---
Title: 打造 Windows 隨身程式系統
Date: 2020-05-12 11:00
Category: Windows
Tags: Portable_system
Slug: create-portable-win-prog-sys
Author: yen
---

在 Windows 操作系統上開發套件, 不僅希望這個套件能夠在 Mac OS X 與 Linux 上運行, 而且整個程式環境都能放入一個 USB 隨身碟, 在任何一台乾淨的 64 位元 Windows 10 操作系統中都能正常運行. 不受限制, 因此需要打造一個隨身程式系統.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others
</t>
<t tx="yen.20200516092143.1">@language md
---
Title: gitlab 與 github 整合運用
Date: 2020-05-16 11:00
Category: git
Tags: Github Pages
Slug: use-github-and-gitlab-pages
Author: yen
---

由於 [github] 遲遲不推出支援 IPv6 網站的連線功能, 目前若要在電腦輔助設計室直接透過純 IPv6 網路連線使用 git 分散式版次管理系統, 可以將 [Github Pages] 上的 [CMSiMDE] 網站, 同步一份倉儲資料到 [Gitlab Pages].

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others
</t>
<t tx="yen.20200516203207.1">@language md
---
Title: Virtualbox Ubuntu 虛擬主機網路設定
Date: 2020-05-16 12:00
Category: ubuntu
Tags: Virtualbox
Slug: virtualbox-ubuntu-nat-network
Author: yen
---

利用 [Virtualbox] 建立 Ubuntu 20.04 伺服器的虛擬主機, 可以讓使用者透過便捷的網路設定, 了解不同主機連線配置的特性外, 也能同時測試跨操作系統平台套件在 Windows 與 Ubuntu 環境執行的差異.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others
</t>
<t tx="yen.20200517131340.1">try to integrate pelican with blogger
    
需要安裝兩個程式庫
    
    pip install google-api-python-client oauth2client
    
OAuth 2.0 client IDs 程式類別選擇 other
    
使用者完成 client_secrets.json 設定後, 必須將檔案存在倉儲目錄外部


    
</t>
<t tx="yen.20200517131657.1">@language python
'''
可攜程式系統執行前, 必須額外安裝:

pip install google-api-python-client

pip install oauth2client
'''
__author__ = 'mdecourse At gmail.com'

import sys
from oauth2client import client
from googleapiclient import sample_tools

argv = ""
# 認證並建立服務
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')

try:
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # blog id is now blogs["items"][0]["id"]
    for blog in blogs['items']:
        print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 blog id
    '''
    body = {
    "kind": "blogger#post",
    "id": blogs["items"][0]["id"],
    "title": "透過 Python 程式新增網誌文章",
    "content":"使用 Google Blogger API 可以利用程式新增網誌文章內容",
    "labels": "test"
    }
    insert = posts.insert(blogId=blogs["items"][0]["id"], body=body)
    posts_doc = insert.execute()
    print(posts_doc)
    '''
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": "透過 Python 程式修改網誌文章",
    "content":'''使用 Google Blogger API 可以利用程式修改網誌文章內容. http://mde.tw/cd2019
    '''
    }
    # need to save postId to outline head
    update = posts.update(blogId=blogs["items"][0]["id"], postId="1234567", body=body, publish=True)
    update_doc = update.execute()
    print(update_doc)
except(client.AccessTokenRefreshError):
    print("error")</t>
<t tx="yen.20200517132439.1"></t>
<t tx="yen.20200517142620.1">當利用 syntaxhighlighter 引用 html 標註時, 必須先使用 CMSiMDE 編輯器將資料轉為 html_entities 格式後, 再導入 pre 標註, 以免產生額外的對應關閉標註符號.</t>
<t tx="yen.20200517194513.1">https://github.com/googleapis/google-api-python-client/blob/master/googleapiclient/sample_tools.py

def init(
    argv, name, version, doc, filename, scope=None, parents=[], discovery_filename=None
):
  Args:
    argv: list of string, the command-line parameters of the application.
    name: string, name of the API.
    version: string, version of the API.
    doc: string, description of the application. Usually set to __doc__.
    file: string, filename of the application. Usually set to __file__.
    parents: list of argparse.ArgumentParser, additional command-line flags.
    scope: string, The OAuth scope used.
    discovery_filename: string, name of local discovery file (JSON). Use when discovery doc not available via URL.</t>
<t tx="yen.20200517195613.1">http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html

other ref
    http://www.easonhsu.idv.tw/2017/01/use-blogger-python-api-to-publish-from.html</t>
<t tx="yen.20200517200253.1"># new-to-wp button
#coding: utf-8
import xmlrpc.client
import datetime
import os
 
def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!---more---&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
 
os.environ['TZ'] = 'Asia/Taipei'
 
#################################
filepath = "/your/wordpress/username/and/passwrod.txt"
wordpress = "your.wordpress.site.domain"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()
 
# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)
 
# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}
 
post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 
 
g.es("post_id 為", post_id)
g.es("已經送出資料!")</t>
<t tx="yen.20200517200409.1"># edit-to-wp
#coding: utf-8
import xmlrpc.client
import datetime
import os
 
def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!---more---&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
 
os.environ['TZ'] = 'Asia/Taipei'
 
#################################
filepath = "/your/wordpress/username/and/passwrod.txt"
wordpress = "your.wordpress.site.domain"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()
 
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)
 
# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}
 
# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)
 
if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")</t>
<t tx="yen.20200517200437.1"># get-from-wp
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html
 
#################################
filepath = "/your/wordpress/username/and/passwrod.txt"
wordpress = "your.wordpress.site.domain"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()
 
# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
 
server = xmlrpc.client.ServerProxy(wp_url)
 
# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資
 
# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&lt;!--more--&gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&lt;!--more--&gt;', '\n&lt;!-- PELICAN_END_SUMMARY --&gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")</t>
<t tx="yen.20200517233108.1">from markdown import markdown

print(markdown("# Hello World"))
# &lt;h1&gt;Hello World&lt;/h1&gt;</t>
<t tx="yen.20200517233837.1">這裡可以針對不同的網誌 credential 將同一份資料推向不同的 Blogger 網誌</t>
<t tx="yen.20200518055330.1">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 KBlogger!")
except(client.AccessTokenRefreshError):
    g.es("error")

</t>
<t tx="yen.20200518070950.1">@language md
---
Title: CMSiMDE 部署
Date: 2020-05-09 11:00
Category: Github
Tags: Deployment
Slug: 2020-lab-get-started
Author: yen
---

[CMSiMDE] 所能伺服的內容包含網站, 網誌與簡報, 而網站又分為動態系統與靜態系統, 動態網站建置主要的目的在方便進行 html 文件的編輯, 而靜態網站系統則主要為了能在一般的 WWW 伺服器上進行部署. 

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others
</t>
<t tx="yen.20200518071032.1">@language md
---
Title: 倉儲資料維護與管理
Date: 2020-05-11 11:00
Category: Github
Tags: CMSiMDE
Slug: manage-your-cmsimde-site
Author: yen
---

[cd2020] 是 2020 春季協同產品設計實習的課程網站, 而 [cd2020pj1] 則是與協同設計課程相關的程式專案, 兩者都採用 [CMSiMDE] 建立網站. 其中 [cd2020] 是典型的動態與網站架構, 而 [cd2020pj1] 則除了網站還包含 Flask 協同產品設計程式的開發.

[cd2020]: http://mde.tw/cd2020
[cd2020pj1]: http://mde.tw/cd2020pj1
[CMSiMDE]: https://github.com/mdecourse/cmsimde

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others

</t>
<t tx="yen.20200518101418.1">網站
----

[CMSiMDE] 的網站編輯採用 Flask 框架編寫, 目前所需要的模組包含 flask, flask_cors, lxml, bs4 與 markdown. 使用者可以選擇將 [CMSiMDE] 當作 submodule 或者單獨部署在倉儲內容中的 cmsimde 目錄後, 再將 cmsimde 目錄中的 up_dir 目錄內容複製到倉儲主目錄即可.

[CMSiMDE] 倉儲資料包含引擎內容 (也就是 cmsimde 中的資料) 與使用者內容 (也就是 up_dir 中的資料) 等兩類, 許多的網際功能都是配合歷年上課時敲敲打打修改而成, 因此整體架構相當鬆散, 就所謂的網際內容管理功能而言, 只能算勉強堪用, 還有很大的修改空間.

[CMSiMDE]: https://github.com/mdecourse/cmsimde

網誌
----

[CMSiMDE] 的網誌系統採用 [Pelican], 編輯網誌的架構採用 [Leo Editor] 管理, 而網誌專案檔位於 config 目錄中的 pelican.leo.

[Leo Editor] 其實是一套值得大力推廣的整合開發系統與文件編輯器, 但可能因為曲高因此和寡, 真正能夠運用上手的全球用戶, 數量始終偏低. 但是其大綱編輯模式非常適合處理複雜的工程設計流程所產生的各種文字資料, 因此非常希望 Python 新手能夠以看懂 [Leo Editor] 的設計架構與處理問題的細節作為遠大的目標.

[Pelican]: https://github.com/getpelican/pelican
[Leo Editor]: https://github.com/leo-editor/leo-editor

簡報
----

[CMSiMDE] 的網誌簡報採用 [reveal.js]. 而簡報的編輯檔案也是採用 [Leo Editor], 簡報專案位於 config 目錄中的 reveal.leo.

[reveal.js]: https://github.com/hakimel/reveal.js/

網站建構流程
----

[CMSiMDE] 的網站建構流程, 可以從建立初始的 [Github] 倉儲開始. 亦即在 [Github] 建立一個僅含 README.md 檔案的倉儲, 然後 git clone 該倉儲到近端後, 以命令列進入該倉儲後再以 

&lt;pre class="brush: jscript"&gt;
git submodule add https://github.com/mdecourse/cmsimde.git cmsimde
&lt;/pre&gt;

將 [CMSiMDE] 倉儲內容納為子模組, 且命名為 cmsimde 目錄. 接下來將 cmsimde 目錄中, 名稱為 up_dir 的目錄內容, 複製到倉儲的根目錄中. 若近端隨身系統或操作系統已經安裝 Python3 與相應的 flask, flask_cors, lxml, bs4, markdown 等模組後, 就可以在命令列中, 進入 cmsimde 子目錄, 以:

&lt;pre class="brush: jscript"&gt;
python wsgi.py
&lt;/pre&gt;

 假如是在 OS X 或 Linux 操作系統, 則必須使用 Python 3 指令:
 
 &lt;pre class="brush: jscript"&gt;
python3 wsgi.py
&lt;/pre&gt;

在近端啟動動態網站, 以瀏覽器 https://localhost:9443 開啟.

[Github]: https://github.com

網站內容管理
----

[CMSiMDE] 的動態網際內容管理, 將所有網頁內容存入 config 目錄中的 content.htm 檔案, 而在每一次使用者儲存新檔案之前,  會將舊版的 content.htm 複製至 content_backup.htm, 之所以如此是因為 [CMSiMDE] 採用 [bs4], 對 config/content.htm 內容進行分頁, 而分頁是依據 content.htm 由上到下的 h1, h2 與 h3 標註內容而定. 並在將動態網站內容 content.htm 以動態編輯器中的 generate pages 功能 (使用 [lxml] 模組功能) 轉為 content 目錄中的各分頁內容時, 可能因分頁失敗而讓整個 content.htm 內容丟失 (這就是非常需要改進的地方之一), 所以才設計 content_backup.htm 的複製進行及時補救.

[bs4]: https://pypi.org/project/beautifulsoup4/
[lxml]: https://pypi.org/project/lxml/
[Github Pages]: https://pages.github.com/

另外, 在 [CMSiMDE] 將操作系統不允許作為檔案名稱的特殊符號自動移除之前 (例如 ":" 號), 使用者應該避免在 h1, h2 與 h3 等標題中使用特殊符號.

Github Pages
----

將 [CMSiMDE] 的動態系統轉為靜態後, 所有靜態頁面的內容存入 content 目錄, 使用者可以將此目錄內容部署到 [Github Pages] 上, 或其他能夠伺服 WWW html 檔案的系統即可完成網站的建立.

但是一般為了方便, 通常將包含動態系統與靜態網站內容的整個倉儲資料, 直接交由 [Github] 管理.  只要將倉儲的 master 分支設為 [Github Pages] 的根目錄, 就可以交由 [Github Pages], 由倉儲主分支倉儲中的 index.html 進行網站導引.

假如使用者將近端的動態網頁內容轉為靜態後, 希望在近端檢視靜態網站內容, 可以在近端倉儲根目錄利用:

&lt;pre class="brush: jscript"&gt;
python http-server.py
&lt;/pre&gt;

或在 OS X 及 Linux 操作系統中以:

&lt;pre class="brush: jscript"&gt;
python3 http-server.py
&lt;/pre&gt;

啟動 https://localhost:8444 近端的靜態網頁伺服系統.

Ubuntu 20.04 自架主機
----

上述利用 [Github Pages] 伺服 [CMSiMDE] 靜態網頁內容的配置流程非常簡單, 但若是要將 [CMSiMDE] 靜態網頁與動態網站系統部署在自架的 Ubuntu 20.04 主機, 則操作系統除了要安裝前述的 python3, flask, flask_cors, bs4, lxml, markdown 之外, 還需要運用 [nginx], [uwsgi], [openssl] 進行配置.

[nginx]: https://nginx.org/en/
[uwsgi]: https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html
[openssl]: https://www.openssl.org/

其中, [openssl] 用來建立網站認證用的 key 與 certificate, [nginx] 負責建立 WWW 伺服, 而 [uwsgi] 則負責用來開機執行 [CMSiMDE] 中的 wsgi.py 伺服程式.

利用 [openssl] 建立 cmsimde.key 與 cmsimde.crt 的指令如下:

&lt;pre class="brush: jscript"&gt;
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout cmsimde.key -out cmsimde.crt
&lt;/pre&gt;

與 [uwsgi] 有關的 Ubuntu 系統安裝則包括:

&lt;pre class="brush: jscript"&gt;
// 安裝 pip3
sudo apt install python3-pip
// 安裝 python 編譯開發系統
sudo apt install build-essential python3-dev
// 安裝 uwsgi 模組
sudo pip3 install uwsgi
// 安裝 nginx 伺服套件與 uwsgi python3 plugin 程式庫
sudo apt install nginx uwsgi-plugin-python3
&lt;/pre&gt;

/etc/nginx/sites-available/default

&lt;pre class="brush: jscript"&gt;
# for lab.mde.tw static site, use nginx to serve
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	root /home/user_account/labmdetw;
	index index.html index.htm;
	server_name _;
	
	location /static {
            alias /home/user_account/labmdetw/cmsimde/static/;
        }
        location /downloads {
            alias /home/user_account/labmdetw/downloads/;
        }

        location /images {
            alias /home/user_account/labmdetw/images/;
        }

        location /blog {
            alias /home/user_account/labmdetw/blog/;
        }

        location /reveal {
            alias /home/user_account/labmdetw/reveal/;
        }

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

}

# https://lab.mde.tw use nginx to serve
server {
    listen 443 ssl;
    listen [::]:443 ssl;
	root /home/user_account/labmdetw;
	index index.html index.htm;
	server_name _;
	
	location /static {
            alias /home/user_account/labmdetw/cmsimde/static/;
        }
        location /downloads {
            alias /home/user_account/labmdetw/downloads/;
        }

        location /images {
            alias /home/user_account/labmdetw/images/;
        }

        location /blog {
            alias /home/user_account/labmdetw/blog/;
        }

        location /reveal {
            alias /home/user_account/labmdetw/reveal/;
        }
 
    location / {
	# First attempt to serve request as file, then
	# as directory, then fall back to displaying a 404.
	try_files $uri $uri/ =404;
    }

    ssl_certificate /etc/nginx/nginx.crt;
    ssl_certificate_key /etc/nginx/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}

# dynamic https://lab.mde.tw:7443 use nginx for ssl and uwsgi for wsgi serving
server {
 
    listen 7443 ssl;
    listen [::]:7443 ssl;
 
    location /static {
        alias /home/user_account/labmdetw/cmsimde/static/;
    }
 
    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:9443;
    }
 
    ssl_certificate /etc/nginx/nginx.crt;
    ssl_certificate_key /etc/nginx/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}
&lt;/pre&gt;

 uwsgi_ini/uwsgi.ini
 
&lt;pre class="brush:js;auto-links:false"&gt;
[uwsgi]
socket = 127.0.0.1:9443
uid = user_account
gid = user_account
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
master = true
process = 4
threads = 2
chdir = /home/user_account/labmdetw/cmsimde
wsgi-file = /home/user_account/labmdetw/cmsimde/wsgi.py
&lt;/pre&gt;

啟動 uwsgi 指令, 將會逐一啟動 wsgi_ini 目錄中個別 .ini 檔案:

&lt;pre class="brush: jscript"&gt;
sudo /usr/bin/uwsgi --emperor /home/user_account/wsgi_ini
&lt;/pre&gt;

最後則設定 Ubuntu 系統服務, 用來啟動 uwsgi:

/etc/systemd/system 的 cmsimde.service 服務啟動檔案內容:

&lt;pre class="brush: jscript"&gt;
[Unit]
Description=uWSGI to serve CMSiMDE
After=network.target
  
[Service]
User=user_account
Group=user_account
WorkingDirectory=/home/user_account/uwsgi_ini
ExecStart=/usr/local/bin/uwsgi --emperor /home/user_account/uwsgi_ini
  
[Install]
WantedBy=multi-user.target
&lt;/pre&gt;

接著將 cmsimde 服務設為隨系統開機啟動:

sudo systemctl enable cmsimde

若要取消 cmsimde 服務隨系統開機啟動:

sudo systemctl disable cmsimde

手動啟動 cmsimde.service 服務

sudo systemctl start cmsimde

手動停止 cmsimde.service 服務

sudo systemctl stop cmsimde</t>
<t tx="yen.20200518105911.1">當要從遠端 git clone [cd2020] 倉儲時, 牽涉到系統使用何種協定連線, https 或 ssh?

因為不同的連線協定有不同的設定檔案, 而且預計連線的主機並不一定就能提供服務, 因此能否順利完成 git clone 牽涉許多細節. 而這些細節並非一成不變, 而必須按照邏輯順序, 一一查驗才能得到期望中的結果.

首先, 因為 [cd2020] 網站的倉儲位於 https://github.com/mdecourse/cd2020.git, 其中帶有 cmsimde 子模組, 因此若要將此倉儲從遠端 git clone 到近端作為工作目錄, 最好的方式就是透過 --recurse-submodules 參數, 將子模組一起 clone 到近端.

&lt;pre class="brush: jscript"&gt;
git clone --recurse-submodules https://github.com/mdecourse/cd2020.git
&lt;/pre&gt;

由於 KMOLab 的課程鼓勵學員在 Windows 10 操作系統中, 使用隨身程式系統, 而不要被微軟綁定, 因為使用者必須了解所開發的程式必須能在 Mac OS X 與許多 Linux 操作系統執行, Windows 10 不應該是工程師唯一的操作系統.

因此, 從隨身系統中的 start.bat 啟動後, Windows 10 就只是機械設計工程師的暫時宿主, 隨時都要準備離開, 所以啟動後必須注意所處的網路連線環境, 假如是在 IPv4 網路環境, 可以直接對 github.com 連線, 但是身處純 IPv6 網路環境中, 目前仍必須透過支援 IPv4 與 IPv6 的網路代理主機, 才能利用 git 或 ssh 對 github.com 連線.

以 https 對 github.com 連線, 代理主機的設定是透過:

&lt;pre class="brush: jscript"&gt;
git config --global http.proxy=http://[2001::_your_ipv6_proxy]:3128
&lt;/pre&gt;

假如採 ssh 對 github.com 連線, 則代理主機的設定必須檢查 putty.exe 中 github.com session 中 Connections - Proxy 的代理主機設定.

一旦完成 [cd2020] 網站倉儲的 git clone, 使用者就可以使用隨身系統中的命令列視窗, 進入 [cd2020] 倉儲中的 cmsimde 目錄, 以:

&lt;pre class="brush: jscript"&gt;
python wsgi.py
&lt;/pre&gt;

開啟動態網站系統, 並利用瀏覽器連線到 https://localhost:9443 進行動態網站內容的維護, 完成後再利用 generate pages 按鈕將動態網站中的 config/content.htm 轉為 content 目錄中的靜態網頁, 之後再新增, 提交, 推送到遠端, 以完成倉儲改版的流程.</t>
<t tx="yen.20200518105955.1">啟動批次檔案
----

從以下這個 start.bat 批次啟動檔案, 大致可以看出此一可攜程式系統所包含的內容:

&lt;pre class="brush: jscript"&gt;
@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_no_proxy
set HomeDrive=%Disk%:\home_no_proxy
set Home=%Disk%:\home_no_proxy
set USERPROFILE=%Disk%:\home_no_proxy

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\Python38\DLLs;%Disk%:\Python38\Lib;%Disk%:\Python38\Lib\site-packages;
set PYTHONHOME=%Disk%:\Python38

REM for Java and Android SDK
set java_home=%Disk%:\java\jdk8u222-b10
set ANDROID_SDK_home=%Disk%:\home_no_proxy
set GRADLE_USER_home=%Disk%:\home_no_proxy
set ANDROID_SDK_ROOT=%Disk%:\android\sdk
set ANDROID_Home=%Disk%:\android\sdk
set REPO_OS_OVERRIDE=windows

REM 設定跟 Python 有關的命令搜尋路徑
set path_python=%Disk%:\Python38;%Disk%:\Python38\Scripts;
REM 設定跟Git 有關的命令搜尋路徑
set path_git=%Disk%:\portablegit\bin;
REM 設定 msys2 64 位元的執行路徑
set path_msys2=%Disk%:\msys64\mingw64\bin;
REM set for LaTeX
set path_miketex=%Disk%:\miktex-portable\texmfs\install\miktex\bin\x64;
REM Flutter path
set path_flutter=%Disk%:\flutter\bin;%java_home%\bin;%Disk%:\Android\sdk;%Disk%:\Android\sdk\tools;%Disk%:\Android\sdk\tools\bin;%Disk%:\Android\sdk\emulator;%Disk%:\Android\sdk\platform-tools;%Disk%:\flutter\bin\cache\dart-sdk\bin;%Disk%:\vscode;

path=%Disk%:;%path_python%;%path_git%;%path_msys2%;%path_miketex%;%path_flutter%;%path%;

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe

start /MIN %Disk%:\wScite\SciTE.exe
start /MIN %Disk%:\wScite\SciTE.exe

Exit
&lt;/pre&gt;

關閉隨身系統的批次檔案 stop.bat, 只將 python, scite 與 dos 命令列關閉, 若需要關閉其他可能開啟的套件, 可以自行加入:

&lt;pre class="brush: jscript"&gt;
@echo off
set Disk=y
path=%PATH%;

taskkill /IM python.exe /F
taskkill /IM pythonw.exe /F

taskkill /IM scite.exe /F

REM 終止虛擬硬碟與目錄的對應
subst %Disk%: /D
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F

EXIT
&lt;/pre&gt;

此一隨身系統安裝配置以 [MSYS2] 與 [Flutter] 較具挑戰性.

[MSYS2]: https://www.msys2.org/
[Flutter]: https://flutter.dev/

[MSYS2]
----

首先與 [MSYS2] 的代理主機設定位於 Y:\msys64\etc\wgetrc. 接下來為了可以編譯 C++ 程式, 必須安裝

&lt;pre class="brush: jscript"&gt;
pacman -S mingw-w64-x86_64-gcc
&lt;/pre&gt;

與

&lt;pre class="brush: jscript"&gt;
pacman -S mingw-w64-x86_64-toolchain
&lt;/pre&gt;

而列出 [MSYS2] 中所安裝的模組:

&lt;pre class="brush: jscript"&gt;
pacman -Q
&lt;/pre&gt;

為了編譯 [Range3], 必須額外安裝:

&lt;pre class="brush: jscript"&gt;
pacman -S mingw-w64-x86_64-ffmpeg

pacman -S mingw-w64-x86_64-qt5

pacman -S mingw-w64-x86_64-qt5-static
&lt;/pre&gt;

編譯 Range3
----

git clone https://github.com/Range-Software/range3.git

start Y:\msys64\mingw64.exe

cd \y\tmp\fem_ex\range3

./scripts/build.sh --clean &amp;&amp; ./scripts/create_package.sh

而為了讓 svg 格式的 icons 能夠正確顯示, 必須納入 Qt5Svg.dll

Flutter
----

至於現階段 [Flutter] 的安裝配置問題源自 [Android] sdk 的最新版 tools 與最新版的 [Flutter] 並不相容. 具體原因是: 目前的 [Flutter] 必須使用舊版的 [Android] sdk 中的舊版 tools.

[Android]: https://developer.android.com/studio

使用者若從 [Android] 官方網站下載 tools 工具, 試圖與 [Flutter] 配合, 將會在執行:

&lt;pre class="brush: jscript"&gt;
flutter doctor
&lt;/pre&gt; 

時將出現 Android sdk licenses 尚未完成.  但是若再以:

&lt;pre class="brush: jscript"&gt;
flutter doctor --android-licenses
&lt;/pre&gt; 

就會出現 Java setting 錯誤.

解決方案
----

處理上述 [Flutter] 與最新版 [Android] 無法相容的問題, 必須借助:

&lt;pre class="brush: jscript"&gt;
sdkmanager --sdk_root=y:\android\sdk tools
&lt;/pre&gt;

安裝舊版的 [Android] sdk tools, 問題是 sdkmanager 工具就位於 tools 目錄中, 因此必須先將新版的 tools 目錄改名為 tools_new, 並配合將 tools_new/bin 設為 start.bat 中的 PATH, 可攜系統啟動後, 以:

&lt;pre class="brush: jscript"&gt;
sdkmanager --sdk_root=y:\android\sdk tools
&lt;/pre&gt;

安裝舊版的 [Android] sdk tools 後, 再將 PATH 路徑改為舊版 tools/bin.

之後再以

&lt;pre class="brush: jscript"&gt;
flutter doctor --android-licenses
&lt;/pre&gt; 

同意使用授權後, 就可以接續進行 Flutter 套件的開發.</t>
<t tx="yen.20200518110043.1">機械設計工程師的網站
----

身為使用分散式版次管理系統的機械設計工程師團隊, 除了自行建立的 Linux 伺服器主機之外, [Github Pages] 是目前用來建立靜態網頁的最佳平台. 但是截至目前只支援 IPv4 網路協定連線的 [github], 在上課時僅支援 IPv6 上線的情況下, 造成了許多不便. 因為所有的資料封包都必須透過雙支援的代理主機傳訊.

[github]: https://github.com
[gitlab]: https://gitlab.com
[Github Pages]: https://pages.github.com/
[Gitlab Pages]: https://docs.gitlab.com/ee/user/project/pages/
[CMSiMDE]: https://github.com/mdecourse/cmsimde.git

為了讓使用者可以在純 IPv6 環境下, 將 [CMSiMDE] 的靜態網頁部署在廣域雲端平台上, 準備將倉儲資料同步一份到 [Gitlab Pages].

開放作風的 gitlab
----

[github] 雖然比 [gitlab] 早創立幾年, 但是 [gitlab] 的開源與大器作風, 讓帳面價值達到 76 億美元的 [github] 失色許多.

[Github Pages] 將用戶設定的靜態網頁資料分支, 以直覺但隱藏流程的方式進行, 導致許多情況下, 用戶無法就網頁資料轉檔流程進行除錯.

gitlab-ci.yml
----

而 [Gitlab Pages] 則選擇讓使用自行透過 gitlab-ci.yml 的 YAML 檔案, 自行控制網頁的轉檔流程.

以 [CMSiMDE] 網際內容管理中的靜態網頁而言, 只要在倉儲資料根目錄中, 加入一個 gitlab-ci.yml 檔案, 內容如下:

&lt;pre class="brush: jscript"&gt;
pages:
  stage: deploy
  script:
  - mkdir .public
  - cp -r * .public
  - mv .public public
  artifacts:
    paths:
    - public
  only:
  - master
variables:
  GIT_SUBMODULE_STRATEGY: recursive
&lt;/pre&gt;

就可以順利將倉儲資料中的主分支靜態網頁, 部署在 https://帳號.gitlab.io/倉儲名稱 網址中. 其中最重要的設定參數:

&lt;pre class="brush: jscript"&gt;
GIT_SUBMODULE_STRATEGY: recursive
&lt;/pre&gt;

就是表明要求 [gitlab] 在將倉儲轉為網頁的過程, 同時以 recursive 的方式將其中的 submodule 目錄, 也納入網頁的內容.

git remote add
----

針對目前已經部署在 [github] 的靜態網頁倉儲, 使用者先在主分支的根目錄中, 新增提交推送一個上述的 gitlab-ci.yml 設定檔案, 然後建立與 [github] 帳號對應的 [gitlab] 帳號之後, 新增一個與 [github] 倉儲的同名空專案, 也就是連 README.md 都不建立的 public 空倉儲, 然後在近端倉儲主分支工作目錄中, 以:

&lt;pre class="brush: jscript"&gt;
git remote add gitlab https://gitlab.com/帳號/同名倉儲.git
&lt;/pre&gt;

新增一個網址代號 gitlab, 指到上述 [gitlab] 系統中的空同名倉儲網址.

接下來就可以透過:

&lt;pre class="brush: jscript"&gt;
git push gitlab
&lt;/pre&gt;

將 [github] 倉儲中的主分支資料, 同步一份到 [gitlab], 並且在 gitlab-ci.yml 的設定導引下, 自動產生相應的 [Gitlab Pages] 靜態網頁. 而其網址就是: https://帳號.gitlab.io/倉儲名稱

最後, 假如之後的倉儲改版以 [gitlab] 為主, 只要在近端主分支的工作目錄中, 以:

&lt;pre class="brush: jscript"&gt;
git remote add github https://github.com/帳號/同名倉儲.git
&lt;/pre&gt;

建立一個 github 代號倉儲連結, 就可以透過:

&lt;pre class="brush: jscript"&gt;
git push github
&lt;/pre&gt;

將 [github] 當作 [gitlab] 倉儲的備份網站.</t>
<t tx="yen.20200518110131.1">修課學員只要登入 ＠gm 帳號後, 就可下載 [Ubuntu 20.04 虛擬主機] (或下載 [Ubuntu 20.04 W12 虛擬主機]), 並匯入 Windows 10 環境所安裝的 [Virtualbox].

接下來就必須了解如何使用虛擬主機的 NAT Network 網路設定.

讓虛擬主機連上廣域網路
----

能直接讓 [Virtualbox] 虛擬主機連上網路的設定, 可以選擇 NAT, NAT Network 與 Bridged 等三種設定. 詳細的說明可以參考 [Virtualbox Network Setting], [Virtualbox 5.1.22 User Manual], [Virtualbox 6.1.8 User Manual] 中的說明.

假如需要利用 Python 程式透過 COM 操控 [Virtualbox] 中的虛擬主機, 則可以參考 [Virtualbox 5.1.22 Programming Guide] 與 [Virtualbox 6.1.8 Programming Guide] 中的說明.

在目前的網際內容管理與協同產品設計課程應用上, 以 NAT Network 的設置最合需求. 因為 Ubuntu 20.04 虛擬主機可以透過 Windows 10 Host 的 IPv4 或 IPv6 網路設定連外. 同時 Ｗindows 10 上的瀏覽器與 Python 程式可以透過內部網路對虛擬主機連線.

使用 NAT Network 讓虛擬主機上網的另外一個好處是: Host 上 [Virtualbox] 的網路設定可以動態生效, 亦即 Ubuntu 20.04 可以一直保持在開機狀態, 使用者在 Host 端更動 [Virtualbox] 的 NAT Network 設定後, 即刻可以在 Ubuntu 虛擬主機上進行配合調適, 無需如 Bridged 或 Host Only 虛擬主機的網路設定, 必須關機後才能修改所使用的網路設定.

NAT Network 上的 IPv4 與 IPv6 設定
----

由於在電腦輔助設計室使用純 IPv6 協定上網, 因此採用 NAT Network 設定的 [Virtualbox] 虛擬主機, 也必須能夠透過 IPv6 進行設定.

NAT Network 的 DHCP 能同時支援 IPv4 與 IPv6, 但是在 GUI 介面只列出 IPv4 的 DHCP 內定使用 10.0.2.0/24 IP 位址, IPv6 的部分則需要透過指令才可列出:

&lt;pre class="brush: jscript"&gt;
C:\Users\kmol2019&gt;"C:\Program Files\Oracle\VirtualBox\VBoxManage" list natnetworks
NetworkName:    NatNetwork
IP:             10.0.2.1
Network:        10.0.2.0/24
IPv6 Enabled:   Yes
IPv6 Prefix:    fd17:625c:f037:2::/64
DHCP Enabled:   Yes
Enabled:        Yes
loopback mappings (ipv4)
        127.0.0.1=2
&lt;/pre&gt;

換言之, 在 [Virtualbox] 採用 NAT Network 設定的虛擬主機, 其 IPv4 gateway 預設為 10.0.2.1, 而 IPv6 的 gateway 則為 fd17:625c:f037:2::1, 了解此一訊息之後, 使用者就可以利用 Ｗindows 10 中的批次檔案 setnatnetwork.bat 來設定後續的網路內容, 主要讓 [cd2020pj1] 啟動後的 8443 與 7443 埠號伺服器, 能夠從 Host 瀏覽器中連線:

[cd2020pj1]: https://github.com/mdecourse/cd2020pj1.git

&lt;pre class="brush: jscript"&gt;
"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "ssh:tcp:[127.0.0.1]:22:[10.0.2.4]:22"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "coppeliasim:tcp:[127.0.0.1]:19999:[10.0.2.4]:19999"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "cmsimde1:tcp:[127.0.0.1]:8443:[10.0.2.4]:8443"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "cmsimde2:tcp:[127.0.0.1]:7443:[10.0.2.4]:7443"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-6 "ssh:tcp:[::1]:22:[fd17:625c:f037:2:a00:27ff:fef6:9b8a]:22"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-6 "cmsimde1:tcp:[::1]:8443:[fd17:625c:f037:2:a00:27ff:fef6:9b8a]:8443"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-6 "cmsimde2:tcp:[::1]:7443:[fd17:625c:f037:2:a00:27ff:fef6:9b8a]:7443"
&lt;/pre&gt;

其中 Ubuntu 20.04 虛擬主機的 netplan 網路設定為:

&lt;pre class="brush: jscript"&gt;
network:
    ethernets:
        enp0s3:
            dhcp4: true 
            dhcp6: true 
            nameservers:
                addresses:
                     - 2001:b000:168::1
    version: 2
&lt;/pre&gt;

表示兩種網路協定都採用 DHCP, 但是 IPv6 必須設定 DNS 伺服器, 因為學校 DHCP6 所設定的 DNS 無法正確運作的緣故.

[Ubuntu 20.04 虛擬主機]: https://drive.google.com/open?id=1Ff-mPk9kww_04RxkkiS0lb_2Y9z8Ek1Z

[Ubuntu 20.04 W12 虛擬主機]: https://drive.google.com/open?id=13Gqwyj0CGR6wa9dZg_BmlCLv5cNYWQJ_

[Virtualbox]: https://www.virtualbox.org/

[Virtualbox Network Setting]: https://drive.google.com/open?id=1U8hVabo24eBrkuau5Ev0Za8XC9k_Bzux

[Virtualbox 5.1.22 User Manual]: https://drive.google.com/open?id=1xRxWmYOw4tQuRAFecsAEOlqu62xPUvMc

[Virtualbox 5.1.22 Programming Guide]: https://drive.google.com/open?id=1DsVpKWUoDHO-AWnuFxafQ-kYR53_kCT6

[Virtualbox 6.1.8 User Manual]: https://drive.google.com/open?id=1MX1XT1hlOWYVIZ8bKbtlrTAWBCgRRnSL

[Virtualbox 6.1.8 Programming Guide]: https://drive.google.com/open?id=1jTmj2oWSO8aCpF6DW1rIAYz3iqYQtjPp

[Virtualbox download]: https://download.virtualbox.org/virtualbox/
</t>
<t tx="yen.20200518110700.1">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 K Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
</t>
<t tx="yen.20200518115111.1"></t>
<t tx="yen.20200518115329.1"></t>
<t tx="yen.20200518115347.1"></t>
<t tx="yen.20200518115404.1"></t>
<t tx="yen.20200518115421.1"></t>
<t tx="yen.20200518115509.1">@language md
---
Title: 同步 Pelican 與 Blogger 網誌內容
Date: 2020-05-18 11:00
Category: Weblog
Tags: Pelican, Blogger
Slug: sync-pelican-and-blogger-content
Author: yen
---

在先前的 [CMSiMDE] 架構中, 曾經設法讓 [Pelican 與 Ｗordpress 的內容同步], 相同的概念, 也可以在 [Leo Editor] 中, 讓 Pelican 的網誌文章與 Google Blogger 保持同步.

&lt;!-- PELICAN_END_SUMMARY --&gt;

[CMSiMDE]: https://github.com/mdecourse/cmsimde.git
[Pelican 與 Ｗordpress 的內容同步]: http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html
[Leo Editor]: https://leoeditor.com/

@others
</t>
<t tx="yen.20200518120231.1">按鈕與節點標題
----

[Leo Editor] 中可以設置按鈕執行 Python 程式, 其中搭配節點的標題內容存取, 可以應用在 Pelican 與 Blogger 的網誌內容同步.

由於目前使用的 Pelican, 在 markdown 目錄中編寫 .md 檔案, 然後再設法以 Pelican 指令與設定檔, 將所有的 .md 檔案轉為 blog 目錄中的網誌內容. 其中, 若能將個別的 .md 檔案先轉為 html 後, 再利用 Google Blogger API 的 Python 程式將各網誌 html 檔案送至對應帳號下的 Blogger 網誌系統, 將可以將一份內容分別同步到 Pelican 與 Blogger.


新增 Blogger 文章
----

 add_to_blogger 按鈕程式:
 
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    # 但是只換第一個
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;', 1)
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    blog_id = blogs["items"][0]["id"]
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

編輯 Blogger 文章
----

edit_to_blogger 按鈕程式:

&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    blog_id = blogs["items"][0]["id"]
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

從 Blogger 取回內容
----

在 [Pelican 與 Ｗordpress 的內容同步] 中, 可以從 Wordpress 取回網誌內容, 然後新增到 Pelican, 在此因為網誌文章的建立以 [CMSiMDE] 倉儲中的 Pelican 網誌為主, Blogger 只是附屬備份網誌, 所以就不再從新增的 Google Blogger 取回網誌文章.

參考資料
----

&lt;a href="https://developers.google.com/blogger"&gt;https://developers.google.com/blogger&lt;/a&gt;
</t>
<t tx="yen.20200521095531.1"></t>
<t tx="yen.20200528095926.1">@language md
---
Title: 網際內容管理 Ｗ13
Date: 2020-05-28 11:00
Category: WCM
Tags: Pelican, Blogger, Ubuntu
Slug: wcm-w13-ubuntu-and-blogs
Author: yen
---

之所以在機械設計工程系開設網際內容管理課程, 起源於多年前的所謂製商整合科技教育改進計畫, 當時參與的科系有機械設計系, 自動化工程系, 工業管理系與資訊管理系, 同時開設的課程還有協同產品設計實習, 基因演算與產品生命週期管理.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="yen.20200529220132.1">網際內容管理課程目標
----

這項計畫與其他所謂的跨領域學程的命運沒有太大的差異, 計畫補助經費結束, 大家各自回巢, 留下一堆陳年資訊系統設備, 還有這門網際內容管理與協同產品設計實習.

網際內容管理課程開設在機械科系的主要任務, 是要鼓勵工程師善用全球資訊網的無遠弗屆, 與其他領域工程師執行協同設計, 自 2012 年起 [Onshape] 已經成功在曾經開發 [Solidworks] 的基礎上, 證明瀏覽器, 平板電腦與手機, 都可以是機械設計工程師開發產品的平台, 無需受限於單機安裝, 必須自行看顧版本更新, 徹底脫離沒有產品資料管理系統, 就無法協同進行產品開發的舊時代.

當然, [Onshape] 雖然定位為電腦輔助機械設計與分析管理平台, 但是真正能夠編寫 Web based 程式前後端, 並且與 [Parasolid] 核心程式庫進行圖形介面與觸控互動, 絕非出自通常只上過一門 [計算機程式] 課程的機械工程師, 而是來自一群號稱 Full stack web developers 的資訊科系研究工程師.

[計算機程式]: http://mde.tw/lab/content/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A8%8B%E5%BC%8F.html
[Onshape]: https://www.onshape.com/
[Solidworks]: https://www.solidworks.com/
[Parasolid]: https://en.wikipedia.org/wiki/Parasolid
[Featurescript]: https://cad.onshape.com/FsDoc/
[CMSiMDE]: https://github.com/mdecourse/cmsimde.git
[Pelican]: https://github.com/getpelican/pelican
[Blogger]: https://www.blogger.com/
[Leo Editor]: https://leoeditor.com/
[節點指令]: https://leoeditor.com/directives.html
[clean]: https://leoeditor.com/directives.html#clean-path
[Markdown]: https://en.wikipedia.org/wiki/Markdown
[button]: https://leoeditor.com/customizing.html?highlight=button
[html]: https://en.wikipedia.org/wiki/HTML
[google-api-python-client]: https://github.com/googleapis/google-api-python-client
[oauth2client]: https://github.com/googleapis/oauth2client

儘管如此, 對於必須在 [Onshape] 上利用 [Featurescript] 進行各種 2D 與 3D 零組件客製設計的機械工程師, 仍需具備一定程度的網際程式能力.

因此, 在四技部的網際內容管理課程, 定位為接續計算機程式課程, 預計培養未來在電腦輔助設計實習與協同產品設計實習等課程, 負責建置實體與虛擬主機, 搭建網際機械設計管理系統的協同人員, 而五專部的網際內容管理課程, 則定位在承接計算機概論課程, 讓高一程度的學員, 能夠了解網際軟硬體的基本架構外, 也能夠利用分散式版次管理建立網站, 管理網誌並利用基本的程式方法, 讓 Google [Blogger] 與 [CMSiMDE] 中的 [Pelican] 網誌內容同步.

[Leo Editor]
----

要讓兩套架構完全不同的網誌系統內容同步, 可以採取各種程式方法, 這裡是透過 [Leo Editor] 大綱編輯程式中的節點按鈕與節點編輯特性完成.

[Leo Editor] 允許使用者透過不同的 [節點指令], 進行特定文字檔案的編輯管理, 其中的 [clean] 節點指令, 最適合用來編輯 [Pelican] Blog 的 [Markdown] 文章內容, 因為 [clean] 允許將一篇文章以從屬架構的節點內容分割, 當使用者利用 [button] 中的 Python 程式段, 試圖將 [Pelican] 網誌的文章從 [Markdown] 格式,  轉為 [html] 檔案, 並且通過 Google [Blogger] API 的 credential 認證, 將網誌的 [html] 格式文章, 轉貼到對應的 [Blogger] 系統之後, 可以取得該網誌的 id, 並將此 id 儲存在該 [Pelican] [Markdown] 文章編輯大綱中, [clean] 節點下層的最末端, 之後的內容改版, 就可以依據此一 [Blogger] 文章 id, 循相同的授權模式, 將改版內容送至 Google [Blogger].

按鈕程式所需模組
----

為了利用 [button] 中的 Python 程式將文章發佈至 Google [Blogger], 可攜程式系統需要安裝 [google-api-python-client] 與 [oauth2client] 模組.

pip install google-api-python-client oauth2client

接下來則是取得與所要同步的 Google [Blogger] 認證檔案.</t>
<t tx="yen.20200529224039.1">@language python
# get secrets: https://console.developers.google.com
# https://developers.google.com/blogger/docs/3.0/using
# pip install google_auth_oauthlib
# under Mac command + b to execute
import pickle
import os
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request


SCOPES = ['https://www.googleapis.com/auth/blogger', ]

# we check if the file tBo store the credentials exists
if not os.path.exists('./../../yen_gm_blogger_token.dat'):

    flow = InstalledAppFlow.from_client_secrets_file('./../../yen_gm_blogger_secrets.json', SCOPES)
    credentials = flow.run_local_server()

    with open('yen_gm_blogger_token.dat', 'wb') as credentials_dat:
        pickle.dump(credentials, credentials_dat)
else:
    with open('yen_gm_blogger_token.dat', 'rb') as credentials_dat:
        credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
g.es(service)</t>
<t tx="yen.20200608161509.1">@language md
---
Title: 高風險聯網設備
Date: 2020-06-04 11:00
Category: Network
Tags: Security
Slug: high-risk-networking-devices
Author: yen
---

前幾天, 感謝校方送來一份通知, 列出系上共有 40 多台所謂的高風險聯網設備. 其中有 8 台 Linux 代理主機必須配合更新套件, 並且限定可連線管理的 IP 位址範圍.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others

</t>
<t tx="yen.20200608161548.1">
Ubuntu 伺服器
----

設計系目前共有三台實體虛擬主機與一台虛擬代理主機, 四台符號名稱伺服器,  以及兩台虛擬的 WWW 伺服器主機. 

其中系上的符號名稱伺服器原先安裝 Ubuntu 18.04, 必須升級為 20.04, 四台符號名稱伺服器與 WWW 伺服器則需要限制 ssh 的連線範圍.

針對非開發版本的 Ubuntu 18.04 可以參考 https://www.linuxtechi.com/upgrade-ubuntu-18-04-lts-to-ubuntu-20-04-lts/ 升級為 20.04.

舊版的 nginx, 若要升級為較新版本, 則可參考 https://devopscraft.com/how-to-compile-nginx-from-source-on-ubuntu-20-04/ 自行編譯安裝.

ufw 防火牆
----

以代理主機而言, 除了限制可連線 ssh 的 IP 範圍外, 還需要讓同區段的電腦可以對 3128 埠號連線;

&lt;pre class="brush: js"&gt;
    sudo -s 
    ufw status
    ufw allow from your_ipv4_or_ipv6_ip
    ufw allow from 2001:288::/16 to any port 22
    ufw deny 22
    ufw allow from 2001:288::/16 to any port 3128
    ufw deny 3128
    ufw enable
&lt;/pre&gt;

其次, 若要刪除原先 ufw 的設定可以使用 ufw reset, 若要暫時關閉 ufw, 採用 ufw disable.

符號名稱的部分, 需要限制 port 22 連線外, 必須讓所有主機都能對 port 53 連線:

&lt;pre class="brush: js"&gt;
    sudo -s 
    ufw status
    ufw allow from your_ipv4_or_ipv6_ip
    ufw allow from 2001:288::/16 to any port 22
    ufw deny 22
    ufw allow 53
    ufw enable
&lt;/pre&gt;

WWW 伺服器若採用 port 80 與 443 配置, 則需要對所有主機開放, port 5443 若執行 Fossil SCM, 也必須開放, 其他也是對 port 22 有連線範圍的限制.

&lt;pre class="brush: js"&gt;
    sudo -s 
    ufw status
    ufw allow from your_ipv4_or_ipv6_ip
    ufw allow from 2001:288::/16 to any port 22
    ufw deny 22
    ufw allow 80
    ufw allow 443
    ufw allow 5443
    ufw enable
&lt;/pre&gt;

最後, 則是附上[電腦輔助設計室電腦規劃] 與 [網路安全] 參考資料.

[電腦輔助設計室電腦規劃]: https://github.com/mdecourse/wcms2018/issues/7
[網路安全]: http://www.linuxfromscratch.org/blfs/view/svn/postlfs/security.html



</t>
<t tx="yen.20200608161847.1"></t>
<t tx="yen.20200608204806.1"></t>
<t tx="yen.20200608205522.1">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    #blog_id = blogs["items"][0]["id"]
    blog_id = "7949497010793271992"
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 MBlogger!")
except(client.AccessTokenRefreshError):
    g.es("error")

</t>
<t tx="yen.20200608205624.1">@language python
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    #blog_id = blogs["items"][0]["id"]
    blog_id = "7949497010793271992"
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 M Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
</t>
<t tx="yen.20200608205920.1"></t>
<t tx="yen.20200608210003.1"></t>
<t tx="yen.20200611213634.1">@language md
---
Title: 代理主機維護策略
Date: 2020-06-11 11:00
Category: Network
Tags: Proxy
Slug: stratege-for-proxy-servers
Author: yen
---

昨天又失去一台 HP 代理主機, 也就是編號 42 的 Squid Proxy Server. 因此目前只剩下 4, 53 與 69 等三台.

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="yen.20200611214052.1">雙協定支援代理主機的需求
----

也許大家會存疑, 機械設計科系為何需要自行安裝維護網路代理主機？假如根據學校多年前回覆, 之所以拆掉校級的代理主機設置, 原因是聯外頻寬已經很足夠, 因此不需要網路代理主機.

但是, 這種假設是, 系上的 IPv4 數量足夠, 而大部分的外部伺服器都已經支援 IPv6, 但是對於平日電腦總數量超過 300 台的機械設計系, 希望上課時讓每一位學員都能將課程資料存取於 Github.com, 這兩個條件都不存在.

因此, 從電腦輔助設計室上課的需求來看, 採用 IPv4 NAT 的模式, 並無足夠的頻寬讓 至少 50 台電腦快速直接對 Github.com 連線, 而如眾所知, Github.com 目前尚不支援 IPv6 網路協定.

因此, 2-3 台能夠同時支援 IPv4 與 IPv6 網路協定的代理主機, 似乎是可行的方案之一.

維護全時運作主機的可能方案
----

假如以電腦輔助設計室每週 40 堂課計算, 其中只有至多 14 堂課需要使用網路代理主機, 理論上並沒有必要全時讓這些代理主機運作, 而只要維持一台連內 (69), 一台連外 (4), 其餘的 IPv4 伺服器 IP 位址, 可以交由每班中至多 5 個分組的組長, 以虛擬主機 bridged 網路的方式各自管理分組中的代理主機, 其中可能的編號將有 (24, 32, 34, 39, 42）等五台.

其中, 因為在上學期的課程有大一的計算機程式與大二的電腦輔助設計實習課程, 而下學期的課程則有大一的網際內容管理與大二的協同產品設計實習, 正好可以在各課程中安排學長與學弟妹共同維護這五台代理主機的互動傳承內容.

Squid 代理主機的安裝
----

以 Ubuntu 20.04 伺服器主機為例, 安裝 Squid Proxy 伺服器:

sudo apt install squid

接下來, 利用 /etc/squid/squid.conf 進行配置:

&lt;pre class="brush: jscript"&gt;
# 定義可以連線電腦網路位置範圍或特定 IP
acl cad_lab src 192.130.17.0/24
acl cad_lab src 192.127.237.33
acl cad_lab src 2001:288::/64

# 定義可以連線通過的埠號
acl SSL_ports port 443
acl Safe_ports port 80 # http
acl Safe_ports port 88
acl Safe_ports port 89
 
#acl Safe_ports port 21 # ftp
acl SSL_ports port 8843
acl SSL_ports port 5443
acl SSL_ports port 8443
acl Safe_ports port 8443
 
acl SSL_ports port 9443
acl Safe_ports port 9443
 
acl SSL_ports port 22
acl Safe_ports port 22
 
acl Safe_ports port 443 # https
acl Safe_ports port 1025-65535 # unregistered ports
acl Safe_ports port 280 # http-mgmt
acl Safe_ports port 488 # gss-http
acl Safe_ports port 591 # filemaker
acl Safe_ports port 777 # multiling http
acl CONNECT method CONNECT

# 除了前面定義的安全埠號外, 一律拒絕連線
# Deny requests to certain unsafe ports
http_access deny !Safe_ports

# 除了前面定義的安全埠號外, 一律不准連線
# Deny CONNECT to other than secure SSL ports
http_access deny CONNECT !SSL_ports
 
# 只允許前面定義的網路 IP 電腦連線, 其餘一律禁止
http_access allow cad_lab
http_access deny all
# Only allow cachemgr access from localhost
http_access allow localhost manager
http_access deny manager
 
#http_access allow localnet
http_access allow localhost
 
# And finally deny all other access to this proxy
http_access deny all
 
# Squid normally listens to port 3128
http_port 3128
 
#cache_dir ufs /var/spool/squid 100 16 256
icp_port 3130
icp_access allow all
 
cache_dir ufs /var/spool/squid 2000 16 256
cache_peer 192.130.17.4 sibling 3128 3130
cache_peer 192.130.17.42 sibling 3128 3130
cache_peer 192.130.17.53 sibling 3128 3130

 
#
# Add any of your own refresh_pattern entries above these.
#
refresh_pattern ^ftp: 1440 20% 10080
refresh_pattern ^gopher: 1440 0% 1440
refresh_pattern -i (/cgi-bin/|\?) 0 0% 0
refresh_pattern (Release|Packages(.gz)*)$ 0 20% 2880
refresh_pattern . 0 20% 4320

max_filedesc 40960
cache_mem 4000 MB
&lt;/pre&gt;

修改 /etc/squid/squid.conf 後, 以:

sudo systemctl restart squid 重新啟動.

假如要讓 Virtualbox 虛擬主機與 Windows 10 host 啟動開啟虛擬代理主機, 可以設定使用 [VBoxVmService], 但是 5.X 的 Virtualbox 必須與 VBoxVmService  5.X 版配合, 而 6.X 的版本也必須互動升級配置.

[VBoxVmService]: https://github.com/onlyfang/VBoxVmService

後記:

42 是一台 HP ML 30 gen9 的機器,  2017 安裝的 Ubuntu 在前幾天停止運作後, 直接將 Host 裝上 Win 10, 因無法從 USB 安裝, 只能用 blueray  dvd 重新安裝, 然後外部設為 39, 然後將虛擬 proxy 伺服器設為 42,  目前仍然加入服役中.
</t>
<t tx="yen.20200611221636.1"></t>
<t tx="yen.20200611221647.1"></t>
<t tx="yen.20200611221718.1"></t>
<t tx="yen.20200611223454.1"></t>
</tnodes>
</leo_file>
