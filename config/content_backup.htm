<h1>About</h1>
<p>這裡是國立虎尾科技大學機械設計工程系 (National Formosa University, Dept. of Mechanical Design Engineering, Taiwan) <a href="http://lab.kmol.info/blog/index.html">KMOlab</a> 所屬的網站. 主要提供與計算機程式, 網際內容管理, 電腦輔助設計與實習, 以及協同產品設計實習等課程相關資料.</p>
<p><a href="https://lab.mde.tw">https://lab.mde.tw</a> 是未來五年, 與 <a href="http://lab.kmol.info/blog/index.html">KMOlab</a> 有關教學課程與研究方向的規劃網站, <a href="https://chiamingyen.github.io/kmolab/blog/pages/about/">KMOLab</a> 是知識管理與最佳化應用實驗室 (Knowledge Management and Optimal utilization Laboratory) 的簡稱, 實驗室的目的在鼓勵技職體系學員, 透過長期的專題學習與研究履歷積累, 進行與機電資整合產品有關的設計工具開發 [<a href="https://www.pyslvs.com">1</a>][<a href="https://github.com/KmolYuan/Pyslvs-UI">2</a>]. 並依此研究成果, 在國內外一流學府取得碩士以上學位.</p>
<p>網站 (Web site): <a href="http://lab.mde.tw">http://lab.mde.tw</a></p>
<p>網誌 (Web blog): <a href="http://lab.mde.tw/blog">http://lab.mde.tw/blog</a></p>
<p>簡報 (Web presentation): <a href="http://lab.mde.tw/reveal">http://lab.mde.tw/reveal</a></p>
<hr/>
<h4>網站部署</h4>
<p><a href="https://lab.mde.tw">https://lab.mde.tw</a> 目前部署在機械設計工程系工作站室中的 <a href="https://www.hpe.com/au/en/servers/proliant-servers.html">HP ProLiant </a>等級伺服器上, 並將倉儲與網站內容同步至 <a href="https://fossil-scm.org">Fossil SCM</a> (Software Configuration Management), <a href="https://github.com/">Github</a> 與 <a href="https://about.gitlab.com/">Gitlab</a> 雲端倉儲中.</p>
<h2>Lab logo</h2>
<h4><a href="http://lab.kmol.info/blog/index.html">KMOLab</a> logo images</h4>
<p><img alt="" height="87" src="/images/kmol_1172x340_red_3yrs.png" width="300"/></p>
<p><img alt="" height="87" src="/images/kmol_1172x340_yellow_3yrs.png" width="300"/></p>
<p><img alt="" height="87" src="/images/kmol_1172x340_blue_3yrs.png" width="300"/></p>
<p><img alt="" height="87" src="/images/kmol_1172x340_green_3yrs.png" width="300"/></p>
<p><img alt="" height="87" src="/images/kmol_1172x340_color_3yrs.png" width="300"/></p>
<p><img alt="" height="87" src="/images/kmol_1172x340_bw_3yrs.png" width="300"/></p>
<p><img alt="" height="300" src="/images/kmol_rotary_570x570.png" width="300"/></p>
<p><img caption="false" height="264" src="/images/3yrs_camel.jpg" width="300"/></p>
<h4><a href="http://lab.kmol.info/blog/index.html">KMOLab</a> T-shirt</h4>
<p><img alt="" height="400" src="/images/kmolab_banner_tshirt.jpg" width="400"/></p>
<p><img alt="" height="400" src="/images/kmolab_rotary_tshirt.jpg" width="400"/></p>
<p></p>
<p></p>
<p style="padding-left: 30px;"></p><h2>隨身程式系統</h2>
<p><a href="https://drive.google.com/open?id=1cVJ1LOKzXerjfFyYOMlXGqoPg8DGiJSf">WCM2020_8g.7z</a> (登入 @gm 帳號後下載)</p>
<p>Python3</p>
<p style="padding-left: 30px;">pip</p>
<p style="padding-left: 30px;">flask</p>
<p style="padding-left: 30px;">flask_cors</p>
<p style="padding-left: 30px;">lxml</p>
<p style="padding-left: 30px;">bs4</p>
<p style="padding-left: 30px;">markdown</p>
<p style="padding-left: 30px;">leo</p>
<p style="padding-left: 30px;">sympy</p>
<p style="padding-left: 30px;">cv2</p>
<p style="padding-left: 30px;">numpy</p>
<p style="padding-left: 30px;">scipy</p>
<p style="padding-left: 30px;">imutils</p>
<p>Tiny C</p>
<p>SciTE</p>
<p>ShareX</p>
<p>Process explorer</p>
<p>Msys2</p>
<p>Solvespace</p>
<p>CoppeliaSim</p>
<p>Webots</p>
<p>Range3</p>
<p>Dia</p>
<p>OBS</p>
<p>Dart sdk</p>
<p>Flutter sdk</p>
<p>visual studio code</p>
<p>Virtualbox</p>
<p>Ubuntu</p>
<p>Sketchbook</p><h2>Github</h2>
<h4>Git Commands</h4>
<p>git add .</p>
<p>git commit -m "commint message"</p>
<p>git push</p>
<p>git clone</p>
<p>git clone --recurse-submodules url_of_repo</p>
<p>git status</p>
<p>git checkout</p>
<p>git submodule add url_of_repo local_directory</p>
<p>git submodule init</p>
<p>git submodule update --recursive</p>
<p>git branch</p>
<p>git pull</p>
<p>git merge</p>
<p>git remote add name url_of_repo</p>
<h4><a href="https://pages.github.com/">Github Pages</a></h4>
<p style="padding-left: 30px;"><a href="https://pages.github.com/">Github Pages</a> 為 Github 所提供的倉儲內容網頁伺服器. 使用者可以將倉儲主分支, gh-pages 分支或 docs 目錄中的 HTML, 利用 Github Pages 設定, 轉為以使用者帳號及倉儲名稱所組成的網站.</p>
<p style="padding-left: 30px;">例如: 將 github_account 中名稱為 repo 的倉儲內容設為 Github Pages 網站後, 其網址為: <a href="https://github_account.github.io/repo">https://github_account.github.io/repo</a>.</p>
<p style="padding-left: 30px;">若使用者設為 Girhub Pages 之倉儲名稱為 github_account.github.io, 則所設定的 Github Pages 網站名稱將為:</p>
<p style="padding-left: 30px;">https://github_account.github.io</p>
<h4>Github SSH</h4>
<p style="padding-left: 30px;">使用者從近端將工作目錄中的資料推送到 Github, 可以選擇 Https 或 SSH 連線協定.</p>
<p style="padding-left: 30px;">使用者提交 Github 倉儲內容改版之前, 必須利用 git config 進行身份與代理主機的設定.</p>
<p style="padding-left: 60px;">git config --edit --system</p>
<p style="padding-left: 60px;">git config --global user.name "github_account"</p>
<p style="padding-left: 60px;">git config --global user.email "your_github_account _register email"</p>
<p style="padding-left: 60px;">git config --global http.proxy=http://proxy_server:3128</p>
<p style="padding-left: 60px;">若設 IPv6 主機則使用:</p>
<p style="padding-left: 90px;">git config --global http.proxy=http://[2001::ip_address]:3128</p>
<p style="padding-left: 60px;">--global 表示要存擋到啟動隨身碟 home 目錄中的 .gitconfig 設定檔</p>
<p style="padding-left: 60px;">若 git config 不使用 --global 表示該設定僅此命令 session 有效.</p>
<p style="padding-left: 30px;">假如要在 Windows 10 操作系統中, 將倉儲設定使用 SSH 網路協定推送, 則需完成下列步驟:</p>
<p>1. 下載 Putty 工具組</p>
<p style="padding-left: 30px;"><span>從 </span><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/" rel="nofollow">https://www.chiark.greenend.org.uk/~sgtatham/putty/</a><span><span> </span>下載一般版, 或從<span> </span></span><a href="http://jakub.kotrla.net/putty/" rel="nofollow">http://jakub.kotrla.net/putty/</a><span><span> </span>下載特殊的可攜版本.</span></p>
<p><span>2. 利用 y:\portablegit\bin\sh.exe 進入 shell 命令環境後, 以 <br/></span></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">ssh-keygen -t rsa -b 4096 -C "使用者學號"</pre>
<p style="padding-left: 30px;">在 /y/home/.ssh 目錄下建立 id_rsa 與 id_rsa.pub 等 private key 與 public key</p>
<p style="padding-left: 30px;">之後以 SciTE 開啟 id_rsa.pub 後, 將此 public key 的內容, 以新增添加到 Github.com 帳號下 personal settings -&gt; SSH and GPG keys 頁面下.</p>
<p>3. 接下來要利用 puttygen.exe 將 id_rsa 轉為 Putty 可以解讀的 .ppk 格式, 並修改隨身系統的啟動批次檔案, 指定利用 putty 目錄下的 plink 執行 git 指令的網路代理設定.</p>
<p>修改啟動的 start.bat 加入下列設定:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe</pre>
<div>
<div class="syntaxhighlighter js" id="highlighter_31185"></div>
</div>
<p>4. 利用 puttygen.exe 載入第二步驟所建立的 private key, 也就是 id_rsa.</p>
<p>開啟 puttygen 之後, 以右下方的 load 載入 id_rsa, 成功載入後, 利用 save private key 按鈕, 將已經轉為 putty 格式的 .ppk 存檔. 此一 .ppk 檔案必須在設定 putty 中 github.com session 時, 在 Connection-&gt;SSH-&gt;Auth 項目下, 將轉檔後的 .ppk 指向 private key file for authentication 欄位. </p>
<p>並在 Connection-&gt;Proxy 項目下, 指定 Proxy type: HTTP, 並將 IPv6 代理主機設為 ::53 或 ::42 埠號設為 3128.</p>
<p>5. 之後確定 home 下的 .ssh 目錄中的 config 設定檔案為:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false"># no proxy at home
#ProxyCommand y:/PortableGit/mingw64/bin/connect.exe -H proxy.mde.nfu.edu.tw:3128 %h %p
# set git_ssh=y:/putty/plink.exe with auth under putty github.com session setup
ProxyCommand y:/putty/plink.exe github.com %h %p
  
Host github.com
    User git
    Port 22
    Hostname github.com
     
    # for connect.exe need openssh key format
    #IdentityFile "y:\home\.ssh\id_rsa_mdecourse"
    # for plink.exe need rsa key format but set under putty github.com session
    # plink.exe do not need the following setting
    #IdentityFile "y:\home\.ssh\mdecourse_putty_private.ppk"
  
    TCPKeepAlive yes
    IdentitiesOnly yes</pre>
<div>
<div class="syntaxhighlighter js" id="highlighter_585341"></div>
</div>
<p>6. 最後再將 wcmj2020 倉儲中 .git 目錄下的 config 檔案中的連線協定, 由 https 改為採 ssh 連線: 範例如下:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[core]
    repositoryformatversion = 0
    filemode = false
    bare = false
    logallrefupdates = true
    symlinks = false
    ignorecase = true
[submodule]
    active = .
[remote "origin"]
    #url = https://github.com/mdecourse/wcmj2020.git
    url = git@github.com:mdecourse/wcmj2020.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
    remote = origin
    merge = refs/heads/master
[submodule "cmsimde"]
    url = https://github.com/mdecourse/cmsimde.git</pre>
<div>
<div class="syntaxhighlighter js" id="highlighter_731483"></div>
</div>
<p>之後就可以透過近端的 .ppk private key 與 Github.com 上的 public key 對應, 無需輸入帳號密碼就可以進行 git push.</p><h2>Virtualbox</h2>
<p><a href="https://drive.google.com/open?id=143jFMheM1xjLxhLkSAouThLzj3WUYX6_">Ubuntu 20.04 for cd2020pj1.ova</a> (<a href="https://drive.google.com/open?id=13Gqwyj0CGR6wa9dZg_BmlCLv5cNYWQJ_">W12 version)</a> (for @gm users only)</p>
<p><a href="https://drive.google.com/open?id=1yDdGMWEzVvnuaqZ9a_VXYSAr-N4cer4K">Win10 comsol5.ova</a> (for @gm users only)</p>
<h4>Ｕbuntu 20.04 安裝 Chrome</h4>
<p style="padding-left: 30px;">sudo apt install gdebi-core wget</p>
<p style="padding-left: 30px;">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</p>
<p style="padding-left: 30px;">sudo gdebi google-chrome-stable_current_amd64.deb</p>
<p style="padding-left: 30px;">google-chrome</p>
<p style="padding-left: 30px;"> 因為 Ubuntu 中的 Chrome 使用操作系統中的 Proxy 設定, 若採 IPv6 Proxy 使用 fe80::1 格式, 且無需前後加上中括號. 但若修改系統 Proxy 設定後, Chrome 必須重新啟動後才可生效.</p><h2>Pyslvs</h2>
<p><a href="https://github.com/KmolYuan/Pyslvs-UI">https://github.com/KmolYuan/Pyslvs-UI</a></p>
<p><a href="https://www.pyslvs.com/">https://www.pyslvs.com/</a></p>
<p>論壇: <a href="https://gitter.im/pyslvs-ui/forum">https://gitter.im/pyslvs-ui/forum</a></p>
<h2>Fossil SCM</h2>
<p><a href="http://mde.tw/cp2019/content/Fossil%20SCM.html">http://mde.tw/cp2019/content/Fossil%20SCM.html</a></p>
<p>Fossil SCM 是一套軟體組態管理 (Software Configuration Management) 系統, 其中包含分散式版次控管 (DVC, Distributed Version Control) 、Wiki 、Forum、Bug Tracking 與 Technote 等功能, 可以用來控制及追蹤軟體開發專案, 並且紀錄專案開發歷程.</p>
<h4>安裝 Fossil SCM</h4>
<h4>Windows</h4>
<p style="padding-left: 30px;">從 <a href="https://fossil-scm.org/home/uv/download.html">https://fossil-scm.org/home/uv/download.html</a> 下載 Windows 64 位元 2.11 版, 解開壓縮檔案, 將 fossil.exe 放入隨身程式系統的 Y:\ 即可在命令列利用:</p>
<p style="padding-left: 60px;">fossil version</p>
<p style="padding-left: 30px;">查詢版本.</p>
<h4>MacOS</h4>
<p style="padding-left: 30px;">從 <a href="https://fossil-scm.org/home/uv/download.html">https://fossil-scm.org/home/uv/download.html</a> 下載 MacOS 版本後, 自動解開壓縮取得 fossil 可執行檔案後, 以 env 查詢 PATH 路徑設定, 可以利用:</p>
<p style="padding-left: 60px;">cd</p>
<p style="padding-left: 60px;">cd Downloads</p>
<p style="padding-left: 60px;">sudo mv fossil /opt/local/bin</p>
<p style="padding-left: 30px;">先更換目錄到帳號 home 之後, 進入 Downloads 目錄, 將 fossil 放到 /opt/local/bin 目錄中, 接著就可以利用:</p>
<p style="padding-left: 60px;">fossil version</p>
<p style="padding-left: 30px;">查詢版本.</p>
<p style="padding-left: 30px;">但若該 fossil 並沒有經由 Apple 公證 (notarized), 則必須至 System Preferences - Security &amp; Privacy - General 中, 針對 "fossil" was blocked from use because it is not from an identified developer 項目, 選擇 "Allow Anyway".</p>
<p style="padding-left: 30px;">截至 2020.05.23, Fossil SCM 的 MacOS 2.11 與 2.10 版都未經過 Apple 公證.</p>
<h4>Ubuntu</h4>
<p style="padding-left: 30px;">從 <a href="https://fossil-scm.org/home/uv/download.html">https://fossil-scm.org/home/uv/download.html</a> 下載 Linux X64 版本後, 解開壓縮檔案後, 將 fossil 放到 /usr/bin 目錄後, 即可利用:</p>
<p style="padding-left: 60px;">fossil version</p>
<p style="padding-left: 30px;">查詢版本.</p>
<p style="padding-left: 30px;">或者利用 sudo apt install fossil 安裝.</p>
<h3>配置 Fossil SCM</h3>
<h4>Ubuntu</h4>
<p style="padding-left: 30px;">sudo apt install fossil stunnel</p>
<p style="padding-left: 30px;">在 /etc/environment 檔案中加入:</p>
<p style="padding-left: 60px;">HTTPS=on</p>
<p style="padding-left: 30px;">在 /etc/default/stunnel4 檔案中加入</p>
<p style="padding-left: 60px;">ENABLED=1</p>
<p style="padding-left: 30px;">利用</p>
<p style="padding-left: 60px;">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout stunnel.key -out stunnel.crt</p>
<p style="padding-left: 30px;">在 /etc/stunnel 目錄中建立 stunnel.key 與 stunnel.crt</p>
<p style="padding-left: 30px;">接著建立 /etc/stunnel/stunnel.conf</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[https]
accept=kmol2020:5443
accept=:::5443
cert=/etc/stunnel/stunnel.crt
key=/etc/stunnel/stunnel.key
exec=/usr/bin/fossil
execargs=/usr/bin/fossil http /home/kmol2020/repository/ --https --nojail --notfound kmol2020</pre>
<p>在 /home/kmol2020/ 建立 repository 目錄, 以及 kmol2020.fossil 後, 以 /etc/init.d/stunnel4 restart 重新啟動伺服器.</p>
<p>管理者可以從 <a href="https://[:1]:5443">https://[::1]:5443</a> 登入.</p><h1>計算機程式</h1>
<p>計算機程式是工程師解決問題的工具之一, 而工程師希望利用計算機程式解決問題之前需要對電腦與其周遭環境相關的事項有所了解</p>
<h4>電腦基本軟硬體術語及功能</h4>
<h4>電腦網路設定與應用</h4>
<h4>電腦程式語言:</h4>
<h4 style="padding-left: 30px;">Javascript</h4>
<p style="padding-left: 60px;"><a href="https://drive.google.com/open?id=18StxYXFRbJzQiwOjkiMEAMYToX96-Hyq">Javascript course note.pdf</a></p>
<p style="padding-left: 60px;">https://javascript.info/</p>
<p style="padding-left: 60px;"><a href="https://www.khanacademy.org/computing/computer-programming">https://www.khanacademy.org/computing/computer-programming</a></p>
<h4 style="padding-left: 30px;">C</h4>
<p style="padding-left: 60px;"><a href="https://modernc.gforge.inria.fr/">https://modernc.gforge.inria.fr/</a> (<a href="https://drive.google.com/open?id=1gEndnExRZ-WR7yPQL1IxIQAN4Btu7dM-">Modern C.pdf</a>)</p>
<p style="padding-left: 60px;"><a href="http://karadev.net/uroci/filespdf/files/Programming-in-ANSI-C.pdf">http://karadev.net/uroci/filespdf/files/Programming-in-ANSI-C.pdf</a> (<a href="https://drive.google.com/open?id=1pgE-xT3mFbfEK3fC532z15kp-L0QdNaJ">Programming-in-ANSI-C.pdf)</a></p>
<h4 style="padding-left: 30px;">Dart</h4>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Dart_(programming_language)">https://en.wikipedia.org/wiki/Dart_(programming_language)</a></p>
<p style="padding-left: 60px;"><a href="https://dartpad.github.io">https://dartpad.github.io</a></p>
<p style="padding-left: 60px;"><a href="https://flutter.dev/web">https://flutter.dev/web</a></p>
<h4 style="padding-left: 30px;">Python</h4>
<p style="padding-left: 60px;"><a href="http://do1.dr-chuck.com/pythonlearn/EN_us/pythonlearn.pdf">http://do1.dr-chuck.com/pythonlearn/EN_us/pythonlearn.pdf</a></p>
<p style="padding-left: 90px;"><a href="https://drive.google.com/open?id=1tYFRytEEkPuuUTE4O9Q6AURaHcU598BV">Python-for-everyone.pdf</a></p>
<h4>資料結構</h4>
<p style="padding-left: 30px;"><a href="https://opendatastructures.org/ods-cpp.pdf">https://opendatastructures.org/ods-cpp.pdf</a> (C++)</p>
<p style="padding-left: 30px;"><a href="https://www.cs.auckland.ac.nz/compsci105s1c/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf">https://www.cs.auckland.ac.nz/compsci105s1c/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf</a></p>
<p style="padding-left: 60px;"><a href="https://drive.google.com/open?id=17S_Bb1O7JiMYGHdU6sQ4CYwAhHPC5E8B">利用資料結構與演算法解題.pdf </a>(Python)</p>
<p></p><h2>ＷＷＷ網頁</h2>
<p>你需要一個 World Wide Web Page, 帶有分門別類的標題與內容, 能夠紀錄日誌, 可以直接在瀏覽器上進行簡報, 無論是在廣域網路, 區域網路或單一電腦上.</p>
<p><a href="https://github.com/mdecourse/cmsimde.git">CMSiMDE</a> 就是因應機械設計工程師需要建立上述</p>
<p>網頁 (Web Page)</p>
<p>簡報 (Web Presentation)</p>
<p>網誌 (Web Blog)</p>
<p>而拼拼湊湊成的一套系統.</p>
<h3>Javascript</h3>
<p>一般建議是將 Javascript 放在 &lt;/body&gt; 標註之前, 也就是所有頁面內容的最後面, 因為這樣會讓瀏覽用戶先看到整個頁面內容之後, 再下載執行頁面所需的 Javascript, 如此, 使用者會"感覺"頁面的資料擷取順暢, 不會頁面載入到中途, 因下載或執行 Javascript 程式碼而停頓.</p>
<p>Beginning JavaScript (2019)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-4395-4">https://link.springer.com/book/10.1007/978-1-4842-4395-4</a></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">for (var i=0; i&lt;10; i++)
    // 將原本列在 console 區的資料導引到下列程式執行輸出區
    console.log(i + ": Hello, 開始學習 Javascript!");</pre>
<p>下列範例,  以 <a href="https://www.arc.id.au/CanvasGraphics.html">https://www.arc.id.au/CanvasGraphics.html</a> 繪圖程式庫中的程式碼為例.</p>
<script src="/downloads/dart_ex/cango/Cango-15v00-min.js"></script>
<script src="/downloads/dart_ex/cango/CangoAxes-6v01-min.js"></script>
<script src="/downloads/dart_ex/cango/Cango3D-8v00-min.js"></script>
<script src="/downloads/dart_ex/cango/gearUtils-09.js"></script>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<!--
<script type="text/javascript" src="/static/ace/mode-python3.js"></script>
<script type="text/javascript" src="/static/ace/snippets/python.js"></script>
--></p>
<!-- 嘗試直接使用 ace.js 編寫 Javascript -->
<div id="js_editor" style="width: 600px; height: 300px;"></div>
<p>
<script>
editor = window.ace.edit("js_editor");
session = editor.getSession();
//session.setMode("ace/mode/javascript");
editor.setOptions({
// Javascript 中的 true 與 false 為小寫開頭
             enableLiveAutocompletion: true,
             enableSnippets: true,
             highlightActiveLine: false,
             highlightSelectedWord: true,
             autoScrollEditorIntoView: true,
             // 'maxLines': session.getLength() 可以根據程式長度設定 editor 列數
             // 設定讓使用者最多可以在畫面中顯示 20 行程式碼
             maxLines: 20,
             fontSize: '12pt'
            });
if (localStorage["js_src"] != null){
    editor.setValue(localStorage["js_src"]);
}else{
    editor.setValue(`
  var g = new Cango('canvas'),
      i, data = [];

  g.gridboxPadding(10);
  g.setWorldCoordsRHC(0, -50, 2*Math.PI, 100);
  // draw axes
  g.drawAxes(0, 6.5, -50, 50, {
    xOrigin:0, yOrigin:0,
    fontSize:10,
    strokeColor:'gray'});

  for (i=0; i<=2*Math.PI; i+=0.03) {
    data.push(i, 50*Math.sin(i));
  }
  g.drawPath(data, {strokeColor:'red'});
  console.log("繪圖完成");
`);
}
editor.scrollToRow(0);
editor.gotoLine(0);

function runjs(){
    code = editor.getValue();
    localStorage['js_src'] = code;
    // 在目前頁面中執行 code
    // grabbed from https://stackoverflow.com/questions/6432984/adding-script-element-to-the-dom-and-have-the-javascript-run
    var script = document.createElement('script');
    try {
      script.appendChild(document.createTextNode(code));
      document.body.appendChild(script);
    } catch (e) {
      script.text = code;
      document.body.appendChild(script);
    }
}

// 用於清除 console 輸出區
function clearBox(elementID)
{
    document.getElementById(elementID).innerHTML = "";
}

// 設定擴大 console 區
function showConsole()
{
    document.getElementById("js_console").cols = 60;
    document.getElementById("js_console").rows = 10;
}

// 清除 canvas
function clearCanvas(canvasID)
{
    var canvas = document.getElementById(canvasID);
    const context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
}

// redirect console.log to page id="js_console" area
// https://stackoverflow.com/questions/11403107/capturing-javascript-console-log
(function(){
    var oldLog = console.log;
    console.log = function (message) {
        document.getElementById("js_console").innerHTML+= message + "\n";
        oldLog.apply(console, arguments);
    };
})();

// get gist data with id
function getGist(gistid, filename)
{
    $.ajax({
      url: 'https://api.github.com/gists/'+gistid,
      type: 'GET',
      dataType: 'jsonp'
    }).success( function(gistdata) {
        var content = gistdata.data.files[filename].content;
            editor.setValue(content);
      }).error( function(e) {
      // ajax error
      console.log("ajax error");
});
}
</script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["js_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".js");
}
</script>
</p>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="js_filename" placeholder="input file name" type="text"/>.js</label> <input onclick="doSave('js_src', 'js_filename');" type="submit" value="Save"/></form>
<p><button onclick="runjs()">Run</button><button onclick="showConsole()">Output</button><button onclick="clearBox('js_console')">清除輸出區</button><button onclick="clearCanvas('canvas')">清除繪圖區</button><button onclick="clearBox('html')">清除 html 區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="js_console"></textarea></div>
<p><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'ROCFlag.js')">ROC Flag</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'plotSin.js')">Plot Sin</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'plotCos.js')">Plot Cos</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'excavator.js')">Excavator</button> <button onclick="getGist('e267db237e4ec2c38d208529503b1bbf', 'ajax_get_stud_data.js')">Read Stud List</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'bouncingBall.js')">Bouncing Ball</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'editCurve.js')">Edit Curve</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'groupDrag.js')">Group Drag</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'involuteGear1.js')">Involute Gear</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'gearMeshing.js')">Gear Meshing</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'internalGear.js')">Internal Gear</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'threejs_cube.js')">Three.js Cube</button><button onclick="getGist('d2f8b8898ff1a17a078374ee8dc714c4', 'canvas_drawLine.js')">Canvas Draw Line</button></p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.js">
</script>
<div id="html"></div>
<p><canvas height="400" id="canvas" width="600"></canvas></p><h3>JQuery</h3>
<p>JQuery 起源於 <a href="https://johnresig.com/blog/selectors-in-javascript/">https://johnresig.com/blog/selectors-in-javascript/,</a> 展示透過 CSS Selector 可以與 Javascript 的元件互動.</p>
<p>CSS</p>
<p>Document Object Model (DOM)</p>
<p>Javascript elements</p><h3>Html</h3>
<h3>Canvas</h3>
<h3>Dart</h3>
<p>下列影片說明如何利用 Javascript 建立按鈕, 讓 <a href="https://dartpad.github.io">https://dartpad.github.io</a> 可以直接帶出存放在 <a href="https://github.com/mdecourse/cp2019/tree/master/downloads/dart_ex">downloads</a> 目錄中的 Dart 程式範例. 所引用的程式包含<a href="https://github.com/dartpad/dartpad.github.io/blob/master/embed-dart.html">純 Dart 程式碼</a>, 包含 html 與 css 的<a href="https://github.com/dartpad/dartpad.github.io/blob/master/embed-html.html">網際程式碼</a>, 以及 <a href="https://github.com/dartpad/dartpad.github.io/blob/master/embed-flutter.html">flutter 程式碼</a>等三種.</p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/hoEUb5NIgrU" width="560"></iframe></p>
<!-- 透過 getDart(dirname) 取位於 downloads/dart_ex/ 目錄中 dirname 目錄中的 Dart 程式碼 -->
<script>
function getDart(dirname){
    source = "https://dartpad.github.io/embed-dart.html?gh_owner=mdecourse&gh_repo=cp2019&gh_path=downloads/dart_ex/" + dirname + "&theme=dark";
    document.getElementById("iframe").src = source ;
}

function getHtmlDart(dirname){
    source = "https://dartpad.github.io/embed-html.html?gh_owner=mdecourse&gh_repo=cp2019&gh_path=downloads/dart_ex/" + dirname + "&theme=dark";
document.getElementById("iframe").src = source ;
}

function getFlutter(dirname){
    source = "https://dartpad.github.io/embed-flutter.html?gh_owner=mdecourse&gh_repo=cp2019&gh_path=downloads/dart_ex/" + dirname + "&theme=dark";
document.getElementById("iframe").src = source ;
}

function largest(){
document.getElementById("iframe").width = document.body.clientWidth ;
document.getElementById("iframe").height = document.body.clientWidth*0.5 ;
}

function original(){
document.getElementById("iframe").width = 800 ;
document.getElementById("iframe").height = 600 ;
}
</script>
<!-- 取 Dart 程式的按鈕 -->
<h4>純 Dart 程式</h4>
<p><button onclick="getDart('hello')">Hello</button> <button onclick="getDart('for')">For Loop</button> <button onclick="getDart('sum')">Sum</button> <button onclick="getDart('runge_kutta')">Runge-Kutta</button> <button onclick="getDart('rk_ex1')">RK ex1</button> <button onclick="getDart('mass_spring_damping')">Mass Spring Damping</button> <button onclick="getDart('function')">Function</button> <button onclick="getDart('fun_parameter')">Function Parameter</button> <button onclick="getDart('fat_arrow')">Fat Arrow</button> <button onclick="getDart('temp1')">Temp 1</button></p>
<h4>Html 程式</h4>
<p><button onclick="getHtmlDart('random_grouping')">亂數分組</button> <button onclick="getHtmlDart('roc_flag')">ROC Flag</button> <button onclick="getHtmlDart('rotROC')">rot ROC</button> <button onclick="getHtmlDart('usaflag')">USA Flag</button> <button onclick="getHtmlDart('grid')">Grid</button> <button onclick="getHtmlDart('xyplot')">X-Y Plot</button> <button onclick="getHtmlDart('slithery')">Slithery</button> <button onclick="getHtmlDart('html_tetris')">Tetris</button></p>
<h4>Flutter 程式</h4>
<p><button onclick="getFlutter('flutter0')">Flutter0</button> <button onclick="getFlutter('flutter1')">Flutter1</button> <button onclick="getFlutter('flutter2')">Flutter2</button> <button onclick="getFlutter('flutter3')">Flutter3</button> <button onclick="getFlutter('flutter4')">Flutter4</button> <button onclick="getFlutter('flutter_counter')">Flutter Counter</button> <button onclick="getFlutter('flutter_roc')">ROC Flag</button> <button onclick="getFlutter('flutter_mine1')">踩地雷 1</button> <button onclick="getFlutter('flutter_mine2')">踩地雷 2</button> <button onclick="getFlutter('flutter_mine3')">踩地雷 3</button> <button onclick="getFlutter('flutter_mine4')">踩地雷 4</button> <button onclick="getFlutter('flutter_dropdown')">Dropdown</button> <button onclick="getFlutter('flutter_multiselect')">Multiselect</button> <button onclick="getFlutter('flutter_search')">Search</button> <button onclick="getFlutter('flutter_login')">Login</button> <button onclick="getFlutter('flutter_temp')">溫度轉換</button> <button onclick="getFlutter('flutter_ttt')">Tic-Tac-Toe</button> <button onclick="getFlutter('flutter_calculator')">Calculator</button> <button onclick="getFlutter('flutter_mouse1')">Mouse1</button> <button onclick="getFlutter('flutter_paint1')">Paint1</button></p>
<!-- 內建放入的 Dart 原始碼 -->
<p><button onclick="largest()">放大</button> <button onclick="original()">回復</button></p>
<p><iframe height="600" id="iframe" src="https://dartpad.dartlang.org/embed-dart.html?gh_owner=mdecourse&amp;gh_repo=cp2019&amp;gh_path=downloads/dart_ex/mass_spring_damping&amp;theme=dark" width="800"></iframe></p><h3>WebGL</h3><h2>學號抽點</h2>
<p>為了編寫能夠進行修課學員學號抽點的程式, 提出下列兩種可行方案:</p>
<p style="padding-left: 30px;">將原本按照順序排列的學號次序弄亂, 然後按所需抽點的人數,  從已經弄亂的學號中一一取出</p>
<p style="padding-left: 30px;">依據所要抽點的人數, 建立一個由亂數組成的資料,  然後從順序排列的學號中抽出所要</p>
<h4>抽點的目的</h4>
<p style="padding-left: 30px;">查核學員學習情況</p>
<p style="padding-left: 30px;">讓抽點學員回報學習狀況</p>
<p style="padding-left: 30px;">交付任務, 要求抽點出的學員執行任務, 並交付報告</p><h3>亂數分組</h3>
<h4>evenGrouping.dart</h4>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">import 'dart:html';
  
  InputElement studListUrl = querySelector("#studListUrl");
  String studUrl;
  // 將 Label 改為 Textarea, 避免產生過程結果嵌入所在頁面
  TextAreaElement output = querySelector("#output");
  
main() {
  querySelector("#submit").onClick.listen((e) =&gt; grouping());
}
  
grouping() {
  output.innerHtml = "";
  
  if (studListUrl.value != "") {
    studUrl = studListUrl.value;
  } else {
    studUrl = 'https://mde.tw/group/downloads/2019fall_cp_1a_list.txt';
  }
  
  // 組序由 1 開始
  int gth = 1;
  // 迴圈序號變數
  int i;
  int j;
  int total;
  int inc;
  // 每組學員暫存數列
  var gpList = [];
  // 全班分組數列
  var group = [];
  // 各組人數數列
  var numList = [];
  var courseTitle = 'cd2020';
  
  HttpRequest.getString(studUrl).then((String resp) {
    // 利用 trim() 去除字串最後的跳行符號, 之後再利用 split() 根據 \n 轉為數列
    var studList = resp.trim().split("\n");
    // 數列利用 shuffle() 方法以隨機方法弄亂順序
    studList.shuffle();
    total = studList.length;
    output.text += "全班總計" + total.toString() + " 人\n";
    numList = getNumList(studList.length);
    inc = 0;
    for (i in numList){
      // 列印區隔符號
      output.text += '=' * 20 + "\n";
      output.text += "group $gth 有 " + i.toString() + " 人: \n";
      gpList = [];
      for (j = 0; j &lt; i; j++){
        output.text += studList[j+inc] + "\n";
        // 在各分組數列中加入將對應的學員學號
        gpList.add(studList[j+inc]);
      }
      gth = gth + 1;
      inc = inc + j;
        //output.text += studList[j] + "\n";
        // 逐步將各組暫存的分組數列加入全班分組數列中
      gpList.sort();
      group.add(gpList);
    }
    // 列出全班分組數列
    output.text += group.toString() + "\n";
    // 列出已經排序後的分組名單
    output.text += '=' * 25 + "\n";
    output.text += '以下為排序後的各組成員名單: \n';
    gth = 1;
    /*
    404231
    s4052
    4062
    s4072
    4082
    5072
    5083
    */
    // 先列出純文字以 \n 跳行組員資料
    for (i=0; i &lt; group.length; i++){
      // 列印區隔符號
      output.text += '=' * 20 + "\n";
      output.text += "group $gth \n";
      gpList = [];
      for (j=0; j &lt; group[i].length; j++){
        output.text += group[i][j] + "\n";
      }
      gth = gth + 1;
    }
     
    gth = 1;
    // 最後列出超文件以 &lt;br\&gt; 跳行組員資料, 包含倉儲與網站
    for (i=0; i &lt; group.length; i++){
      // 列印區隔符號
      output.text += '\n' + '=' * 30 + "&lt;br \&gt;";
      output.text += "group $gth &lt;br \&gt;";
      gpList = [];
      for (j=0; j &lt; group[i].length; j++){
          if (group[i][j].startsWith('4052') || group[i][j].startsWith('4072')) {
              output.text += "Repository: &lt;a href='https://github.com/s" + 
                                      group[i][j] + "/" + courseTitle + "'&gt;" + group[i][j] + 
                                      "&lt;/a&gt;" + " | Site: &lt;a href='https://s" + group[i][j] + 
                                      ".github.io/" + courseTitle + "'&gt;" + group[i][j] + 
                                      "&lt;/a&gt;&lt;br \&gt;";
          }
          else {
              output.text += "Repository: &lt;a href='https://github.com/" + 
                                      group[i][j] + "/" + courseTitle +"'&gt;" + group[i][j] + 
                                      "&lt;/a&gt;" + " | Site: &lt;a href='https://" + group[i][j] + 
                                      ".github.io/" + courseTitle + "'&gt;" + group[i][j] + 
                                      "&lt;/a&gt;&lt;br \&gt;";
          }
      }
      gth = gth + 1;
    }
  });
}
  
List getNumList(int total){
  // total student number
  // int total = 65;
  // initial each group expect to be "eachGrp" number of people
  int eachGrp = 10;
  // may divide into "grpNum" number of group
  int grpNum = total ~/ eachGrp;
  // vacant list
  var splits = [];
  // find remainder when total number divid into "grpNum" number of group
  int remainder = total % grpNum;
  // number of people in one group by calculation
  int calGrp = total ~/ grpNum;
  
  for (int i = 0; i &lt; grpNum; i++) {
    splits.add(calGrp);
  }
  //print(splits);
  
  for (int i = 0; i &lt; remainder; i++) {
    splits[i] += 1;
  }
  //print(splits);
  return splits;
 }</pre>
<h4>index.html</h4>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;h1&gt;亂數分組:&lt;/h1&gt;
學員名單 URL: &lt;input type="text" id="studListUrl" size="50" value="https://mde.tw/wcm2020/downloads/2020spring_wcm_1a_list.txt"&gt;&lt;br /&gt;
&lt;input type="submit" value="開始分組" id="submit"&gt;&lt;br /&gt;
&lt;textarea id="output" cols="80" rows="10"&gt;&lt;/textarea&gt;</pre>
<p>style.css</p>
<pre class="brush:css;auto-links:false;toolbar:false" contenteditable="false">body {
  color: white;
  font-size: 20px;
}
 
input, select, textarea {
font-size: 100%;
}</pre>
<h4>get_student.py</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, request 
from flask_cors import CORS
 
import requests
import bs4
import ssl
 
'''
https://s1.mde.nfu.edu.tw:7443/?semester=1082&amp;courseno=0767
cd
2a 1082/0767
2b 1082/0780
 
2a 1072/0777
2b 1072/0790
2a 1062/0788
2a 1062/0802
 
wcm
1082/0744
 
1072/0754
1062/0765
 
wcmj
1082/2418
'''
 
app = Flask(__name__)
CORS(app)
 
@app.route('/studlist')
@app.route('/')
def studlist():
    semester = request.args.get('semester')
    courseno = request.args.get('courseno')
    if semester == None:
        semester = '1082'
    if courseno == None:
        courseno = '0744'
     
    url = 'https://osa.nfu.edu.tw/query/studlist_ajax.php'
    post_var = {'pselyr': semester, 'pseqno': courseno}
 
    result = requests.post(url, data = post_var)
 
    soup = bs4.BeautifulSoup(result.content, 'lxml')
    table = soup.find('table', {'class': 'tbcls'})
    data = []
    rows = table.find_all('tr')
    for row in rows:
        cols = row.find_all('td')
        cols = [ele.text.strip() for ele in cols]
        data.append([ele for ele in cols if ele]) # Get rid of empty values
    output = ""
    for i in data[2:]:
        #print(i[0])
        output +=i[0] + "\n"
    return output
    #return  str(pselyr) + " + " +str(pseqno)
 
# 即使在近端仍希望以 https 模式下執行
context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
context.load_cert_chain('localhost.crt', 'localhost.key')
 
# 取 flaskapp.py 中的 uwsgi 變數設定
uwsgi = False
if uwsgi:
    # 表示程式在雲端執行
    application = app
else:
    # 表示在近端執行, 以 python3 wsgi.py 執行
    app.run(host='127.0.0.1', port=5443, debug=True, ssl_context=context)</pre>
<h4>nginx sites-available/default settings:</h4>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">server {
    listen 8000;
    server_name s1.mde.nfu.edu.tw;
    charset utf-8;
     
    listen 7443 ssl;
  
    location /static {
        alias /home/kmol2019/course_studlist/static/;
    }
  
    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:8087;
    }
     
    ssl_certificate /etc/stunnel/localhost.crt;
    ssl_certificate_key /etc/stunnel/localhost.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}</pre>
<h4>uwsgi7.ini</h4>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">uwsgi]
socket = 127.0.0.1:8087
uid = kmol2019
gid = kmol2019
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
master = true
logto = /var/log/uwsgi/emperor.log
logfile-chown = kmol2019:kmol2019
processes = 4
threads = 2
chdir = /home/kmol2019/course_studlist
wsgi-file = /home/kmol2019/course_studlist/get_student.py</pre>
<h4>/etc/systemd/system/cmsimfly.service</h4>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[Unit]
Description=uWSGI to serve CMSimfly
After=network.target
 
[Service]
User=kmol2019
Group=kmol2019
WorkingDirectory=/home/kmol2019/uwsgi_ini
ExecStart=/usr/local/bin/uwsgi --emperor /home/kmol2019/uwsgi_ini
 
[Install]
WantedBy=multi-user.target</pre>
<h4>random_select.dart</h4>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">import 'dart:html';
import 'dart:convert';
 
SelectElement studListUrl = querySelector("#RstudListUrl");
String grpList;
InputElement numOfStud = querySelector("#RnumOfStud");
int num;
// 將 Label 改為 Textarea, 避免產生過程結果嵌入所在頁面
TextAreaElement output = querySelector("#Routput");
 
main() {
  querySelector("#Rsubmit").onClick.listen((e) =&gt; randomSelect());
}
 
randomSelect() {
  output.innerHtml = "";
 
  if (studListUrl.value != "") {
    grpList = studListUrl.value;
  } else {
    grpList = 'https://mde.tw/cd2020/downloads/2a_group_list.txt';
  }
 
  if (numOfStud.value != "") {
    num = int.parse(numOfStud.value);
  } else {
    num = 2;
  }
 
  HttpRequest.getString(grpList).then((String resp) {
    final replaced = resp.replaceAll("'", '');
    List studList = jsonDecode(replaced);
    for (int i = 0; i &lt; studList.length; i++) {
      // shuffle studList element
      studList[i].shuffle();
      // draw num of member from each group
      output.text += "-" * 20 + "\n";
      for (int j = 0; j &lt; num; j++) {
        output.text += "group ${i + 1}:" + studList[i][j].toString() + "\n";
      }
    }
  });
}</pre>
<h4>index.html</h4>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;h1&gt;每組隨機抽選:&lt;/h1&gt;
學員名單 URL: 
&lt;select id="RstudListUrl"&gt;
  &lt;option value="https://mde.tw/cd2020/downloads/2a_group_list.txt" selected&gt;2a&lt;/option&gt;
  &lt;option value="https://mde.tw/cd2020/downloads/2b_group_list.txt"&gt;2b&lt;/option&gt;
&lt;/select&gt;&lt;br /&gt;
每組抽選人數: &lt;input type="text" id="RnumOfStud" size="2" value="1"&gt;&lt;br /&gt;
&lt;input type="submit" value="開始" id="Rsubmit"&gt;&lt;br /&gt;
&lt;textarea id="Routput" cols="80" rows="10"&gt;&lt;/textarea&gt;</pre>
<h4>main.css</h4>
<pre class="brush:css;auto-links:false;toolbar:false" contenteditable="false">body {
  color: white;
  font-size: 20px;
}
 
input, select, textarea {
font-size: 100%;
}</pre>
<h4>利用 Python 進行亂數分組:</h4>
<p>randomw6.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import random
import requests
 
# getNumList 主要在每組最低人數下, 將不足 10 人的分組
# 平均分配至各組
def getNumList(total, eachGrp=10):
    # total is the number of students
    # each group at least 10 students
    #eachGrp = 10;
    # may divide into "grpNum" number of group
    grpNum = total // eachGrp;
    # check grpNum
    #print(grpNum)
    # vacan list
    splits = []
    # find remainder when total number divid into "grpNum" number of group
    remainder = total % grpNum
    # number of people in one group by calculation
    calGrp = total // grpNum
     
    for i in range(grpNum):
        splits.append(calGrp)
         
    # check first splits
    #print(splits)
   
    for i in range(remainder):
        splits[i] += 1
     
    # check final splits
    #print(splits);
    return splits;
 
# 儲存學生名單資料的 url
target_url = "http://mde.tw/cd2020/downloads/2020spring_cd_2a_list.txt"
# 利用 requests 讀取 url 中的資料
f = requests.get(target_url)
# get student list from target_url
# 利用 splitlines() 將資料放入數列 studList
studList = f.text.splitlines()
# 每組預計分組的最低人數
num_in_one_group = 10
# 每組學員暫存數列
gpList = []
# 全班分組數列
group = []
# 各組人數數列
numList = []
# get numList
numList = getNumList(len(studList), num_in_one_group)
# check numList
# 列出已經補齊的各組人數數列
print("預計各組人數數列:" + str(numList))
 
output = ""
gth = 1
inc = 0
 
# 弄亂 studList
random.shuffle(studList)
output += "以下為尚未排序前的各組學員學號: \n"
for i in numList:
    # 列印區隔符號
    output += '=' * 20 + "\n";
    output += "group " + str(gth) + " 有 " + str(i) + " 人: \n"
    # 每組學員暫存數列, 在此 reset
    gpList = []
    for j in range(i):
        output += studList[j+inc] + "\n"
        # 在各分組數列中加入將對應的學員學號
        gpList.append(studList[j+inc])
       
    gth = gth + 1
    inc = inc + j
    # 將各組學員數列依照學號排序
    gpList.sort()
    group.append(gpList)
 
# 列出尚未排序前的分組結果
print(output)
# 列出已經完成排序的分組數列
print("已經排序後的分組數列:" + str(group))
 
output = ""
# 列出已經排序後的分組名單
output += '=' * 25 + "\n"
output += '以下為排序後的各組成員名單:\n'
gth = 1
 
# 先列出純文字以 \n 跳行組員資料
for i in range(len(group)):
    # 列印區隔符號
    output += '=' * 20 + "\n"
    output += "group" + str(gth) + "\n"
    gpList = []
     
    for j in range(len(group[i])):
        output += str(group[i][j]) + "\n"
       
    gth = gth + 1
     
print(output)</pre>
<h3>隨機與基因演算</h3>
<p><a href="http://lab.kmol.info/blog/2015-cadp-w16.html">http://lab.kmol.info/blog/2015-cadp-w16.html</a></p>
<p><a href="https://github.com/DEAP/deap">https://github.com/DEAP/deap</a></p>
<p><a href="/downloads/ga/A genetic algorithm for bin packaging.pdf">A genetic algorithm for bin packaging.pdf</a></p>
<p><a href="/downloads/ga/An_Efficient_Algorithm_for_3D_Rectangular_Box_Packing.pdf">An_Efficient_Algorithm_for_3D_Rectangular_Box_Packing.pdf</a></p>
<p>RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># https://github.com/flukeskywalker/PyRGA
# 原始程式為 Python2 修改為 Python3 格式
# 除了原先的最大化適應值外, 增加最小化方法設定
import numpy as np
import random
import math

# 請注意各代族群數必須為 4 的倍數
class GA: # popsize must be multiple of 4
    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):
        self.EPSILON = 10e-6
        self.INFINITY = 10e6
        self.pop = []
        self.fits = []
        self.obj = obj
        self.dim = dim
        self.popsize = popsize
        self.ngen = ngen
        self.pc = pc
        self.pm = pm
        self.etac = etac
        self.etam = etam
        # min = 1 表最小化, min = -1 表最大化
        self.min = min
        self.RIGID = 0
        self.lowb = -self.INFINITY*np.ones(self.dim)
        self.highb = self.INFINITY*np.ones(self.dim)
        self.tourneylist = range(0, self.popsize)
        self.tourneysize = 2 # works for 2 for now
        self.bestmemyet = np.zeros(self.dim)
        # 若是求最大值
        if self.min == -1:
            self.bestfityet = -np.inf
        else:
        # 若是求最小值
            self.bestfityet = np.inf
        self.pop_init()

    def pop_init(self):
        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]
        for member in self.pop:
            for i in range(self.dim):
                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])
        self.fits = [self.obj(member) for member in self.pop]
        #self.pop_print()
        return

    def setbounds(self, lows, highs):
        for i in range(self.dim):
            self.lowb[i] = lows[i]
            self.highb[i] = highs[i]
        self.pop_init()
        return

    def run(self):
        for gen in range(self.ngen):
            print("Generation ", gen)
            self.pop = self.getnewpop()
            self.eval_pop()
            #self.pop_print()
        return [self.bestmemyet, self.bestfityet]

    def getnewpop(self):
        newpop = []
        #self.tourneylist = range(0, self.popsize)
        random.shuffle(list(self.tourneylist))
        self.tourneypos = 0
        for i in range(0, self.popsize, 2):
            [p1, p2] = self.getparents() #return parents, not just indices
            [c1, c2] = self.xover(p1, p2) #return children, not just indices
            c1 = self.mutate(c1)
            c2 = self.mutate(c2)
            newpop.append(c1)
            newpop.append(c2)
        return newpop

    def getparents(self):
        if (self.popsize - self.tourneypos) &lt; self.tourneysize:
            random.shuffle(list(self.tourneylist))
            self.tourneypos = 0
        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize

        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize
        return [p1, p2]

    def xover(self, p1, p2): # Here p1 and p2 are pop members
        c1 = np.zeros_like(p1)
        c2 = np.zeros_like(p2)
        if random.random()&lt;=self.pc: # do crossover
            for i in range(p1.size):
                if random.random()&lt;0.5: # 50% variables crossover
                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])
                else:
                    [c1[i], c2[i]] = [p1[i], p2[i]]
        else:
            c1 = p1
            c2 = p2
        return [c1, c2]

    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables
        if p1&gt;p2:
            p1, p2 = p2, p1 # p1 must be smaller
        mean = (p1+p2)*0.5
        diff = (p2-p1)
        dist = max(min(p1-low, high-p2), 0)
        if (self.RIGID and diff &gt; self.EPSILON):
            alpha = 1.0 + (2.0*dist/diff)
            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))
            seed = umax*random.random()
        else:
            seed = random.random()
        beta = self.getbeta(seed)
        if (abs(diff*beta) &gt; self.INFINITY):
            beta = self.INFINITY/diff
        c2 = mean + beta*0.5*diff
        c1 = mean - beta*0.5*diff
        c1 = max(low, min(c1, high))
        c2 = max(low, min(c2, high))
        return [c1, c2]

    def getbeta(self, seed):
        if (1 - seed) &lt; self.EPSILON:
            seed = 1 - self.EPSILON
        seed = max(0.0, seed)
        if seed &lt; 0.5:
            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))
        else:
            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))
        return beta

    def getdelta(self, seed, delta_low, delta_high):
        if seed &gt;= 1.0 - (self.EPSILON/1e3):
            return delta_high
        if seed &lt;= (self.EPSILON/1e3):
            return delta_low
        if seed &lt;= 0.5:
            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))
            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0
        else:
            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))
            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))
        return delta

    def mutate(self, member):
        mut_member = np.zeros_like(member)
        for i in range(member.size):
            low = self.lowb[i]
            high = self.highb[i]
            if random.random() &lt;= self.pm: # pm is simply the prob of a variable to mutate
                if self.RIGID:
                    value = member[i]
                    delta_low = max((low-value)/(high-low), -1.0)
                    delta_high = min((high-value)/(high-low), 1.0)
                    if abs(delta_low)&lt;abs(delta_high):
                        delta_high = -delta_low
                    else:
                        delta_low = -delta_high
                else:
                    delta_low = -1.0
                    delta_high = 1.0
                seed = random.random()
                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)
                mut_member[i] = max(low, min(member[i] + delta, high))
            else:
                mut_member[i] = member[i]
        return mut_member

    def eval_pop(self):
        self.fits = [self.obj(member) for member in self.pop]
        # 若是最大化適應值題目者
        if self.min == -1:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmax(self.fits)
        else:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmin(self.fits)
        bestmember = self.pop[bestindex]
        bestfitness = self.fits[bestindex]
        # self.min = -1 for maximization, self.min = 1 for minimization
        if self.min == -1:
            # 若是在族群中的最佳適應值大於目前為止最佳的適應值
            if bestfitness &gt; self.bestfityet:
                # 則將此最大適應值指為目前為止最佳適應值
                self.bestfityet = bestfitness
                # 並且將最佳族群成員指向目前最佳成員
                self.bestmemyet = bestmember
        else:
            if bestfitness &lt; self.bestfityet:
                self.bestfityet = bestfitness
                self.bestmemyet = bestmember
        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)

    def pop_print(self):
        for i in range(self.popsize):
            print(self.pop[i], self.fits[i])
        return

# 若單獨存在則需導入 GA 所有方法
#import GA
#from GA import *
import numpy as np

def square(x):
    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)
    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)
    term3 = term1+term2
    return term3

# 最大化體積題目
def volume(x):
    surface = 80.0
    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))
    volume = x[0]*x[1]*z
    return volume


def miniex1(x):
    '''Minimizing Beale's function (optimal value f(3, 0.5) = 0):
    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    term1 = 1.5 - x[0] + x[0]*x[1]
    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]
    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]
    return term1*term1 + term2*term2 + term3*term3

def miniex2(x):
    '''Schaffer function #2. Minimium at (0,0), equal to 0
    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    return 0.5 + (math.pow(math.sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/math.pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)

#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化
#ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
ga=GA(miniex1, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
ga.setbounds(np.zeros(10), 10*np.ones(10))
#ga.setbounds(-10*np.ones(10), 10*np.ones(10))
#ga.pop_init()
print(ga.run())</pre>
<p>利用 C 與 Differential Evolution 解上述相同問題的原始碼:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">// 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散??
 
/***************************************************************
**                                                            **
**        D I F F E R E N T I A L     E V O L U T I O N       **
**                                                            **
** Program: de.c                                              **
** Version: 3.6                                               **
**                                                            **
** Authors: Dr. Rainer Storn                                  **
**          c/o ICSI, 1947 Center Street, Suite 600           **
**          Berkeley, CA 94707                                **
**          Tel.:   510-642-4274 (extension 192)              **
**          Fax.:   510-643-7684                              **
**          E-mail: storn@icsi.berkeley.edu                   **
**          WWW: http://http.icsi.berkeley.edu/~storn/        **
**          on leave from                                     **
**          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
**          D-81739 Muenchen, Germany                         **
**          Tel:    636-40502                                 **
**          Fax:    636-44577                                 **
**          E-mail: rainer.storn@zfe.siemens.de               **
**                                                            **
**          Kenneth Price                                     **
**          836 Owl Circle                                    **
**          Vacaville, CA 95687                               **
**          E-mail: kprice@solano.community.net               ** 
**                                                            **
** This program implements some variants of Differential      **
** Evolution (DE) as described in part in the techreport      **
** tr-95-012.ps of ICSI. You can get this report either via   **
** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
** A more extended version of tr-95-012.ps is submitted for   **
** publication in the Journal Evolutionary Computation.       ** 
**                                                            **
** You may use this program for any purpose, give it to any   **
** person or change it according to your needs as long as you **
** are referring to Rainer Storn and Ken Price as the origi-  **
** nators of the the DE idea.                                 **
** If you have questions concerning DE feel free to contact   **
** us. We also will be happy to know about your experiences   **
** with DE and your suggestions of improvement.               **
**                                                            **
***************************************************************/
/**H*O*C**************************************************************
**                                                                  **
** No.!Version! Date ! Request !    Modification           ! Author **
** ---+-------+------+---------+---------------------------+------- **
**  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
**    +      +       +         + included                  +        **
**  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
**  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
**  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
**  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
**  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
**    +      +       +         + initialization            +        **
**  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
**  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
**  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
**  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
**  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
**  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
**  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
**  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
**                                                                  **
***H*O*C*E***********************************************************/
 
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "memory.h"
#include &lt;time.h&gt;
 
// 最大族群數, NP
#define MAXPOP  5000
// 最大向量維度, D
#define MAXDIM  35
#define MAXIMAPROBLEM 0
#define PENALITY 1000
 
/*------Constants for rnd_uni()--------------------------------------------*/
 
#define IM1 2147483563
#define IM2 2147483399
#define AM (1.0/IM1)
#define IMM1 (IM1-1)
#define IA1 40014
#define IA2 40692
#define IQ1 53668
#define IQ2 52774
#define IR1 12211
#define IR2 3791
#define NTAB 32
#define NDIV (1+IMM1/NTAB)
#define EPS 1.2e-7
#define RNMX (1.0-EPS)
 
// 與機構合成相關的常數定義
#define PI 3.1415926
#define degree PI/180.0
#define mech_loop -1
#define NUM_OF_POINTS 10
 
/*------------------------Macros----------------------------------------*/
 
/*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                           /* works only for small  */
                                                           /* arrays, but is faster.*/
 
/*------------------------Globals---------------------------------------*/
 
long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];
 
/*---------Function declarations----------------------------------------*/
 
void  assignd(int D, double a[], double b[]);
double rnd_uni(long *idum);    /* uniform pseudo random number generator */
double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */
 
// 與機構合成相關的函式宣告
double distance(double x0, double y0, double x1, double y1);
double rr(double L1, double dd, double theta);
struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt);
void mechanism(double x0, double y0, double x1, double y1, double L1,
  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);
 
struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);
 
/*---------Function definitions-----------------------------------------*/
// 指定向量 b 為 a
void  assignd(int D, double a[], double b[])
/**C*F****************************************************************
**                                                                  **
** Assigns D-dimensional vector b to vector a.                      **
** You might encounter problems with the macro ASSIGND on some      **
** machines. If yes, better use this function although it's slower. **
**                                                                  **
***C*F*E*************************************************************/
{
   int j;
   for (j=0; j&lt;D; j++)
   {
      a[j] = b[j];
   }
}
 
// 產生 0 ~ 1 間的亂數
double rnd_uni(long *idum)
/**C*F****************************************************************
**                                                                  **
** SRC-FUNCTION   :rnd_uni()                                        **
** LONG_NAME      :random_uniform                                   **
** AUTHOR         :(see below)                                      **
**                                                                  **
** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
**                 dom number in the interval [0,1]. For further    **
**                 reference see Press, W.H. et alii, Numerical     **
**                 Recipes in C, Cambridge University Press, 1992.  **
**                                                                  **
** FUNCTIONS      :none                                             **
**                                                                  **
** GLOBALS        :none                                             **
**                                                                  **
** PARAMETERS     :*idum    serves as a seed value                  **
**                                                                  **
** PRECONDITIONS  :*idum must be negative on the first call.        **
**                                                                  **
** POSTCONDITIONS :*idum will be changed                            **
**                                                                  **
***C*F*E*************************************************************/
{
  long j;
  long k;
  static long idum2=123456789;
  static long iy=0;
  static long iv[NTAB];
  double temp;
 
  if (*idum &lt;= 0)
  {
    if (-(*idum) &lt; 1) *idum=1;
    else *idum = -(*idum);
    idum2=(*idum);
    for (j=NTAB+7;j&gt;=0;j--)
    {
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &lt; 0) *idum += IM1;
      if (j &lt; NTAB) iv[j] = *idum;
    }
    iy=iv[0];
  }
  k=(*idum)/IQ1;
  *idum=IA1*(*idum-k*IQ1)-k*IR1;
  if (*idum &lt; 0) *idum += IM1;
  k=idum2/IQ2;
  idum2=IA2*(idum2-k*IQ2)-k*IR2;
  if (idum2 &lt; 0) idum2 += IM2;
  j=iy/NDIV;
  iy=iv[j]-idum2;
  iv[j] = *idum;
  if (iy &lt; 1) iy += IMM1;
  if ((temp=AM*iy) &gt; RNMX) return RNMX;
  else return temp;
 
}/*------End of rnd_uni()--------------------------*/
 
// 將上下限轉為全域變數
double inibound_h;      /* upper parameter bound              */
double inibound_l;      /* lower parameter bound              */
// 與機構合成相關的全域變數
// 宣告一個座標結構
struct Coord {
    double x;
    double y;
  // 這裡保留 double z;
};
 
main(int argc, char *argv[])
/**C*F****************************************************************
**                                                                  **
** SRC-FUNCTION   :main()                                           **
** LONG_NAME      :main program                                     **
** AUTHOR         :Rainer Storn, Kenneth Price                      **
**                                                                  **
** DESCRIPTION    :driver program for differential evolution.       **
**                                                                  **
** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
**                 fopen(), fclose(), fscanf().                     **
**                                                                  **
** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
**                                                                  **
** PARAMETERS     :argc            #arguments = 3                   **
**                 argv            pointer to argument strings      **
**                                                                  **
** PRECONDITIONS  :main must be called with three parameters        **
**                 e.g. like de1 &lt;input-file&gt; &lt;output-file&gt;, if     **
**                 the executable file is called de1.               **
**                 The input file must contain valid inputs accor-  **
**                 ding to the fscanf() section of main().          **
**                                                                  **
** POSTCONDITIONS :main() produces consecutive console outputs and  **
**                 writes the final results in an output file if    **
**                 the program terminates without an error.         **
**                                                                  **
***C*F*E*************************************************************/
 
{
   char  chr;             /* y/n choice variable                */
   char  *strat[] =       /* strategy-indicator                 */
   {
            "",
            "DE/best/1/exp",
            "DE/rand/1/exp",
            "DE/rand-to-best/1/exp",
            "DE/best/2/exp",
            "DE/rand/2/exp",
            "DE/best/1/bin",
            "DE/rand/1/bin",
            "DE/rand-to-best/1/bin",
            "DE/best/2/bin",
            "DE/rand/2/bin"
   };
 
   int   i, j, L, n;      /* counting variables                 */
   int   r1, r2, r3, r4;  /* placeholders for random indexes    */
   int   r5;              /* placeholders for random indexes    */
   int   D;               /* Dimension of parameter vector      */
   int   NP;              /* number of population members       */
   int   imin;            /* index to member with lowest energy */
   int   refresh;         /* refresh rate of screen output      */
   int   strategy;        /* choice parameter for screen output */
   int   gen, genmax, seed;   
 
   long  nfeval;          /* number of function evaluations     */
 
   double trial_cost;      /* buffer variable                    */
   // 將上下限轉為全域變數, 可能要根據各變數加以設定
   //double inibound_h;      /* upper parameter bound              */
   //double inibound_l;      /* lower parameter bound              */
   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
   double cost[MAXPOP];    /* obj. funct. values                 */
   double cvar;            /* computes the cost variance         */
   double cmean;           /* mean cost                          */
   double F,CR;            /* control variables of DE            */
   double cmin;            /* help variables                     */
 
   FILE  *fpin_ptr;
   FILE  *fpout_ptr;
 
// 計算執行過程所需時間起點, 需要導入 time.h
  clock_t start = clock();
 
/*------Initializations----------------------------*/
 
 //if (argc != 3)                                 /* number of arguments */
 //{
    //printf("\nUsage : de &lt;input-file&gt; &lt;output-file&gt;\n");
    //exit(1);
 //}
 
// 將結果寫入 out.dat
 fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                          /* to see whether it already exists */
 /*
 if ( fpout_ptr != NULL )
 {
    printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
    printf("want to overwrite it, \nanything else if you want to exit.\n");
    chr = (char)getchar();
    if ((chr != 'y') &amp;&amp; (chr != 'Y'))
    {
      exit(1);
    }
    fclose(fpout_ptr);
 }
*/
 
/*-----Read input data------------------------------------------------*/
 
 //fpin_ptr   = fopen(argv[1],"r");
/*
 if (fpin_ptr == NULL)
 {
    printf("\nCannot open input file\n");
    exit(1);
 }*/
 
 //fscanf(fpin_ptr,"%d",&amp;strategy);       /*---choice of strategy-----------------*/
 //fscanf(fpin_ptr,"%d",&amp;genmax);         /*---maximum number of generations------*/
 //fscanf(fpin_ptr,"%d",&amp;refresh);        /*---output refresh cycle---------------*/
 //fscanf(fpin_ptr,"%d",&amp;D);              /*---number of parameters---------------*/
 //fscanf(fpin_ptr,"%d",&amp;NP);             /*---population size.-------------------*/
 //fscanf(fpin_ptr,"%lf",&amp;inibound_h);    /*---upper parameter bound for init-----*/
 //fscanf(fpin_ptr,"%lf",&amp;inibound_l);    /*---lower parameter bound for init-----*/
 //fscanf(fpin_ptr,"%lf",&amp;F);             /*---weight factor----------------------*/
 //fscanf(fpin_ptr,"%lf",&amp;CR);            /*---crossing over factor---------------*/
 //fscanf(fpin_ptr,"%d",&amp;seed);           /*---random seed------------------------*/
// 目前已經採用 strategy 3 可以得到最佳結果
  strategy = 3;
  genmax = 2000;
  refresh = 100;
  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值
  D = 19;
  NP = 200;
  inibound_h = 50.;
  inibound_l = 0.;
/*得到最佳解
  F = 0.85;
CR 必須介於 0 to 1. 之間
  CR = 1.;
*/
  F = 0.85;
  CR = 1.;
  seed = 3;
 
 //fclose(fpin_ptr);
 
/*-----Checking input variables for proper range----------------------------*/
 
  if (D &gt; MAXDIM)
  {
     printf("\nError! D=%d &gt; MAXDIM=%d\n",D,MAXDIM);
     exit(1);
  }
  if (D &lt;= 0)
  {
     printf("\nError! D=%d, should be &gt; 0\n",D);
     exit(1);
  }
  if (NP &gt; MAXPOP)
  {
     printf("\nError! NP=%d &gt; MAXPOP=%d\n",NP,MAXPOP);
     exit(1);
  }
  if (NP &lt;= 0)
  {
     printf("\nError! NP=%d, should be &gt; 0\n",NP);
     exit(1);
  }
  if ((CR &lt; 0) || (CR &gt; 1.0))
  {
     printf("\nError! CR=%f, should be ex [0,1]\n",CR);
     exit(1);
  }
  if (seed &lt;= 0)
  {
     printf("\nError! seed=%d, should be &gt; 0\n",seed);
     exit(1);
  }
  if (refresh &lt;= 0)
  {
     printf("\nError! refresh=%d, should be &gt; 0\n",refresh);
     exit(1);
  }
  if (genmax &lt;= 0)
  {
     printf("\nError! genmax=%d, should be &gt; 0\n",genmax);
     exit(1);
  }
  if ((strategy &lt; 0) || (strategy &gt; 10))
  {
     printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
     exit(1);
  }
  if (inibound_h &lt; inibound_l)
  {
     printf("\nError! inibound_h=%f &lt; inibound_l=%f\n",inibound_h, inibound_l);
     exit(1);
  }
 
 
/*-----Open output file-----------------------------------------------*/
 
   //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */
 
   //if (fpout_ptr == NULL)
   //{
      //printf("\nCannot open output file\n");
      //exit(1);
   //}
 
 
/*-----Initialize random number generator-----------------------------*/
 
 rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
 nfeval       =  0;  /* reset number of function evaluations */
 
 
 
/*------Initialization------------------------------------------------*/
/*------Right now this part is kept fairly simple and just generates--*/
/*------random numbers in the range [-initfac, +initfac]. You might---*/
/*------want to extend the init part such that you can initialize-----*/
/*------each parameter separately.------------------------------------*/
 
   for (i=0; i&lt;NP; i++)
   {
      for (j=0; j&lt;D; j++) /* spread initial population members */
      {
        c[i][j] = inibound_l + rnd_uni(&amp;rnd_uni_init)*(inibound_h - inibound_l);
      }
      cost[i] = evaluate(D,c[i],&amp;nfeval); /* obj. funct. value */
   }
   cmin = cost[0];
   imin = 0;
   for (i=1; i&lt;NP; i++)
   {
     if(MAXIMAPROBLEM == 1)
     {
       // 改為最大化
        if (cost[i]&gt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
      else
      {
        // 最小化問題
        if (cost[i]&lt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
   }
 
   assignd(D,best,c[imin]);            /* save best member ever          */
   assignd(D,bestit,c[imin]);          /* save best member of generation */
 
   pold = &amp;c; /* old population (generation G)   */
   pnew = &amp;d; /* new population (generation G+1) */
 
/*=======================================================================*/
/*=========Iteration loop================================================*/
/*=======================================================================*/
 
   gen = 0;                          /* generation counter reset */
   while ((gen &lt; genmax) /*&amp;&amp; (kbhit() == 0)*/) /* remove comments if conio.h */
   {                                            /* is accepted by compiler    */
      gen++;
      imin = 0;
 
      for (i=0; i&lt;NP; i++)         /* Start of loop through ensemble  */
      {
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 2 !!!     */
       r1 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while(r1==i);            
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 3 !!!     */
       r2 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r2==i) || (r2==r1));
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 4 !!!     */
       r3 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r3==i) || (r3==r1) || (r3==r2));
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 5 !!!     */
       r4 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));
 
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 6 !!!     */
       r5 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));
 
 
/*=======Choice of strategy===============================================================*/
/*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
/*=======DE :  stands for Differential Evolution==========================================*/
/*=======x  :  a string which denotes the vector to be perturbed==========================*/
/*=======y  :  number of difference vectors taken for perturbation of x===================*/
/*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
/*                                                                                        */
/*=======There are some simple rules which are worth following:===========================*/
/*=======1)  F is usually between 0.5 and 1 (in rare cases &gt; 1)===========================*/
/*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
/*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
/*           happens.                                                                     */
/*=======4)  If you increase NP, F usually has to be decreased============================*/
/*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/
 
 
/*=======EXPONENTIAL CROSSOVER============================================================*/
 
/*-------DE/best/1/exp--------------------------------------------------------------------*/
/*-------Our oldest strategy but still not bad. However, we have found several------------*/
/*-------optimization problems where misconvergence occurs.-------------------------------*/
     if (strategy == 1) /* strategy DE0 (not in our paper) */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/1/exp-------------------------------------------------------------------*/
/*-------This is one of my favourite strategies. It works especially well when the-------*/
/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
/*-------as a first guess.---------------------------------------------------------------*/
     else if (strategy == 2) /* strategy DE1 in the techreport */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
/*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
/*-------should play around with all three control variables.----------------------------*/
     else if (strategy == 3) /* similiar to DE2 but generally better */
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                       
         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
     else if (strategy == 4)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
     else if (strategy == 5)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
 
/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/
 
/*-------DE/best/1/bin--------------------------------------------------------------------*/
     else if (strategy == 6) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/1/bin-------------------------------------------------------------------*/
     else if (strategy == 7) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
     else if (strategy == 8) 
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/best/2/bin--------------------------------------------------------------------*/
     else if (strategy == 9)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/2/bin--------------------------------------------------------------------*/
     else
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
 
 
/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/
 
     trial_cost = evaluate(D,tmp,&amp;nfeval);  /* Evaluate new vector in tmp[] */
   if(MAXIMAPROBLEM == 1)
   {
    // 改為最大化
       if (trial_cost &gt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&gt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
    else
    {
          // 最小化問題
       if (trial_cost &lt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&lt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
 
      }   /* End mutation loop through pop. */
 
      assignd(D,bestit,best);  /* Save best population member of current iteration */
 
      /* swap population arrays. New generation becomes old one */
 
      pswap = pold;
      pold  = pnew;
      pnew  = pswap;
 
/*----Compute the energy variance (just for monitoring purposes)-----------*/
 
      cmean = 0.;          /* compute the mean value first */
      for (j=0; j&lt;NP; j++)
      {
         cmean += cost[j];
      }
      cmean = cmean/NP;
 
      cvar = 0.;           /* now the variance              */
      for (j=0; j&lt;NP; j++)
      {
         cvar += (cost[j] - cmean)*(cost[j] - cmean);
      }
      cvar = cvar/(NP-1);
 
 
/*----Output part----------------------------------------------------------*/
 
      if (gen%refresh==1)   /* display after every refresh generations */
      { /* ABORT works only if conio.h is accepted by your compiler */
    printf("\n\n                         PRESS ANY KEY TO ABORT"); 
    printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);
 
    for (j=0;j&lt;D;j++)
    {
      printf("\n best[%d]=%-15.10g",j,best[j]);
    }
    printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
    printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
               NP,F,CR,cvar);
      }
 
      fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
   }
/*=======================================================================*/
/*=========End of iteration loop=========================================*/
/*=======================================================================*/
 
/*-------Final output in file-------------------------------------------*/
 
 
   fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);
 
   for (j=0;j&lt;D;j++)
   {
     fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
   }
   fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
   fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
           NP,F,CR,cvar); 
 
  fclose(fpout_ptr);
 
  /* Code you want timed here */
  printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
   return(0);
}
 
/*-----------End of main()------------------------------------------*/
 
// 適應函式 fittness function (cost function)
double evaluate(int D, double tmp[], long *nfeval)
{
  // 先處理通過 5 個點的四連桿問題
  // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
  // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
  // L1 為第一桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[4]
  // L2 為第二桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[5]
  // L3 為第三桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[6]
  // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
  // L5, L6 必須 &gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
  // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
  // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
  // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
  // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
  /* void mechanism(double x0, double y0, double x1, double y1, double L1,
  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
  struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
  double input_angles[NUM_OF_POINTS], result;
  int i;
 
  (*nfeval)++;
 
  target_points[0].x = 1.0;
  target_points[0].y = 1.0;
 
  target_points[1].x = 2.0;
  target_points[1].y = 2.0;
 
  target_points[2].x = 3.0;
  target_points[2].y = 3.0;
 
  target_points[3].x = 4.0;
  target_points[3].y = 4.0;
 
  target_points[4].x = 5.0;
  target_points[4].y = 5.0;
 
  target_points[5].x = 6.0;
  target_points[5].y = 6.0;
 
  target_points[6].x = 7.0;
  target_points[6].y = 7.0;
 
  target_points[7].x = 8.0;
  target_points[7].y = 8.0;
 
  target_points[8].x = 9.0;
  target_points[8].y = 9.0;
 
  target_points[9].x = 10.0;
  target_points[9].y = 10.0;
 
  // 輸入角度值與 tmp[] 的設定
  for(i = 0; i &lt; NUM_OF_POINTS; i++)
  {
    input_angles[i] = tmp[i + 9];
  }
  // 呼叫 mechanism() 以便計算 output_points[]
  mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);
 
  // for debug
  /*
  if(*nfeval%3000 == 0)
  {
    for(i = 0; i &lt; NUM_OF_POINTS; i++)
    {
      printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
    }
    printf("#####################################\n");
  }
  */
  // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
  result = error_function(output_points, target_points);
  // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result
 
  // x0 與 x1 點位於 -500 與 500 中間
    for(i = 0; i &lt; 4; i++)
  {
    if(tmp[i] &lt; -50 || tmp[i] &gt; 50){
      return PENALITY;
    }
  }
 
  // 三個連桿值, 一定要為正
    for(i = 4; i &lt; 7; i++)
  {
    if(tmp[i] &lt; 0 || tmp[i] &gt; 50){
      return PENALITY;
    }
  }
 
    // L5 L6 可以為 0 或負值
    for(i = 7; i &lt; 9; i++)
  {
    if(tmp[i] &lt; -50 || tmp[i] &gt; 50){
      return PENALITY;
    }
  }
 
  // 角度值一定要大於 0
 
  for(i = 1; i &lt;= NUM_OF_POINTS; i++)
  {
    if((tmp[D-i] &lt; 0)){
      return PENALITY;
    }
  }
 
  return result;
 
  /*
   double result=0, surface = 80.0, z, volume, penality;
   (*nfeval)++;
   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
   volume = tmp[0]*tmp[1]*z;
 
  if(volume &lt;= 0){
    return PENALITY;
  }
 
  if((tmp[0] &lt;= inibound_l)|| (tmp[0] &gt;inibound_h)){
    return PENALITY;
  }
 
  if((tmp[1] &lt;= inibound_l) || (tmp[1] &gt;inibound_h)){
    return PENALITY;
  }
  // volume must &gt;0 and max volume
  // 目前為最小化問題
   return 1+1/(volume*volume);
   */
}
 
struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
{
    struct Coord tip_coord;
 
    if (localt&gt;=0 &amp;&amp; localt &lt;PI)
    {
        // 目前蓋掉的式子為利用手動代換出來的版本
        //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
        // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
    pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
    }
    else
    {
        // 目前蓋掉的式子為利用手動代換出來的版本
        //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
    pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
    pow(x1-x0,2))/2)+x0;
    }
 
// 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
    if (localt&gt;=0 &amp;&amp; localt &lt;PI)
    {
        tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                ))
                +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                +y0;*/
                // 利用 sqrtt 居中進行代換所得到的式子
                pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
    pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
 
    }
    else
    {
        tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                ))
                +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                +y0;*/
                pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
    pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
    }
 
  return tip_coord;
}
 
double distance(double x0, double y0, double x1, double y1)
{
    double distance_value;
    distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
    return distance_value;
}
 
double rr(double L1, double dd, double theta)
{
    double rr_value;
    rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta));
    return rr_value;
}
 
// 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
void mechanism(double x0, double y0, double x1, double y1, double L1,
  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
{
  // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
  // 以下為可能的處理變數宣告
  // 這裡希望能夠定義一個 struct 來處理座標點
  double rr_length, dd_length, angle;
  struct Coord link1_tip, link2_tip, triangle_tip;
    double angle2, angle3;
  int i;
 
  // 開始進行三角形頂點座標的計算
  // 以下變數由每一個體向量提供
  /*
    x0 = 0.0;
    y0 = 0.0;
    x1 = 10.0;
    y1 = 0.0;
    L1 = 5.0;
    L2 = 20;
    L3 = 10;
    L5 = 10;
    L6 = 10;
  */
  dd_length = distance(x0, y0, x1, y1);
  /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
  angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));
 
  for(i = 0; i &lt; NUM_OF_POINTS; i++)
  {
    // 先建立第一點座標, 即 i=0 者
    // i=0;
    // angle = i*degree;
    /*
    // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
    if(i &gt; 0)
    {
      input_angles[i] = input_angles[i] + input_angles[i-1];
    }
    */
    angle = input_angles[i]*degree;
    rr_length = rr(L1, dd_length, angle);
    // 第一次三角形疊代
    link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
    // 第二次三角形疊代
    /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
    angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
    link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
    // 第三次三角形疊代
    //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
    // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
    // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
    output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
  }
}
 
double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
{
  double error = 0.0;
  int i;
  for(i = 0; i &lt; NUM_OF_POINTS; i++)
  {
    error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
  }
  return error;
}
 
struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
{
  struct Coord tip3_coord;
  double theta3, theta4, length3, length4;
  length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
  length4 = sqrt(pow(r1,2) + pow(r2,2));  
  theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
  theta4 = acos(r1 / length4);
  tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
  tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);
 
  return tip3_coord;
}</pre>
<p><a href="https://www.analyzemath.com/calculus/Problems/maximum_volume_problem.html">https://www.analyzemath.com/calculus/Problems/maximum_volume_problem.html</a></p>
<h4>使用 <a href="https://github.com/DEAP/deap">Deap 程式庫</a>解紙盒最大體積設計題目:</h4>
<p><a href="https://github.com/DEAP/deap">https://github.com/DEAP/deap</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import random
import array
from deap import base
from deap import benchmarks
from deap import creator
from deap import tools
import numpy
# Problem dimension, 最大化紙箱 volume
NDIM = 2
# minimization problem
# create(name, base, attributes)
'''
The weights are used in the fitness comparison. They are shared among all fitnesses of the same type. 
When subclassing Fitness, the weights must be defined as a tuple where each element is associated
 to an objective. A negative weight element corresponds to the minimization of the associated 
 objective and positive weight to the maximization.
'''
# weights 為 1.0 表示最大化 fitness
creator.create("FitnessMax", base.Fitness, weights=(1.0,))
'''
Evolution strategies individuals are slightly different as they contain generally two list, 
one for the actual individual and one for its mutation parameters. This time instead of using 
the list base class we will inherit from an array.array for both the individual and the strategy. 
Since there is no helper function to generate two different vectors in a single object we must 
define this function our-self. The initES() function receives two classes and instantiate them 
generating itself the random numbers in the intervals provided for individuals of a given size.
'''
creator.create("Individual", array.array, typecode='d', fitness=creator.FitnessMax)
toolbox = base.Toolbox()
# for sphere
#toolbox.register("attr_float", random.uniform, -3, 3)
'''
toolbox.register("attr_int", random.randint, INT_MIN, INT_MAX)
toolbox.register("attr_flt", random.uniform, FLT_MIN, FLT_MAX)
toolbox.register("individual", tools.initCycle, creator.Individual,
                 (toolbox.attr_int, toolbox.attr_flt), n=N_CYCLES)
'''
toolbox.register("attr_float", random.uniform, 0, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
# selection method
toolbox.register("select", tools.selRandom, k=3)
# fitness function is benchmarks.sphere
# for sphere
#toolbox.register("evaluate", benchmarks.sphere)
'''
SURFACE = 80, 最大化 volume
z =(SURFACE - x*y)/(2.*(x+y));
    volume=x*y*z;
'''
def evalVolume(individual):
    SURFACE = 80.0
    x = individual[0]
    y = individual[1]
    # 確保 x 與 y 都是正值
    if x &lt; 0 or y &lt; 0:
        return -1000,
    z =(SURFACE - x*y)/(2.0*(x+y))
    volume = x*y*z
    return volume,

#toolbox.register("evaluate", benchmarks.ackley)
toolbox.register("evaluate", evalVolume)

def main():
    # Differential evolution parameters
    CR = 0.25
    F = 1 
    MU = 300
    NGEN = 100
     
    pop = toolbox.population(n=MU);
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("std", numpy.std)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)
     
    logbook = tools.Logbook()
    logbook.header = "gen", "evals", "std", "min", "avg", "max"
    
    # Evaluate the individuals
    fitnesses = toolbox.map(toolbox.evaluate, pop)
    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit
    
    record = stats.compile(pop)
    logbook.record(gen=0, evals=len(pop), **record)
    print(logbook.stream)
     
    for g in range(1, NGEN):
        for k, agent in enumerate(pop):
            a,b,c = toolbox.select(pop)
            y = toolbox.clone(agent)
            index = random.randrange(NDIM)
            for i, value in enumerate(agent):
                if i == index or random.random() &lt; CR:
                    y[i] = a[i] + F*(b[i]-c[i])
            y.fitness.values = toolbox.evaluate(y)
            if y.fitness &gt; agent.fitness:
                pop[k] = y
        hof.update(pop)
        record = stats.compile(pop)
        logbook.record(gen=g, evals=len(pop), **record)
        print(logbook.stream)
    print ("Best individual is ", hof[0], hof[0].fitness.values[0])
     
if __name__ == "__main__":
    main()</pre>
<p>紙盒最大體積化題目以 RGA 實數基因演算法解題:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># https://github.com/flukeskywalker/PyRGA
# 原始程式為 Python2 修改為 Python3 格式
# 除了原先的最大化適應值外, 增加最小化方法設定
import numpy as np
import random
import math

# 請注意各代族群數必須為 4 的倍數
class GA: # popsize must be multiple of 4
    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):
        self.EPSILON = 10e-6
        self.INFINITY = 10e6
        self.pop = []
        self.fits = []
        self.obj = obj
        self.dim = dim
        self.popsize = popsize
        self.ngen = ngen
        self.pc = pc
        self.pm = pm
        self.etac = etac
        self.etam = etam
        # min = 1 表最小化, min = -1 表最大化
        self.min = min
        self.RIGID = 0
        self.lowb = -self.INFINITY*np.ones(self.dim)
        self.highb = self.INFINITY*np.ones(self.dim)
        self.tourneylist = range(0, self.popsize)
        self.tourneysize = 2 # works for 2 for now
        self.bestmemyet = np.zeros(self.dim)
        # 若是求最大值
        if self.min == -1:
            self.bestfityet = -np.inf
        else:
        # 若是求最小值
            self.bestfityet = np.inf
        self.pop_init()

    def pop_init(self):
        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]
        for member in self.pop:
            for i in range(self.dim):
                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])
        self.fits = [self.obj(member) for member in self.pop]
        #self.pop_print()
        return

    def setbounds(self, lows, highs):
        for i in range(self.dim):
            self.lowb[i] = lows[i]
            self.highb[i] = highs[i]
        self.pop_init()
        return

    def run(self):
        for gen in range(self.ngen):
            print("Generation ", gen)
            self.pop = self.getnewpop()
            self.eval_pop()
            #self.pop_print()
        return [self.bestmemyet, self.bestfityet]

    def getnewpop(self):
        newpop = []
        #self.tourneylist = range(0, self.popsize)
        random.shuffle(list(self.tourneylist))
        self.tourneypos = 0
        for i in range(0, self.popsize, 2):
            [p1, p2] = self.getparents() #return parents, not just indices
            [c1, c2] = self.xover(p1, p2) #return children, not just indices
            c1 = self.mutate(c1)
            c2 = self.mutate(c2)
            newpop.append(c1)
            newpop.append(c2)
        return newpop

    def getparents(self):
        if (self.popsize - self.tourneypos) &lt; self.tourneysize:
            random.shuffle(list(self.tourneylist))
            self.tourneypos = 0
        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize

        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]&gt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]&lt;self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize
        return [p1, p2]

    def xover(self, p1, p2): # Here p1 and p2 are pop members
        c1 = np.zeros_like(p1)
        c2 = np.zeros_like(p2)
        if random.random()&lt;=self.pc: # do crossover
            for i in range(p1.size):
                if random.random()&lt;0.5: # 50% variables crossover
                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])
                else:
                    [c1[i], c2[i]] = [p1[i], p2[i]]
        else:
            c1 = p1
            c2 = p2
        return [c1, c2]

    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables
        if p1&gt;p2:
            p1, p2 = p2, p1 # p1 must be smaller
        mean = (p1+p2)*0.5
        diff = (p2-p1)
        dist = max(min(p1-low, high-p2), 0)
        if (self.RIGID and diff &gt; self.EPSILON):
            alpha = 1.0 + (2.0*dist/diff)
            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))
            seed = umax*random.random()
        else:
            seed = random.random()
        beta = self.getbeta(seed)
        if (abs(diff*beta) &gt; self.INFINITY):
            beta = self.INFINITY/diff
        c2 = mean + beta*0.5*diff
        c1 = mean - beta*0.5*diff
        c1 = max(low, min(c1, high))
        c2 = max(low, min(c2, high))
        return [c1, c2]

    def getbeta(self, seed):
        if (1 - seed) &lt; self.EPSILON:
            seed = 1 - self.EPSILON
        seed = max(0.0, seed)
        if seed &lt; 0.5:
            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))
        else:
            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))
        return beta

    def getdelta(self, seed, delta_low, delta_high):
        if seed &gt;= 1.0 - (self.EPSILON/1e3):
            return delta_high
        if seed &lt;= (self.EPSILON/1e3):
            return delta_low
        if seed &lt;= 0.5:
            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))
            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0
        else:
            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))
            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))
        return delta

    def mutate(self, member):
        mut_member = np.zeros_like(member)
        for i in range(member.size):
            low = self.lowb[i]
            high = self.highb[i]
            if random.random() &lt;= self.pm: # pm is simply the prob of a variable to mutate
                if self.RIGID:
                    value = member[i]
                    delta_low = max((low-value)/(high-low), -1.0)
                    delta_high = min((high-value)/(high-low), 1.0)
                    if abs(delta_low)&lt;abs(delta_high):
                        delta_high = -delta_low
                    else:
                        delta_low = -delta_high
                else:
                    delta_low = -1.0
                    delta_high = 1.0
                seed = random.random()
                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)
                mut_member[i] = max(low, min(member[i] + delta, high))
            else:
                mut_member[i] = member[i]
        return mut_member

    def eval_pop(self):
        self.fits = [self.obj(member) for member in self.pop]
        # 若是最大化適應值題目者
        if self.min == -1:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmax(self.fits)
        else:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmin(self.fits)
        bestmember = self.pop[bestindex]
        bestfitness = self.fits[bestindex]
        # self.min = -1 for maximization, self.min = 1 for minimization
        if self.min == -1:
            # 若是在族群中的最佳適應值大於目前為止最佳的適應值
            if bestfitness &gt; self.bestfityet:
                # 則將此最大適應值指為目前為止最佳適應值
                self.bestfityet = bestfitness
                # 並且將最佳族群成員指向目前最佳成員
                self.bestmemyet = bestmember
        else:
            if bestfitness &lt; self.bestfityet:
                self.bestfityet = bestfitness
                self.bestmemyet = bestmember
        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)

    def pop_print(self):
        for i in range(self.popsize):
            print(self.pop[i], self.fits[i])
        return

# 若單獨存在則需導入 GA 所有方法
#import GA
#from GA import *
import numpy as np

def square(x):
    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)
    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)
    term3 = term1+term2
    return term3

# 最大化體積題目
def volume(x):
    surface = 80.0
    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))
    volume = x[0]*x[1]*z
    return volume


def miniex1(x):
    '''Minimizing Beale's function (optimal value f(3, 0.5) = 0):
    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    term1 = 1.5 - x[0] + x[0]*x[1]
    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]
    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]
    return term1*term1 + term2*term2 + term3*term3

def miniex2(x):
    '''Schaffer function #2. Minimium at (0,0), equal to 0
    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    return 0.5 + (math.pow(math.sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/math.pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)

#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化
ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
#ga=GA(miniex1, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
ga.setbounds(np.zeros(10), 10*np.ones(10))
#ga.setbounds(-10*np.ones(10), 10*np.ones(10))
#ga.pop_init()
print(ga.run())</pre>
<p></p><h3>隨機與機器學習</h3>
<h4><a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97">隨機森林</a></h4><h2>調查表單</h2>
<p>現成工具</p>
<p style="padding-left: 30px;">Ｇoogle Form 與 Sheet - 學習如何使用</p>
<p style="padding-left: 30px;">如何取出 Sheet 資料, 加值再利用或進行其他處理？</p>
<p>能否自行建置調查表單, 該如何進行? 不同方法, 各有何優缺點?</p>
<p style="padding-left: 30px;">網際表單?</p>
<p style="padding-left: 30px;"></p><h2>學習功課表</h2>
<p>既有工具</p>
<p style="padding-left: 30px;">學校所提供的功課表？</p>
<p style="padding-left: 30px;">利用 Google Calendar 建立自己的行事曆</p>
<p style="padding-left: 30px;">如何針對既有工具所提供的資料再變化 (臨時調課) 或利用 (找出多人可用的共同時段) - Google Calendar 安排會議的衝突檢查</p>
<p>Google Calendar API</p>
<p style="padding-left: 30px;">活動排程 (Scheduling)</p>
<p>自己從學校主機撈出與課程相關的歷史資料, 建立統計數據表, 提供之後的選課參考</p><h2>解微積分</h2>
<p>計算機程式協助解微積分問題  - 利用圖表協助了解問題</p>
<p>計算機程式解數學問題 - 利用圖表了解問題與解題意義</p>
<p><a href="https://www.math.wisc.edu/~angenent/Free-Lecture-Notes/">https://www.math.wisc.edu/~angenent/Free-Lecture-Notes/</a></p>
<p><a href="https://blog.gtwang.org/useful-tools/sympy-python-library-for-symbolic-mathematics/3/">https://blog.gtwang.org/useful-tools/sympy-python-library-for-symbolic-mathematics/3/</a></p>
<p><a href="https://betterexplained.com/articles/a-gentle-introduction-to-learning-calculus/">https://betterexplained.com/articles/a-gentle-introduction-to-learning-calculus/</a></p>
<p><a href="https://towardsdatascience.com/taking-derivatives-in-python-d6229ba72c64">https://towardsdatascience.com/taking-derivatives-in-python-d6229ba72c64</a></p>
<p><a href="https://in.pycon.org/cfp/workshops-2019/proposals/learning-calculus-with-python~av3gb/">https://in.pycon.org/cfp/workshops-2019/proposals/learning-calculus-with-python~av3gb/</a></p>
<p><a href="/downloads/first_semester_calculus.pdf">first semester calculus.pdf</a></p>
<p><a href="/downloads/second_semester_calculus.pdf">second semester calculus.pdf</a></p>
<p><a href="/downloads/programming_and_mathematical_thinking_python.pdf">programming_and_mathematical_thinking_python.pdf</a></p>
<p><a href="/downloads/computational_physics_python.pdf">computational_physics_python.pdf</a></p><h2>活動管理</h2>
<p>寄送活動通知 - 利用 Gmail API 收發信件</p>
<p style="padding-left: 30px;"><a href="https://blog.mailtrap.io/send-emails-with-gmail-api/">https://blog.mailtrap.io/send-emails-with-gmail-api/</a> </p>
<p>活動照片彙整 - 現存工具與自建工具</p>
<p style="padding-left: 30px;">Google + Domain API 與 Oauth2 登入管理系統</p>
<p style="padding-left: 30px;">將活動相關的檔案與照片, 透過 Google Drive API 直接上傳至 Google Drive</p>
<p>活動報到與座位安排</p><h3>GDrive API</h3>
<p><a href="https://developers.google.com/drive/api/v3/enable-drive-api">Enable Google Drive API</a></p>
<p>Reference: <a href="https://github.com/chingjunetao/medium-article/blob/master/google-drive-with-python/google-drive-with-python.py">https://github.com/chingjunetao/medium-article/blob/master/google-drive-with-python/google-drive-with-python.py</a></p>
<p>需要設定 Google Drive API credential 並取得 client_secrets.json</p>
<p>利用</p>
<p style="padding-left: 30px;">pip install pydrive</p>
<p>安裝所需模組, 以下程式將會至 client_secrets.json 所對應帳號下的 Google Drive, 列出所有目錄與檔案, 並將 file_to_upload.pdf 上傳至 Google Drive 中的 uploaded 目錄.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive

gauth = GoogleAuth()
gauth.LocalWebserverAuth() # client_secrets.json need to be in the same directory as the script
drive = GoogleDrive(gauth)


# View all folders and file in your Google Drive
fileList = drive.ListFile({'q': "'root' in parents and trashed=false"}).GetList()
for file in fileList:
  print('Title: %s, ID: %s' % (file['title'], file['id']))
  # Get the folder ID that you want
  if(file['title'] == "uploaded"):
      fileID = file['id']

file1 = drive.CreateFile({"mimeType": "application/pdf", "parents": [{"kind": "drive#fileLink", "id": fileID}]})
file1.SetContentFile("file_to_upload.pdf")
file1.Upload() # Upload the file.
print('Created file %s with mimeType %s' % (file1['title'], file1['mimeType']))   </pre>
<p>For example, you might want to integrate your existing website with Drive API. In that case, you can customize authentication flow as follwing:<br/><br/>1. Get authentication Url from GetAuthUrl().<br/>2. Ask users to visit the authentication Url and grant access to your application. Retrieve authentication code manually by user or automatically by building your own oauth2callback.<br/>3. Call Auth(code) with the authentication code you retrieved from step 2.<br/><br/>Your settings.yaml will work for your customized authentication flow, too.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from pydrive.auth import GoogleAuth

gauth = GoogleAuth()
auth_url = gauth.GetAuthUrl() # Create authentication url user needs to visit
code = AskUserToVisitLinkAndGiveCode(auth_url) # Your customized authentication flow
gauth.Auth(code) # Authorize and build service from the code</pre>
<p><br/><br/></p><h1>網際內容管理</h1>
<p>Leo Editor: <a href="https://leoeditor.com/">https://leoeditor.com/</a></p>
<p>Leo Editor 簡介: <a href="https://kaleguy.github.io/leovue/#dashboard">https://kaleguy.github.io/leovue/#dashboard</a></p><h2>網際 PDF 檔案管理</h2>
<p><a href="http://mde.tw/wcm2020/content/Project.html">wcm2020 pypdf page</a></p><h2>網際圖檔管理</h2>
<p>圖檔管理</p>
<p>影像辨識</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=1WHaL0ye8_cGEl5kuLotLh3jBRwT-Hx9i">Learn Computer Vision using OpenCV.pdf </a>(登入 @gm 後下載)</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=14BFbDUx563oGOBlkjTOv6Qme2FgUnWD8">Practicle OpenCV.pdf </a>(登入 @gm 後下載)</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=1htX5woOugkk4Qjl2_711BrjKBziDwEjD">Pro Processing for Images and Computer Vision with OpenCV.pdf</a> (登入 @gm 後下載)</p>
<h2>線上會議</h2>
<p><a href="https://github.com/jitsi/jitsi-meet">https://github.com/jitsi/jitsi-meet</a> </p>
<p><a href="https://github.com/jitsi/docker-jitsi-meet">https://github.com/jitsi/docker-jitsi-meet</a> </p>
<p></p><h1>電腦輔助設計與實習</h1>
<h2>產品設計繪圖</h2>
<p><a href="http://solvespace.com">Solvespace</a></p>
<p><a href="https://www.onshape.com/">OnShape</a></p>
<p><a href="https://www.freecadweb.org/">FreeCAD</a></p>
<p>SolidWorks</p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cad2019/content/Solidworks.html">cad2019 Solidworks page</a></p>
<p>NX</p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cad2019/content/NX.html">cad2019 下載 NX 套件</a></p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cad2019/content/NX12%20%E7%A8%8B%E5%BC%8F.html">cad2019 NX12 page</a></p>
<p style="padding-left: 30px;"><a href="/downloads/NX-12-for-Engineering-Design.pdf">NX12 for engineering design.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/nxopen_getting_started_v12.pdf">nxopen_getting_started_v12.pdf</a></p>
<p style="padding-left: 30px;"><a href="http://nxjournaling.com/">http://nxjournaling.com/</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Setup_Eclipse_for_NXOpenPythonScripting.pdf">Setup_Eclipse_for_NXOpenPythonScripting.pdf</a></p>
<p style="padding-left: 30px;">run_journal 指令可以直接執行外部的 NXOpen Python Journal 程式</p>
<p>AutoDesk Inventor</p>
<p>參考資料:</p>
<p style="padding-left: 30px;"><a href="http://www.josh-ua.co/blog/2019/2/13/solidworks-vs-siemens-nx-vs-onshape">http://www.josh-ua.co/blog/2019/2/13/solidworks-vs-siemens-nx-vs-onshape</a></p><h2>產品設計分析</h2>
<h4>Digital Products:</h4>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=1mQm55d7Z03wCtBXX-rFNlfgVe1xIcIFJ">Computational Intelligence Techniques for New Product Design.pdf</a> (登入 @gm 後下載)</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=11lPfZ4VTGSKPGYSUI17WdyqiRqlArLYb">Digital Products.pdf</a> (登入 @gm 後下載)</p>
<h4>Computer aided engineering:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/Range-Software/range3">https://github.com/Range-Software/range3</a> </p><h2>機電資整合控制</h2>
<h4>Mechatronic System Design</h4>
<p>Login to your gm email account and download <a href="https://drive.google.com/file/d/1KRb8vX_LB_3hkLwK1z1LOP8wl_StIZOR/view?usp=sharing">MSModelingAndTFApproaches.pdf</a>.</p>
<p style="padding-left: 30px;"><span>(Can we build online tools to facilitate these processes?)</span></p>
<p style="padding-left: 30px;">Mechatronic Systems</p>
<p style="padding-left: 30px;">Mathematical Modeling</p>
<p style="padding-left: 30px;">Transfer Function Approaches</p>
<p>Login to your gm email account and download <a href="https://drive.google.com/file/d/1y0QH6vI8uMymK9JI35EShVFS40Q8uwwq/view?usp=sharing">MechatronicDesignCases.pdf</a>.</p>
<p style="padding-left: 30px;">DC Motor Velocity and Position Control</p>
<p style="padding-left: 30px;">Balancing Robot Control</p>
<p style="padding-left: 30px;">Magnetic Levitation System</p>
<h2>產品生命週期管理</h2>
<p><a href="https://github.com/odoo/odoo">https://github.com/odoo/odoo</a></p>
<p><a href="https://www.odoo.com/documentation/user/13.0/">https://www.odoo.com/documentation/user/13.0/</a></p>
<p><a href="https://drive.google.com/open?id=1tYCGdd6FvVQa9yiCKtOfCKqed23tmpF5">odoo-development-readthedocs-io-en-20200518.pdf</a> (for @gm users only)</p>
<p><a href="https://drive.google.com/drive/folders/12iAsQ9sN_I6iHQiulSZ3MQzyXYFU1BrJ">Download PLM ebooks</a> (for @gm users only)</p>
<p></p><h1>協同產品設計實習</h1>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Digital_twin">Digital Twin</a></p>
<p style="padding-left: 30px;"><a href="/get_page/%E5%8D%94%E5%90%8C%E7%94%A2%E5%93%81%E8%A8%AD%E8%A8%88%E5%AF%A6%E7%BF%92/A Digital Twin Approach to Improve MachineTools Lifecycle">2019 Twin Control.pdf</a> - A Digital Twin Approach to Improve MachineTools Lifecycle (for @gm users only)</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=12OB79G-XElbCiz2fZ6GyVBpoA1s74qTl">2015 Mac Protocol for Cyber-Physical Systems.pdf</a> (for @gm users only)</p>
<p style="padding-left: 30px;"><a href="https://colab.research.google.com/notebooks/intro.ipynb">https://colab.research.google.com/notebooks/intro.ipynb</a> </p>
<p>以未來科技家庭中的先進產品開發為例</p>
<p>可折疊與拼裝組合的各種用途桌椅</p>
<p>可折疊與方便居家儲藏與吊掛的家庭成員自行車</p>
<p>多功能居家隔音與空氣濾清門窗組</p>
<p>家庭遊樂設備, 機電整合多功能櫥櫃</p>
<p>集手足球, 撞球與彈珠台於一身的組合式遊樂中心</p>
<p>STEM 導向機電資整合式運動遊樂器</p>
<p style="padding-left: 30px;">智慧功能機器人</p>
<p style="padding-left: 30px;">能克服障礙物並爬樓梯的激動玩具車</p>
<p style="padding-left: 30px;">折疊省力多功能搬運推車</p>
<p style="padding-left: 30px;">推高自走玩具車</p>
<p style="padding-left: 30px;">自走式自動充電吸塵機器人</p>
<p>S — Science（科學）<br/>T — Technology（技術）<br/>E — Engineering（工程）<br/>M — Mathematics（數學）</p>
<p></p><h2>兩人一組產品開發</h2>
<p>兩人共同快速 (一週) 開發一組產品設計與實作 (分組自評與互評, 說明遭遇問題與解決方法)</p>
<p>報告與檢討 (一週)</p>
<h2>四人一組產品開發</h2>
<p>四人共同快速 (兩週) 開發一組產品設計與實作</p>
<p>報告與檢討 (一週)</p>
<h2>八人一組產品開發</h2>
<p>八人共同快速 (三週) 開發一組產品設計與實作</p>
<p>報告與檢討 (一週) 期中考週</p>
<h2>十六人一組產品開發</h2>
<p>十六人共同快速 (三週) 開發一組產品設計與實作</p>
<p>報告與檢討 (一週)</p>
<h2>三十二人一組產品開發</h2>
<p>三十二人共同快速 (四週) 開發一組產品設計與實作</p>
<p>報告與檢討 (一週) 期末考週</p>