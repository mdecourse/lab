<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mde.tw/lab 網誌 - Weblog</title><link href="https://mde.tw/lab/blog/" rel="alternate"></link><link href="https://mde.tw/lab/blog/feeds/weblog.atom.xml" rel="self"></link><id>https://mde.tw/lab/blog/</id><updated>2021-02-10T11:20:00+08:00</updated><entry><title>Pelican 與 Blogger 內容同步</title><link href="https://mde.tw/lab/blog/sync-pelican-and-blogger-content.html" rel="alternate"></link><published>2021-02-10T11:20:00+08:00</published><updated>2021-02-10T11:20:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-10:/lab/blog/sync-pelican-and-blogger-content.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;cmsimde&lt;/a&gt; 中的 Pelican blog 內容建議採用 config 目錄中的 pelican.leo 進行管理, 主要的資料管理架構採用 [Leo Editor] 中的 &lt;a href="https://leoeditor.com/directives.html#clean-path"&gt;@clean&lt;/a&gt; 標題指令, 能夠與內文指令 &lt;a href="https://leoeditor.com/directives.html#part-2-all-and-others"&gt;@others&lt;/a&gt; 配合, 利用階層式的文章管理, 區隔網誌摘要與各段內容.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;cmsimde&lt;/a&gt; 中的 Pelican blog 內容建議採用 config 目錄中的 pelican.leo 進行管理, 主要的資料管理架構採用 [Leo Editor] 中的 &lt;a href="https://leoeditor.com/directives.html#clean-path"&gt;@clean&lt;/a&gt; 標題指令, 能夠與內文指令 &lt;a href="https://leoeditor.com/directives.html#part-2-all-and-others"&gt;@others&lt;/a&gt; 配合, 利用階層式的文章管理, 區隔網誌摘要與各段內容.&lt;/p&gt;


&lt;h2&gt;Google Developer Console&lt;/h2&gt;
&lt;p&gt;為了能夠將 &lt;a href="https://blog.getpelican.com/"&gt;Pelican blog&lt;/a&gt; 在 [Leo Editor] 中的網誌文章推向 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;, 必須要從 &lt;a href="https://console.developers.google.com"&gt;Google developer console&lt;/a&gt; 取得
與 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 擷取權限對應的 secret json 檔案. 實際操作流程如下:&lt;/p&gt;
&lt;p&gt;進入 Library - &amp;gt; ENABLE APIS AND SERVICES -&amp;gt; 啟用 Blogger API v3&lt;/p&gt;
&lt;p&gt;設定 OAuth consent screen &lt;/p&gt;
&lt;p&gt;新增 Credentials -&amp;gt; Desktop-type Oauth 2.0 client -&amp;gt; Download JSON 即可取得 secret.json 檔案.&lt;/p&gt;
&lt;h2&gt;將 secrets.json 轉為 token.dat&lt;/h2&gt;
&lt;p&gt;轉換前必須確定系統已經安裝 google_auth_oauthlib&lt;/p&gt;
&lt;p&gt;pip install google_auth_oauthlib&lt;/p&gt;
&lt;p&gt;接著利用下列程式將 secrets.json 轉為 token.dat, 隨後使用者就可利用此一  token.dat 將 [Leo Editor] 中的網誌文章內容傳送到對應的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;下列程式在轉換過程會透過操作系統的內定瀏覽器讓使用者登入與 secrets.json 對應的帳號, 一旦通過認證就可以完成 secrets.json 轉為 token.dat 的流程.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# get secrets: https://console.developers.google.com
# https://developers.google.com/blogger/docs/3.0/using
# pip install google_auth_oauthlib
# under Mac command + b to execute
import pickle
import os
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

SCOPES = ['https://www.googleapis.com/auth/blogger', ]

# we check if the file tBo store the credentials exists
if not os.path.exists('./../../yen_gm_blogger_token.dat'):

    flow = InstalledAppFlow.from_client_secrets_file('./../../yen_gm_blogger_secrets.json', SCOPES)
    credentials = flow.run_local_server()

    with open('yen_gm_blogger_token.dat', 'wb') as credentials_dat:
        pickle.dump(credentials, credentials_dat)
else:
    with open('yen_gm_blogger_token.dat', 'rb') as credentials_dat:
        credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
g.es(service)
&lt;/pre&gt;

&lt;h2&gt;將 Pelican 文章轉往 Blogger&lt;/h2&gt;
&lt;p&gt;將 Pelican 文章轉投 Blogger 的過程包含新增與編輯, 新增的程式碼如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 KBlogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;p&gt;完成上述文章轉投至 Blogger 之後, &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 會傳回該文章的 post id, 而新增程式會將此 id 放在該筆 @clean 文章節點的最末端, 由於該  post id 節點只有標題而無內文, 因此即便內縮成為 @clean 的子節點, 也不會在文章中增加任何資料, 但若該網誌內容同步推向一個以上的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;, 則使用者需要將該 post if 內縮外, 還需要在此 post id 節點的上屬節點增加標註, 說明該 post id 所屬的網誌標題或代號.&lt;/p&gt;
&lt;p&gt;至於當該文章內容經過編修後, 使用者若希望將新內容推向遠端同步 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;, 則必須將原先新增的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; post id 移至該 @clean 文章的最末端, 以便讓程式可以更新與此 post id 對應的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 文章內容.&lt;/p&gt;
&lt;p&gt;可用於編輯 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 文章的程式碼如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 K Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>資料儲存的永續性</title><link href="https://mde.tw/lab/blog/data-sustainablity.html" rel="alternate"></link><published>2021-02-10T11:10:00+08:00</published><updated>2021-02-10T11:10:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-10:/lab/blog/data-sustainablity.html</id><summary type="html">&lt;p&gt;假如將時間倒轉 20 年, 看看當時的電腦程式課程在教些什麼? 大家是如何上課, 結果應該會讓現在這些初出茅廬, 剛剛成年的大一生非常驚訝. 是的, 當年並沒有人手一機, 上課是需要抄筆記的......&lt;/p&gt;
</summary><content type="html">&lt;p&gt;假如將時間倒轉 20 年, 看看當時的電腦程式課程在教些什麼? 大家是如何上課, 結果應該會讓現在這些初出茅廬, 剛剛成年的大一生非常驚訝. 是的, 當年並沒有人手一機, 上課是需要抄筆記的......&lt;/p&gt;


&lt;p&gt;而且當時全球科技界正度過所謂的千禧年之禍, 利用電腦程式產生中文字仍處於 Big-5 的陰影下, 倚天中文仍然到處可見, 即使處在所謂的數位科技前緣, 某些人手上已經有小而美的易利信手機, 口袋裡也放著一個由 HTC 打造的頗有重量 HP &lt;a href="https://en.wikipedia.org/wiki/Personal_digital_assistant"&gt;PDA&lt;/a&gt;, 但所謂數位資料的永續性, 距離仍然很遠, 因此二十年多年後, 當時能留下與上課有關的數位資料非常有限.&lt;/p&gt;
&lt;p&gt;之後就在 Google 逐漸成熟, 而 Facebook 騰空出世 7 年後的 2011年, Red Hat 推出可以免費使用的 &lt;a href="https://en.wikipedia.org/wiki/Heroku"&gt;Openshift&lt;/a&gt;, 不僅能夠伺服 PHP 與 Python, 還可免費存放各種數位資料, 當時以為資料終於可以永續存放的假象, 到 2016 年夢想逐漸破滅, 還好 2016 年之後有 Github 接手, Heroku 也很意外地從 2007 年活到現在, 目前, Github 與 Heroku (只能儲存 500 MB), 加上 Gitlab 的同步資料備份與 Google Drive 上的大檔案存放, 全球網友前撲後繼用隱私換取數位資料免費存放的所謂永續性,  似乎終於有了眉目.&lt;/p&gt;
&lt;p&gt;目前教育版的 Google Drive 仍不限容量, 但也許未來的某一天這樣的所謂永續仍會畫上休止符, 大家仍必須有所因應.&lt;/p&gt;
&lt;h2&gt;資料存至 Google Drive&lt;/h2&gt;
&lt;p&gt;從 &lt;a href="https://github.com/mdecourse/cd2020pj1/blob/master/myflaskapp.py"&gt;https://github.com/mdecourse/cd2020pj1/blob/master/myflaskapp.py&lt;/a&gt; 可以看出如何利用 Google Drive API, 在網際環境中將數位檔案送到特定伺服器之外, 還能利用 AJAX 存備份至特定 Google Drive 目錄.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@app.route('/saveToDB' , methods=['POST'])
@login_required
def saveToDB():

    """axuploader.js 將檔案上傳後, 將上傳檔案名稱數列, 以 post 回傳到 Flask server.

    截至這裡, 表示檔案已經從 client 上傳至 server, 可以再設法通過認證, 將 server 上的檔案上傳到對應的 Google Drive, 並且在上傳後的 GDrive 目錄, 設定特定擷取權限 (例如: 只允許 @gm 用戶下載.
    以下則可將 server 上傳後的擷取目錄與 GDrive 各檔案 ID 存入資料庫, 而檔案擷取則分為 server 擷取與 GDrive 擷取等兩種 url 連結設定
    """

    if request.method == "POST":
        files = request.form["files"]
        # split files string
        files = files.split(",")
        # files 為上傳檔案名稱所組成的數列
        for i in range(len(files)):
            # 逐一將已經存在 server downloads 目錄的檔案, 上傳到 GDrive uploaded 目錄
            fileName = files[i]
            fileLocation = _curdir + "/downloads/" + fileName
            mimeType = mimetypes.MimeTypes().guess_type(fileLocation)[0]
            # for GDrive v2
            #gdriveID = uploadToGdrive(fileName, mimeType)
            # for GDrive v3
            gdriveID = uploadToGdrive3(fileName, mimeType)
            fileSize = str(round(os.path.getsize(fileLocation)/(1024*1024.0), 2)) + " MB"
            date = datetime.datetime.now().strftime("%b %d, %Y - %H:%M:%S")
            user = session.get("user")
            print(user + "|" + str(fileSize) + "|" + str(mimeType) + "|"  + gdriveID)
            # 逐一將上傳檔案名稱存入資料庫, 同時存入mimeType, fileSize 與 gdriveID
            # 資料庫欄位
            #g.db.execute('insert into grouping (user , date, fileName, mimeType, fileSize, memo) values (?, ?, ?, ?, ?, ?)',(user, date, fileName, mimeType, fileSize, "memo"))
            #g.db.commit()
            #flash('已經新增一筆 upload 資料!')
    return "Uploaded fileName and gdriveID save to database"
def uploadToGdrive(fileName, mimeType):
    gauth = GoogleAuth()
    # 必須使用 desktop 版本的 client_secrets.json
    gauth.LoadClientConfigFile("./../gdrive_desktop_client_secrets.json")
    drive = GoogleDrive(gauth)

    '''
    # View all folders and file in your Google Drive
    fileList = drive.ListFile({'q': "'root' in parents and trashed=false"}).GetList()
    for file in fileList:
      print('Title: %s, ID: %s' % (file['title'], file['id']))
      # Get the folder ID that you want
      # 檔案會上傳到根目錄下的 uploaded  目錄中
      if(file['title'] == "uploaded"):
          fileID = file['id']
    '''
    # GDrive 上 uploaded 目錄的 fileID
    with open("./../gdrive_uploaded_id.txt", 'r') as content_file:
        fileID = content_file.read()

    # 由上述目錄外的檔案讀取 uploaded 目錄對應 ID
    #fileID = "your_folder_file_ID"
    # 上傳檔案名稱為輸入變數
    #fileName = "DemoFile.pdf"
    filePath = _curdir + "/downloads/"
    # parents 為所在 folder, 亦即 uploaded 目錄, fileID 為 uploaded 目錄的 ID
    file1 = drive.CreateFile({"mimeType": mimeType, "parents": [{"kind": "drive#fileLink", "id": fileID}], "title":  fileName})
    file1.SetContentFile(filePath + fileName)
    file1.Upload() # Upload the file.
    # 傳回與上傳檔案對應的 GDrive ID, 將會存入資料庫 gdiveID 欄位
    return file1['id']
    #print('Created file %s with mimeType %s' % (file1['title'], file1['mimeType']))   
    #print("upload fileID:" + str(file1['id']))
    # 以下為下載檔案測試
    # file2 = drive.CreateFile({'id': file1['id']})
    #file2.GetContentFile('./test/downloaded_ModernC.pdf') # Download file as 'downloaded_ModernC.pdf under directory test'.

    '''
    file1.Trash()  # Move file to trash.
    file1.UnTrash()  # Move file out of trash.
    file1.Delete()  # Permanently delete the file.
    '''
def uploadToGdrive3(fileName, mimeType):
    # get upload folder id
    # GDrive 上 uploaded 目錄的 fileID
    with open("./../gdrive_uploaded_id.txt", 'r') as content_file:
        folderID = content_file.read()

    creds = None
    with open('./../gdrive_write_token.pickle', 'rb') as token:
        creds = pickle.load(token)
    # 讀進既有的 token, 建立 service
    driveService = build('drive', 'v3', credentials=creds)

    metadata = {
        'name': fileName,
        'mimeType': mimeType,
        # 注意: 必須提供數列格式資料
        'parents': [folderID]
        }

    filePath = _curdir + "/downloads/" + fileName
    media = MediaFileUpload(filePath,
                                            mimetype=mimeType,
                                            chunksize=1024*1024,
                                            resumable=True
                                            )

    gdFile = driveService.files().create(
        body=metadata,
        media_body=media,
        fields='id'
    ).execute()
    fileID = gdFile.get("id")

    return fileID
&lt;/pre&gt;

&lt;p&gt;上述程式利用較新的 GDrive V3 上傳資料之前, 可攜系統必須安裝 google-api-python-client:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
# for uploadToGDrive3
# pip install google-api-python-client
# https://github.com/googleapis/google-api-python-client
import pickle
from googleapiclient.discovery import build
from apiclient.http import MediaFileUpload
&lt;/pre&gt;

&lt;h2&gt;Github, Gitlab 與 Fossil SCM&lt;/h2&gt;
&lt;p&gt;針對 Github 與 Gitlab 的操作, 可以參考 &lt;a href="https://git-scm.com/book/en/v2"&gt;https://git-scm.com/book/en/v2&lt;/a&gt;, 但是 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的參考資料則相對較少, 以下將針對 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的應用稍加說明, 為了因應未來上述各種網際免費數位儲存資料系統的更迭, 在近端配置 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;, 並用 &lt;a href="https://en.wikipedia.org/wiki/Blu-ray_Disc_recordable"&gt;BD-R or BD-RE&lt;/a&gt; (25GB) 進行備份, 也是一個不錯的資料永續儲存方案.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的使用非常簡單, 只要配合操作系統從 &lt;a href="https://fossil-scm.org/home/uv/download.html"&gt;https://fossil-scm.org/home/uv/download.html&lt;/a&gt; 下載相應版本, 並讓系統可以執行 fossil.exe (以 Windows 10 為例) 即可, 唯一要注意的是若操作過程牽涉兩個不同操作系統, 必須透過 fossil version 查驗雙方的版本是否相同.&lt;/p&gt;
&lt;p&gt;有關 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的先前參考資料, 可參閱 &lt;a href="http://mde.tw/2017springcd/blog/intro-fossil-scm.html"&gt;Fossil SCM 簡介&lt;/a&gt;.&lt;/p&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>2021 開春</title><link href="https://mde.tw/lab/blog/starting-2021.html" rel="alternate"></link><published>2021-02-10T11:00:00+08:00</published><updated>2021-02-10T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-10:/lab/blog/starting-2021.html</id><summary type="html">&lt;p&gt;2021 年伊始, 機器學習的程式從原先簡單的演化, 進展到能夠有效控制具有亂數的決策系統, 科技的發展讓人類的工作更加兩極化, 一方可持續開發指使電腦軟硬體從事工作, 而另一方則幾乎必須完全按照電腦軟硬體的指示與命令行事.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;2021 年伊始, 機器學習的程式從原先簡單的演化, 進展到能夠有效控制具有亂數的決策系統, 科技的發展讓人類的工作更加兩極化, 一方可持續開發指使電腦軟硬體從事工作, 而另一方則幾乎必須完全按照電腦軟硬體的指示與命令行事.&lt;/p&gt;


&lt;p&gt;這樣的發展似乎已經沒了退路.&lt;/p&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>同步 Pelican 與 Blogger 網誌內容</title><link href="https://mde.tw/lab/blog/sync-pelican-and-blogger-content.html" rel="alternate"></link><published>2020-05-18T11:00:00+08:00</published><updated>2020-05-18T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-18:/lab/blog/sync-pelican-and-blogger-content.html</id><summary type="html">&lt;p&gt;在先前的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 架構中, 曾經設法讓 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt;, 相同的概念, 也可以在 &lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中, 讓 Pelican 的網誌文章與 Google Blogger 保持同步.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;在先前的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 架構中, 曾經設法讓 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt;, 相同的概念, 也可以在 &lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中, 讓 Pelican 的網誌文章與 Google Blogger 保持同步.&lt;/p&gt;


&lt;h2&gt;按鈕與節點標題&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中可以設置按鈕執行 Python 程式, 其中搭配節點的標題內容存取, 可以應用在 Pelican 與 Blogger 的網誌內容同步.&lt;/p&gt;
&lt;p&gt;由於目前使用的 Pelican, 在 markdown 目錄中編寫 .md 檔案, 然後再設法以 Pelican 指令與設定檔, 將所有的 .md 檔案轉為 blog 目錄中的網誌內容. 其中, 若能將個別的 .md 檔案先轉為 html 後, 再利用 Google Blogger API 的 Python 程式將各網誌 html 檔案送至對應帳號下的 Blogger 網誌系統, 將可以將一份內容分別同步到 Pelican 與 Blogger.&lt;/p&gt;
&lt;h2&gt;新增 Blogger 文章&lt;/h2&gt;
&lt;p&gt;add_to_blogger 按鈕程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    # 但是只換第一個
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;', 1)
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    blog_id = blogs["items"][0]["id"]
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;h2&gt;編輯 Blogger 文章&lt;/h2&gt;
&lt;p&gt;edit_to_blogger 按鈕程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    blog_id = blogs["items"][0]["id"]
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;h2&gt;從 Blogger 取回內容&lt;/h2&gt;
&lt;p&gt;在 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt; 中, 可以從 Wordpress 取回網誌內容, 然後新增到 Pelican, 在此因為網誌文章的建立以 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 倉儲中的 Pelican 網誌為主, Blogger 只是附屬備份網誌, 所以就不再從新增的 Google Blogger 取回網誌文章.&lt;/p&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developers.google.com/blogger"&gt;https://developers.google.com/blogger&lt;/a&gt;&lt;/p&gt;</content><category term="Weblog"></category><category term="Pelican"></category><category term="Blogger"></category></entry></feed>