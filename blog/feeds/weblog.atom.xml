<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mde.tw/lab 網誌 - Weblog</title><link href="https://mde.tw/lab/blog/" rel="alternate"></link><link href="https://mde.tw/lab/blog/feeds/weblog.atom.xml" rel="self"></link><id>https://mde.tw/lab/blog/</id><updated>2021-02-11T11:10:00+08:00</updated><entry><title>Fossil SCM 使用案例</title><link href="https://mde.tw/lab/blog/fossil-scm-use-case.html" rel="alternate"></link><published>2021-02-11T11:10:00+08:00</published><updated>2021-02-11T11:10:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-11:/lab/blog/fossil-scm-use-case.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的 &lt;a href="https://fossil-scm.org/home/doc/trunk/www/embeddeddoc.wiki"&gt;https://fossil-scm.org/home/doc/trunk/www/embeddeddoc.wiki&lt;/a&gt; 可以與靜態網頁結合應用, 唯一必須注意的是 &lt;a href="https://fossil-scm.org/home/doc/trunk/www/defcsp.md"&gt;https://fossil-scm.org/home/doc/trunk/www/defcsp.md&lt;/a&gt; 議題.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的 &lt;a href="https://fossil-scm.org/home/doc/trunk/www/embeddeddoc.wiki"&gt;https://fossil-scm.org/home/doc/trunk/www/embeddeddoc.wiki&lt;/a&gt; 可以與靜態網頁結合應用, 唯一必須注意的是 &lt;a href="https://fossil-scm.org/home/doc/trunk/www/defcsp.md"&gt;https://fossil-scm.org/home/doc/trunk/www/defcsp.md&lt;/a&gt; 議題.&lt;/p&gt;


&lt;h2&gt;&lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; documentation 功能&lt;/h2&gt;
&lt;p&gt;先前已經建議 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的倉儲可以放在 /home/user/repository/ 目錄中, 以這裡的範例分別為 /home/user/repository/cd2021.fossil 與 /home/user/repository/lab.fossil, 而這兩個倉儲的展開內容分別位於 /home/user/repository/wd/cd2021 與 /home/user/repository/wd/lab 等目錄.&lt;/p&gt;
&lt;p&gt;透過 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的 &lt;a href="https://fossil-scm.org/home/help/http"&gt;https://fossil-scm.org/home/help/http&lt;/a&gt; 指令與 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt; 的結合運用可以伺服為:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://fossil.kmol.info/cd2021/doc/trunk/index.html"&gt;http://fossil.kmol.info/cd2021/doc/trunk/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;與&lt;/p&gt;
&lt;p&gt;&lt;a href="http://fossil.kmol.info/lab/doc/trunk/index.html"&gt;http://fossil.kmol.info/lab/doc/trunk/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而這兩個 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲的靜態網頁與 &lt;a href="https://mde.tw/cd2021"&gt;https://mde.tw/cd2021&lt;/a&gt; 及 &lt;a href="https://mde.tw/lab"&gt;https://mde.tw/lab&lt;/a&gt; 內容保持同步. 且 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的靜態網頁可以直接將網址中的 trunk (表示為最新版本) 換為 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲內容的對應版本號, 就可以直接顯示各舊版本的靜態網頁內容, 這一個功能至今連 &lt;a href="https://pages.github.com/"&gt;https://pages.github.com/&lt;/a&gt; 或 &lt;a href="https://docs.gitlab.com/ee/user/project/pages/"&gt;https://docs.gitlab.com/ee/user/project/pages/&lt;/a&gt; 都還無法直接在網際介面中完成.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; open, add 與 commit&lt;/h2&gt;
&lt;p&gt;之前已經提過, 建立 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲的方法:&lt;/p&gt;
&lt;p&gt;fossil init cd2021.fossil&lt;/p&gt;
&lt;p&gt;而這個指令若直接在 /home/user/repository/ 目錄中執行, 則可以建立 cd2021.fossil 空倉儲.&lt;/p&gt;
&lt;p&gt;這裡的規劃是將這些倉儲以 fossil open 指令, 在 /home/user/repository/wd 目錄中設法展開內容, 而且以倉儲的名稱作為展開後的目錄, 並將展開內容置入.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;/home/user/repository/cd2021.fossil 可以透過:&lt;/p&gt;
&lt;p&gt;在 /home/user/repository/wd/cd2021/ 目錄中執行 fossil open ./../../cd2021.fossil 而將內容展開.&lt;/p&gt;
&lt;p&gt;而 /home/user/repository/lab.fossil 則在 /home/user/repository/wd/lab 目錄中展開內容.&lt;/p&gt;
&lt;p&gt;若從 Github 以:&lt;/p&gt;
&lt;p&gt;git clone --recurse-submodules https://github.com/mdecourse/cd2021.git &lt;/p&gt;
&lt;p&gt;將 cd2021 倉儲內容取下, 而且放入 /home/user/repository/wd/cd2021/ 目錄中.&lt;/p&gt;
&lt;p&gt;使用者就可以在 /home/user/repository/wd/cd2021/ 目錄中執行:&lt;/p&gt;
&lt;p&gt;fossil add .&lt;/p&gt;
&lt;p&gt;fossil commit -m "add cd2021 git repository content"&lt;/p&gt;
&lt;p&gt;則 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 會將 /home/user/repository/wd/cd2021/ 已經改版的內容壓進 /home/user/repository/cd2021.fossil 倉儲中, 並透過 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; http 將靜態網頁以 project documentation 功能伺服到 &lt;a href="https://fossil.kmol.info/cd2021/doc/trunk/index.html"&gt;https://fossil.kmol.info/cd2021/doc/trunk/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;而根據網站內容, 必須將 https://fonts.googleapis.com 放入 settings -&amp;gt; default-csp 設定欄位中, &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; doc 網站才會允許 default-csp 設定的網站進行跨網站擷取所需的資料.&lt;/p&gt;
&lt;p&gt;採取相同的操作步驟, 就可以將 &lt;a href="https://mde.tw/lab"&gt;https://mde.tw/lab&lt;/a&gt; 網站資料同步至 &amp;lt;&lt;a href="http://fossil.kmol.info/lab/doc/trunk/index.html"&gt;http://fossil.kmol.info/lab/doc/trunk/index.html&lt;/a&gt;&lt;/p&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>Fossil SCM on Ubuntu</title><link href="https://mde.tw/lab/blog/fossil-scm-on-ubuntu.html" rel="alternate"></link><published>2021-02-11T11:00:00+08:00</published><updated>2021-02-11T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-11:/lab/blog/fossil-scm-on-ubuntu.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 是一套完整的&lt;a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"&gt;軟體組態管理系統&lt;/a&gt; (&lt;a href="https://en.wikipedia.org/wiki/Software_configuration_management"&gt;Software Configuration Management&lt;/a&gt;), 以 ANSI C 編寫, 其中利用 &lt;a href="https://en.wikipedia.org/wiki/Tcl"&gt;TCL&lt;/a&gt; 作為 Scripting 語言. 接下來將要說明如何在 Ubuntu 20.04 中安裝與配置 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 是一套完整的&lt;a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"&gt;軟體組態管理系統&lt;/a&gt; (&lt;a href="https://en.wikipedia.org/wiki/Software_configuration_management"&gt;Software Configuration Management&lt;/a&gt;), 以 ANSI C 編寫, 其中利用 &lt;a href="https://en.wikipedia.org/wiki/Tcl"&gt;TCL&lt;/a&gt; 作為 Scripting 語言. 接下來將要說明如何在 Ubuntu 20.04 中安裝與配置 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;.&lt;/p&gt;


&lt;p&gt;這裡所要介紹的 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 為 &lt;a href="http://fossil.kmol.info"&gt;http://fossil.kmol.info&lt;/a&gt; (只配置 IPv6 網路協定), http 網際伺服器前端採用 &lt;a href="https://nginx.org/"&gt;nginx&lt;/a&gt;, https 代理伺服器採用 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt;, 主要伺服的 &lt;a href="https://en.wikipedia.org/wiki/Software_configuration_management"&gt;Software Configuration Management&lt;/a&gt; 套件則為 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;安裝 &lt;a href="https://nginx.org/"&gt;nginx&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在 Ubuntu 20.04 中安裝 &lt;a href="https://nginx.org/"&gt;nginx&lt;/a&gt; 非常簡單, 只要執行 sudo apt install nginx 即可.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nginx.org/"&gt;nginx&lt;/a&gt; 的基本設定檔案位於 /etc/nginx/sites-available/default&lt;/p&gt;
&lt;p&gt;安裝 &lt;a href="https://nginx.org/"&gt;nginx&lt;/a&gt; 有兩個目的, 一方面回應 &lt;a href="http://fossil.kmol.info"&gt;http://fossil.kmol.info&lt;/a&gt;, 也就是 port 80 的 WWW 伺服器. 而另外一方面則是配合 &lt;a href="https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx"&gt;https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx&lt;/a&gt; 以手動模式取得 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt; https 伺服所需要的 fullchain.pem 與 privkey.prm 等兩個檔案.&lt;/p&gt;
&lt;h2&gt;安裝 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在 Ubuntu 20.04 安裝 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 也非常簡單, 只要執行 sudo apt install fossil 即可. 但是所安裝的版本可能不是最新版, 由於安裝的 fossil 執行檔案位於 /usr/bin/fossil, 假如希望與 Windows 10 64 位元操作系統中的 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 對應, 可以至 &lt;a href="https://fossil-scm.org/home/uv/download.html"&gt;https://fossil-scm.org/home/uv/download.html&lt;/a&gt; 下載 Linux 最新版本的 fossil, 然後以 sudo cp fossil /urs/bin/ 即可. 若要查驗 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的版本, 可以使用 fossil version 指令.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 整個系統就只有一個 fossil 執行檔案, 而倉儲檔案則只全部壓縮在一個 &lt;a href="https://www.sqlite.org"&gt;SQLite&lt;/a&gt; 資料庫檔案中.&lt;/p&gt;
&lt;p&gt;接下來為了配置一套可以伺服多個 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲的 Ubuntu 20.04 系統, 在 /home/user/ 目錄下建立 repository 目錄, 之後的所有要從遠端擷取的 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲都可以放在此一用戶目錄下. 至於要在此目錄下建立一個內定的 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲, 可以進入 /home/user/repository 目錄後 (這裡的 user 為 Ubuntu 20.04 下的用戶帳號名稱), 以 fossil init cd2021.fossil 建立一個 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲, 執行完後系統就會直接在命令列中顯示用來管理此一倉儲的用戶 (會使用建立倉儲的帳號, 也就是 user) 登入管理的密碼.&lt;/p&gt;
&lt;p&gt;使用者可以選擇將此一與 user 對應的管理密碼記起來, 或者之後再使用 sqlite3 指令進入 cd2021.fossil 查詢.&lt;/p&gt;
&lt;p&gt;假如使用者需要在 Ubuntu 環境中直接對 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 倉儲改版, 則建議在 /home/user/repository 目錄中再建立一個 wd 目錄 (為 working directory 的縮寫), 之後可以將位於 /home/user/repository 目錄中的各個 .fossil 內容, 在 /home/user/repository/wd 目錄中展開, 若以 /home/user/repository/cd2021.fossil 為例, 展開後將位於 /home/user/repository/wd/cd2021.&lt;/p&gt;
&lt;h2&gt;安裝 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;安裝 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt; 也很簡單, 只要執行 sudo apt install stunnel4 即可, 安裝後若要隨系統開機啟動, 則需要 sudo vi /etc/default/stunnel4, 並在檔案中加入 ENABLED=1 後存檔.&lt;/p&gt;
&lt;p&gt;另外, 還需要 sudo vi /etc/environment, 並在檔案中加入 HTTPS=on 後存檔.&lt;/p&gt;
&lt;p&gt;接下來為了由 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt; 代理 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的 https 伺服, 必須加入 /etc/stunnel/stunnel.conf&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
[https]
accept = 140.130.your_ipv4.ip:443
accept = 2001:288:6004:your:ipv6::ip:443
cert = /etc/stunnel/fullchain.pem
key = /etc/stunnel/privkey.pem
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021
&lt;/pre&gt;

&lt;p&gt;上述的 fullchain.pem 與 privkey.pem 由於尚未配置 &lt;a href="https://certbot.eff.org/"&gt;certbot&lt;/a&gt;, 必須要取得合法的數位簽章檔案後, 再利用:&lt;/p&gt;
&lt;p&gt;sudo systemctl start stunnel4.service &lt;/p&gt;
&lt;p&gt;啟動 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;sudo systemctl stop stunnel4.service&lt;/p&gt;
&lt;p&gt;關閉 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt;, 或利用:&lt;/p&gt;
&lt;p&gt;sudo systemctl restart stunnel4.service&lt;/p&gt;
&lt;p&gt;重新啟動 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;擷取 fullchain.pem 與 privkey.pem&lt;/h2&gt;
&lt;p&gt;這個步驟主要按照 &lt;a href="https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx"&gt;https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx&lt;/a&gt; 中的指令操作, 由於 Ubuntu 20.04 已經內建 snap, 因此只要執行:&lt;/p&gt;
&lt;p&gt;sudo snap install core; sudo snap refresh core&lt;/p&gt;
&lt;p&gt;sudo snap install --classic certbot&lt;/p&gt;
&lt;p&gt;sudo ln -s /snap/bin/certbot /usr/bin/certbot&lt;/p&gt;
&lt;p&gt;sudo certbot certonly --nginx&lt;/p&gt;
&lt;p&gt;就可以在 /etc/letsencrypt/live/fossil.kmol.info/ 目錄中找到 fullchain.pem 與 privkey.pem 等兩個數位簽章檔案, 接著將此兩個檔案複製至 /etc/stunnel/ 目錄, 以便配合 /etc/stunnel/stunnel.conf 隨電腦開機啟動.&lt;/p&gt;
&lt;p&gt;因為 &lt;a href="https://certbot.eff.org/"&gt;certbot&lt;/a&gt; 的數位簽章每 90 天都要更新一次, 屆時若要手動更新可以先模擬執行:&lt;/p&gt;
&lt;p&gt;sudo certbot renew --dry-run&lt;/p&gt;
&lt;h2&gt;nginx http 跳轉 https&lt;/h2&gt;
&lt;p&gt;最後一個步驟是讓 &lt;a href="https://nginx.org/"&gt;nginx&lt;/a&gt; 所伺服的 &lt;a href="http://fossil.kmol.info"&gt;http://fossil.kmol.info&lt;/a&gt; 能夠自動跳轉到 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 與 &lt;a href="https://www.stunnel.org/"&gt;stunnel&lt;/a&gt; 結合的 &lt;a href="https://fossil.kmol.info"&gt;https://fossil.kmol.info&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改 /etc/nginx/sites-available/default 中的設定如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
server {
listen 80;
server_name fossil.kmol.info;
rewrite ^/(.*)$ https://fossil.kmol.info/$1 permanent;
}
&lt;/pre&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>Pelican 與 Blogger 內容同步2</title><link href="https://mde.tw/lab/blog/sync-pelican-and-blogger-content2.html" rel="alternate"></link><published>2021-02-10T11:20:00+08:00</published><updated>2021-02-10T11:20:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-10:/lab/blog/sync-pelican-and-blogger-content2.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;cmsimde&lt;/a&gt; 中的 Pelican blog 內容建議採用 config 目錄中的 pelican.leo 進行管理, 主要的資料管理架構採用 [Leo Editor] 中的 &lt;a href="https://leoeditor.com/directives.html#clean-path"&gt;@clean&lt;/a&gt; 標題指令, 能夠與內文指令 &lt;a href="https://leoeditor.com/directives.html#part-2-all-and-others"&gt;@others&lt;/a&gt; 配合, 利用階層式的文章管理, 區隔網誌摘要與各段內容.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;cmsimde&lt;/a&gt; 中的 Pelican blog 內容建議採用 config 目錄中的 pelican.leo 進行管理, 主要的資料管理架構採用 [Leo Editor] 中的 &lt;a href="https://leoeditor.com/directives.html#clean-path"&gt;@clean&lt;/a&gt; 標題指令, 能夠與內文指令 &lt;a href="https://leoeditor.com/directives.html#part-2-all-and-others"&gt;@others&lt;/a&gt; 配合, 利用階層式的文章管理, 區隔網誌摘要與各段內容.&lt;/p&gt;


&lt;h2&gt;Google Developer Console&lt;/h2&gt;
&lt;p&gt;為了能夠將 &lt;a href="https://blog.getpelican.com/"&gt;Pelican blog&lt;/a&gt; 在 [Leo Editor] 中的網誌文章推向 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;, 必須要從 &lt;a href="https://console.developers.google.com"&gt;Google developer console&lt;/a&gt; 取得
與 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 擷取權限對應的 secret json 檔案. 實際操作流程如下:&lt;/p&gt;
&lt;p&gt;進入 Library - &amp;gt; ENABLE APIS AND SERVICES -&amp;gt; 啟用 Blogger API v3&lt;/p&gt;
&lt;p&gt;設定 OAuth consent screen &lt;/p&gt;
&lt;p&gt;新增 Credentials -&amp;gt; Desktop-type Oauth 2.0 client -&amp;gt; Download JSON 即可取得 secret.json 檔案.&lt;/p&gt;
&lt;h2&gt;將 secrets.json 轉為 token.dat&lt;/h2&gt;
&lt;p&gt;轉換前必須確定系統已經安裝 google_auth_oauthlib&lt;/p&gt;
&lt;p&gt;pip install google_auth_oauthlib&lt;/p&gt;
&lt;p&gt;接著利用下列程式將 secrets.json 轉為 token.dat, 隨後使用者就可利用此一  token.dat 將 [Leo Editor] 中的網誌文章內容傳送到對應的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;下列程式在轉換過程會透過操作系統的內定瀏覽器讓使用者登入與 secrets.json 對應的帳號, 一旦通過認證就可以完成 secrets.json 轉為 token.dat 的流程.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# get secrets: https://console.developers.google.com
# https://developers.google.com/blogger/docs/3.0/using
# pip install google_auth_oauthlib
# under Mac command + b to execute
import pickle
import os
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

SCOPES = ['https://www.googleapis.com/auth/blogger', ]

# we check if the file tBo store the credentials exists
if not os.path.exists('./../../yen_gm_blogger_token.dat'):

    flow = InstalledAppFlow.from_client_secrets_file('./../../yen_gm_blogger_secrets.json', SCOPES)
    credentials = flow.run_local_server()

    with open('yen_gm_blogger_token.dat', 'wb') as credentials_dat:
        pickle.dump(credentials, credentials_dat)
else:
    with open('yen_gm_blogger_token.dat', 'rb') as credentials_dat:
        credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
g.es(service)
&lt;/pre&gt;

&lt;h2&gt;將 Pelican 文章轉往 Blogger&lt;/h2&gt;
&lt;p&gt;將 Pelican 文章轉投 Blogger 的過程包含新增與編輯, 新增的程式碼如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 KBlogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;p&gt;完成上述文章轉投至 Blogger 之後, &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 會傳回該文章的 post id, 而新增程式會將此 id 放在該筆 @clean 文章節點的最末端, 由於該  post id 節點只有標題而無內文, 因此即便內縮成為 @clean 的子節點, 也不會在文章中增加任何資料, 但若該網誌內容同步推向一個以上的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;, 則使用者需要將該 post if 內縮外, 還需要在此 post id 節點的上屬節點增加標註, 說明該 post id 所屬的網誌標題或代號.&lt;/p&gt;
&lt;p&gt;至於當該文章內容經過編修後, 使用者若希望將新內容推向遠端同步 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;, 則必須將原先新增的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; post id 移至該 @clean 文章的最末端, 以便讓程式可以更新與此 post id 對應的 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 文章內容.&lt;/p&gt;
&lt;p&gt;可用於編輯 &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt; 文章的程式碼如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
#from googleapiclient import sample_tools
import os
# 配合使用 credential token
import pickle
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request

os.environ['TZ'] = 'Asia/Taipei'
with open('./../../yen_gm_blogger_token.dat', 'rb') as credentials_dat:
    credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    #blog_id = blogs["items"][0]["id"]
    blog_id = "2403495118140401474"
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 K Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>資料儲存的永續性</title><link href="https://mde.tw/lab/blog/data-sustainablity.html" rel="alternate"></link><published>2021-02-10T11:10:00+08:00</published><updated>2021-02-10T11:10:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-10:/lab/blog/data-sustainablity.html</id><summary type="html">&lt;p&gt;假如將時間倒轉 20 年, 看看當時的電腦程式課程在教些什麼? 大家是如何上課, 結果應該會讓現在這些初出茅廬, 剛剛成年的大一生非常驚訝. 是的, 當年並沒有人手一機, 上課是需要抄筆記的......&lt;/p&gt;
</summary><content type="html">&lt;p&gt;假如將時間倒轉 20 年, 看看當時的電腦程式課程在教些什麼? 大家是如何上課, 結果應該會讓現在這些初出茅廬, 剛剛成年的大一生非常驚訝. 是的, 當年並沒有人手一機, 上課是需要抄筆記的......&lt;/p&gt;


&lt;p&gt;而且當時全球科技界正度過所謂的千禧年之禍, 利用電腦程式產生中文字仍處於 Big-5 的陰影下, 倚天中文仍然到處可見, 即使處在所謂的數位科技前緣, 某些人手上已經有小而美的易利信手機, 口袋裡也放著一個由 HTC 打造的頗有重量 HP &lt;a href="https://en.wikipedia.org/wiki/Personal_digital_assistant"&gt;PDA&lt;/a&gt;, 但所謂數位資料的永續性, 距離仍然很遠, 因此二十年多年後, 當時能留下與上課有關的數位資料非常有限.&lt;/p&gt;
&lt;p&gt;之後就在 Google 逐漸成熟, 而 Facebook 騰空出世 7 年後的 2011年, Red Hat 推出可以免費使用的 &lt;a href="https://en.wikipedia.org/wiki/Heroku"&gt;Openshift&lt;/a&gt;, 不僅能夠伺服 PHP 與 Python, 還可免費存放各種數位資料, 當時以為資料終於可以永續存放的假象, 到 2016 年夢想逐漸破滅, 還好 2016 年之後有 Github 接手, Heroku 也很意外地從 2007 年活到現在, 目前, Github 與 Heroku (只能儲存 500 MB), 加上 Gitlab 的同步資料備份與 Google Drive 上的大檔案存放, 全球網友前撲後繼用隱私換取數位資料免費存放的所謂永續性,  似乎終於有了眉目.&lt;/p&gt;
&lt;p&gt;目前教育版的 Google Drive 仍不限容量, 但也許未來的某一天這樣的所謂永續仍會畫上休止符, 大家仍必須有所因應.&lt;/p&gt;
&lt;h2&gt;資料存至 Google Drive&lt;/h2&gt;
&lt;p&gt;從 &lt;a href="https://github.com/mdecourse/cd2020pj1/blob/master/myflaskapp.py"&gt;https://github.com/mdecourse/cd2020pj1/blob/master/myflaskapp.py&lt;/a&gt; 可以看出如何利用 Google Drive API, 在網際環境中將數位檔案送到特定伺服器之外, 還能利用 AJAX 存備份至特定 Google Drive 目錄.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@app.route('/saveToDB' , methods=['POST'])
@login_required
def saveToDB():

    """axuploader.js 將檔案上傳後, 將上傳檔案名稱數列, 以 post 回傳到 Flask server.

    截至這裡, 表示檔案已經從 client 上傳至 server, 可以再設法通過認證, 將 server 上的檔案上傳到對應的 Google Drive, 並且在上傳後的 GDrive 目錄, 設定特定擷取權限 (例如: 只允許 @gm 用戶下載.
    以下則可將 server 上傳後的擷取目錄與 GDrive 各檔案 ID 存入資料庫, 而檔案擷取則分為 server 擷取與 GDrive 擷取等兩種 url 連結設定
    """

    if request.method == "POST":
        files = request.form["files"]
        # split files string
        files = files.split(",")
        # files 為上傳檔案名稱所組成的數列
        for i in range(len(files)):
            # 逐一將已經存在 server downloads 目錄的檔案, 上傳到 GDrive uploaded 目錄
            fileName = files[i]
            fileLocation = _curdir + "/downloads/" + fileName
            mimeType = mimetypes.MimeTypes().guess_type(fileLocation)[0]
            # for GDrive v2
            #gdriveID = uploadToGdrive(fileName, mimeType)
            # for GDrive v3
            gdriveID = uploadToGdrive3(fileName, mimeType)
            fileSize = str(round(os.path.getsize(fileLocation)/(1024*1024.0), 2)) + " MB"
            date = datetime.datetime.now().strftime("%b %d, %Y - %H:%M:%S")
            user = session.get("user")
            print(user + "|" + str(fileSize) + "|" + str(mimeType) + "|"  + gdriveID)
            # 逐一將上傳檔案名稱存入資料庫, 同時存入mimeType, fileSize 與 gdriveID
            # 資料庫欄位
            #g.db.execute('insert into grouping (user , date, fileName, mimeType, fileSize, memo) values (?, ?, ?, ?, ?, ?)',(user, date, fileName, mimeType, fileSize, "memo"))
            #g.db.commit()
            #flash('已經新增一筆 upload 資料!')
    return "Uploaded fileName and gdriveID save to database"
def uploadToGdrive(fileName, mimeType):
    gauth = GoogleAuth()
    # 必須使用 desktop 版本的 client_secrets.json
    gauth.LoadClientConfigFile("./../gdrive_desktop_client_secrets.json")
    drive = GoogleDrive(gauth)

    '''
    # View all folders and file in your Google Drive
    fileList = drive.ListFile({'q': "'root' in parents and trashed=false"}).GetList()
    for file in fileList:
      print('Title: %s, ID: %s' % (file['title'], file['id']))
      # Get the folder ID that you want
      # 檔案會上傳到根目錄下的 uploaded  目錄中
      if(file['title'] == "uploaded"):
          fileID = file['id']
    '''
    # GDrive 上 uploaded 目錄的 fileID
    with open("./../gdrive_uploaded_id.txt", 'r') as content_file:
        fileID = content_file.read()

    # 由上述目錄外的檔案讀取 uploaded 目錄對應 ID
    #fileID = "your_folder_file_ID"
    # 上傳檔案名稱為輸入變數
    #fileName = "DemoFile.pdf"
    filePath = _curdir + "/downloads/"
    # parents 為所在 folder, 亦即 uploaded 目錄, fileID 為 uploaded 目錄的 ID
    file1 = drive.CreateFile({"mimeType": mimeType, "parents": [{"kind": "drive#fileLink", "id": fileID}], "title":  fileName})
    file1.SetContentFile(filePath + fileName)
    file1.Upload() # Upload the file.
    # 傳回與上傳檔案對應的 GDrive ID, 將會存入資料庫 gdiveID 欄位
    return file1['id']
    #print('Created file %s with mimeType %s' % (file1['title'], file1['mimeType']))   
    #print("upload fileID:" + str(file1['id']))
    # 以下為下載檔案測試
    # file2 = drive.CreateFile({'id': file1['id']})
    #file2.GetContentFile('./test/downloaded_ModernC.pdf') # Download file as 'downloaded_ModernC.pdf under directory test'.

    '''
    file1.Trash()  # Move file to trash.
    file1.UnTrash()  # Move file out of trash.
    file1.Delete()  # Permanently delete the file.
    '''
def uploadToGdrive3(fileName, mimeType):
    # get upload folder id
    # GDrive 上 uploaded 目錄的 fileID
    with open("./../gdrive_uploaded_id.txt", 'r') as content_file:
        folderID = content_file.read()

    creds = None
    with open('./../gdrive_write_token.pickle', 'rb') as token:
        creds = pickle.load(token)
    # 讀進既有的 token, 建立 service
    driveService = build('drive', 'v3', credentials=creds)

    metadata = {
        'name': fileName,
        'mimeType': mimeType,
        # 注意: 必須提供數列格式資料
        'parents': [folderID]
        }

    filePath = _curdir + "/downloads/" + fileName
    media = MediaFileUpload(filePath,
                                            mimetype=mimeType,
                                            chunksize=1024*1024,
                                            resumable=True
                                            )

    gdFile = driveService.files().create(
        body=metadata,
        media_body=media,
        fields='id'
    ).execute()
    fileID = gdFile.get("id")

    return fileID
&lt;/pre&gt;

&lt;p&gt;上述程式利用較新的 GDrive V3 上傳資料之前, 可攜系統必須安裝 google-api-python-client:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
# for uploadToGDrive3
# pip install google-api-python-client
# https://github.com/googleapis/google-api-python-client
import pickle
from googleapiclient.discovery import build
from apiclient.http import MediaFileUpload
&lt;/pre&gt;

&lt;h2&gt;Github, Gitlab 與 Fossil SCM&lt;/h2&gt;
&lt;p&gt;針對 Github 與 Gitlab 的操作, 可以參考 &lt;a href="https://git-scm.com/book/en/v2"&gt;https://git-scm.com/book/en/v2&lt;/a&gt;, 但是 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的參考資料則相對較少, 以下將針對 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的應用稍加說明, 為了因應未來上述各種網際免費數位儲存資料系統的更迭, 在近端配置 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;, 並用 &lt;a href="https://en.wikipedia.org/wiki/Blu-ray_Disc_recordable"&gt;BD-R or BD-RE&lt;/a&gt; (25GB) 進行備份, 也是一個不錯的資料永續儲存方案.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的使用非常簡單, 只要配合操作系統從 &lt;a href="https://fossil-scm.org/home/uv/download.html"&gt;https://fossil-scm.org/home/uv/download.html&lt;/a&gt; 下載相應版本, 並讓系統可以執行 fossil.exe (以 Windows 10 為例) 即可, 唯一要注意的是若操作過程牽涉兩個不同操作系統, 必須透過 fossil version 查驗雙方的版本是否相同.&lt;/p&gt;
&lt;p&gt;有關 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的先前參考資料, 可參閱 &lt;a href="http://mde.tw/2017springcd/blog/intro-fossil-scm.html"&gt;Fossil SCM 簡介&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Ubuntu 安裝 fossil scm&lt;/h2&gt;
&lt;p&gt;使用 sudo apt install fossil 安裝 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 所取得的版本可以利用 fossil version 檢查. 若版本並非最新版本或與 Windows 10 所用的版本相同, 可以至 &lt;a href="https://fossil-scm.org/home/uv/download.html"&gt;https://fossil-scm.org/home/uv/download.html&lt;/a&gt; 下載最新的 fossil 後, 以 sudo cp /home/user/fossil /usr/bin/, 然後再透過 fossil version 查驗是否已經更新為最新版本.&lt;/p&gt;
&lt;h2&gt;安裝 stunnel4&lt;/h2&gt;
&lt;p&gt;由於 &lt;a href="https://fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 並無 https 啟動功能的設置, 因此在實作上必須透過 stunnel SSL 代理主機啟動 https 伺服功能.&lt;/p&gt;
&lt;p&gt;首先安裝 stunnel4:&lt;/p&gt;
&lt;p&gt;sudo apt install stunnel4&lt;/p&gt;
&lt;p&gt;接下來將系統環境設為 HTTPS:&lt;/p&gt;
&lt;p&gt;sudo vi /etc/environment&lt;/p&gt;
&lt;p&gt;加入 HTTPS=on&lt;/p&gt;
&lt;p&gt;並且在 /etc/default/stunnel4 中加入 ENABLED=1&lt;/p&gt;
&lt;p&gt;然後透過 sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt, 在 /etc/stunnel/ 目錄中建立所需的 localhost.key 與 localhost.crt&lt;/p&gt;
&lt;p&gt;同時建立 /etc/stunnel/stunnel.conf 如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
[https]
accept = your_IPv4_ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021
&lt;/pre&gt;

&lt;p&gt;實際配置下, 使用 :::443 並無法讓 stunnel 綁定至系統的 ipv6 網址, 必須使用:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
[https]
accept = 140.xxx.xxx.xxx:443
accept = 2001:288:6004:xx::1:443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021
&lt;/pre&gt;

&lt;p&gt;似乎 stunnel 會自動取最後的 :443 作為 port, 而無需如 https://[ipv6 address]:443 中以 [] 隔開 ipv6 網址與埠號.&lt;/p&gt;
&lt;p&gt;execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound cd2021 設定的意思為 stunnel 代理啟動的指令為 fossil http, 指定 /home/yser/repository/ 作為倉儲目錄, 可以透過 URL 加上倉儲名稱伺服多個 repo.fossil 倉儲, 隨後的 --https 表示要使用 https 協定擷取資料, --nojail 表示不要使用 root 權限啟動, 且不進入 jail 模式, --notfound cd2021 表示內定  https URL 擷取的倉儲為 /home/user/repository/cd2021.fossil&lt;/p&gt;
&lt;h2&gt;啟動-停止-重新啟動 stunnel4.service&lt;/h2&gt;
&lt;p&gt;sudo systemctl start stunnel4.service&lt;/p&gt;
&lt;p&gt;sudo systemctl stop stunnel4.service&lt;/p&gt;
&lt;p&gt;sutod systemctl restart stunnel4.service&lt;/p&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>2021 開春</title><link href="https://mde.tw/lab/blog/starting-2021.html" rel="alternate"></link><published>2021-02-10T11:00:00+08:00</published><updated>2021-02-10T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2021-02-10:/lab/blog/starting-2021.html</id><summary type="html">&lt;p&gt;2021 年伊始, 機器學習的程式從原先簡單的演化, 進展到能夠有效控制具有亂數的決策系統, 科技的發展讓人類的工作更加兩極化, 一方可持續開發指使電腦軟硬體從事工作, 而另一方則幾乎必須完全按照電腦軟硬體的指示與命令行事.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;2021 年伊始, 機器學習的程式從原先簡單的演化, 進展到能夠有效控制具有亂數的決策系統, 科技的發展讓人類的工作更加兩極化, 一方可持續開發指使電腦軟硬體從事工作, 而另一方則幾乎必須完全按照電腦軟硬體的指示與命令行事.&lt;/p&gt;


&lt;p&gt;這樣的發展似乎已經沒了退路.&lt;/p&gt;</content><category term="Weblog"></category><category term="202102"></category></entry><entry><title>同步 Pelican 與 Blogger 網誌內容</title><link href="https://mde.tw/lab/blog/sync-pelican-and-blogger-content.html" rel="alternate"></link><published>2020-05-18T11:00:00+08:00</published><updated>2020-05-18T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-18:/lab/blog/sync-pelican-and-blogger-content.html</id><summary type="html">&lt;p&gt;在先前的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 架構中, 曾經設法讓 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt;, 相同的概念, 也可以在 &lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中, 讓 Pelican 的網誌文章與 Google Blogger 保持同步.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;在先前的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 架構中, 曾經設法讓 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt;, 相同的概念, 也可以在 &lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中, 讓 Pelican 的網誌文章與 Google Blogger 保持同步.&lt;/p&gt;


&lt;h2&gt;按鈕與節點標題&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中可以設置按鈕執行 Python 程式, 其中搭配節點的標題內容存取, 可以應用在 Pelican 與 Blogger 的網誌內容同步.&lt;/p&gt;
&lt;p&gt;由於目前使用的 Pelican, 在 markdown 目錄中編寫 .md 檔案, 然後再設法以 Pelican 指令與設定檔, 將所有的 .md 檔案轉為 blog 目錄中的網誌內容. 其中, 若能將個別的 .md 檔案先轉為 html 後, 再利用 Google Blogger API 的 Python 程式將各網誌 html 檔案送至對應帳號下的 Blogger 網誌系統, 將可以將一份內容分別同步到 Pelican 與 Blogger.&lt;/p&gt;
&lt;h2&gt;新增 Blogger 文章&lt;/h2&gt;
&lt;p&gt;add_to_blogger 按鈕程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    # 但是只換第一個
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;', 1)
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    blog_id = blogs["items"][0]["id"]
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;h2&gt;編輯 Blogger 文章&lt;/h2&gt;
&lt;p&gt;edit_to_blogger 按鈕程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    blog_id = blogs["items"][0]["id"]
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;h2&gt;從 Blogger 取回內容&lt;/h2&gt;
&lt;p&gt;在 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt; 中, 可以從 Wordpress 取回網誌內容, 然後新增到 Pelican, 在此因為網誌文章的建立以 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 倉儲中的 Pelican 網誌為主, Blogger 只是附屬備份網誌, 所以就不再從新增的 Google Blogger 取回網誌文章.&lt;/p&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developers.google.com/blogger"&gt;https://developers.google.com/blogger&lt;/a&gt;&lt;/p&gt;</content><category term="Weblog"></category><category term="Pelican"></category><category term="Blogger"></category></entry></feed>