<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Lab.mde.tw 網誌</title><link href="https://mde.tw/lab/blog/" rel="alternate"></link><link href="https://mde.tw/lab/blog/feeds/all.atom.xml" rel="self"></link><id>https://mde.tw/lab/blog/</id><updated>2020-06-11T11:00:00+08:00</updated><entry><title>代理主機維護策略</title><link href="https://mde.tw/lab/blog/stratege-for-proxy-servers.html" rel="alternate"></link><published>2020-06-11T11:00:00+08:00</published><updated>2020-06-11T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-06-11:/lab/blog/stratege-for-proxy-servers.html</id><summary type="html">&lt;p&gt;昨天又失去一台 HP 代理主機, 也就是編號 42 的 Squid Proxy Server. 因此目前只剩下 4, 53 與 69 等三台.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;昨天又失去一台 HP 代理主機, 也就是編號 42 的 Squid Proxy Server. 因此目前只剩下 4, 53 與 69 等三台.&lt;/p&gt;


&lt;h2&gt;雙協定支援代理主機的需求&lt;/h2&gt;
&lt;p&gt;也許大家會存疑, 機械設計科系為何需要自行安裝維護網路代理主機？假如根據學校多年前回覆, 之所以拆掉校級的代理主機設置, 原因是聯外頻寬已經很足夠, 因此不需要網路代理主機.&lt;/p&gt;
&lt;p&gt;但是, 這種假設是, 系上的 IPv4 數量足夠, 而大部分的外部伺服器都已經支援 IPv6, 但是對於平日電腦總數量超過 300 台的機械設計系, 希望上課時讓每一位學員都能將課程資料存取於 Github.com, 這兩個條件都不存在.&lt;/p&gt;
&lt;p&gt;因此, 從電腦輔助設計室上課的需求來看, 採用 IPv4 NAT 的模式, 並無足夠的頻寬讓 至少 50 台電腦快速直接對 Github.com 連線, 而如眾所知, Github.com 目前尚不支援 IPv6 網路協定.&lt;/p&gt;
&lt;p&gt;因此, 2-3 台能夠同時支援 IPv4 與 IPv6 網路協定的代理主機, 似乎是可行的方案之一.&lt;/p&gt;
&lt;h2&gt;維護全時運作主機的可能方案&lt;/h2&gt;
&lt;p&gt;假如以電腦輔助設計室每週 40 堂課計算, 其中只有至多 14 堂課需要使用網路代理主機, 理論上並沒有必要全時讓這些代理主機運作, 而只要維持一台連內 (69), 一台連外 (4), 其餘的 IPv4 伺服器 IP 位址, 可以交由每班中至多 5 個分組的組長, 以虛擬主機 bridged 網路的方式各自管理分組中的代理主機, 其中可能的編號將有 (24, 32, 34, 39, 42）等五台.&lt;/p&gt;
&lt;p&gt;其中, 因為在上學期的課程有大一的計算機程式與大二的電腦輔助設計實習課程, 而下學期的課程則有大一的網際內容管理與大二的協同產品設計實習, 正好可以在各課程中安排學長與學弟妹共同維護這五台代理主機的互動傳承內容.&lt;/p&gt;
&lt;h2&gt;Squid 代理主機的安裝&lt;/h2&gt;
&lt;p&gt;以 Ubuntu 20.04 伺服器主機為例, 安裝 Squid Proxy 伺服器:&lt;/p&gt;
&lt;p&gt;sudo apt install squid&lt;/p&gt;
&lt;p&gt;接下來, 利用 /etc/squid/squid.conf 進行配置:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
# 定義可以連線電腦網路位置範圍或特定 IP
acl cad_lab src 192.130.17.0/24
acl cad_lab src 192.127.237.33
acl cad_lab src 2001:288::/64

# 定義可以連線通過的埠號
acl SSL_ports port 443
acl Safe_ports port 80 # http
acl Safe_ports port 88
acl Safe_ports port 89

#acl Safe_ports port 21 # ftp
acl SSL_ports port 8843
acl SSL_ports port 5443
acl SSL_ports port 8443
acl Safe_ports port 8443

acl SSL_ports port 9443
acl Safe_ports port 9443

acl SSL_ports port 22
acl Safe_ports port 22

acl Safe_ports port 443 # https
acl Safe_ports port 1025-65535 # unregistered ports
acl Safe_ports port 280 # http-mgmt
acl Safe_ports port 488 # gss-http
acl Safe_ports port 591 # filemaker
acl Safe_ports port 777 # multiling http
acl CONNECT method CONNECT

# 除了前面定義的安全埠號外, 一律拒絕連線
# Deny requests to certain unsafe ports
http_access deny !Safe_ports

# 除了前面定義的安全埠號外, 一律不准連線
# Deny CONNECT to other than secure SSL ports
http_access deny CONNECT !SSL_ports

# 只允許前面定義的網路 IP 電腦連線, 其餘一律禁止
http_access allow cad_lab
http_access deny all
# Only allow cachemgr access from localhost
http_access allow localhost manager
http_access deny manager

#http_access allow localnet
http_access allow localhost

# And finally deny all other access to this proxy
http_access deny all

# Squid normally listens to port 3128
http_port 3128

#cache_dir ufs /var/spool/squid 100 16 256
icp_port 3130
icp_access allow all

cache_dir ufs /var/spool/squid 2000 16 256
cache_peer 192.130.17.4 sibling 3128 3130
cache_peer 192.130.17.42 sibling 3128 3130
cache_peer 192.130.17.53 sibling 3128 3130


#
# Add any of your own refresh_pattern entries above these.
#
refresh_pattern ^ftp: 1440 20% 10080
refresh_pattern ^gopher: 1440 0% 1440
refresh_pattern -i (/cgi-bin/|\?) 0 0% 0
refresh_pattern (Release|Packages(.gz)*)$ 0 20% 2880
refresh_pattern . 0 20% 4320

max_filedesc 40960
cache_mem 4000 MB
&lt;/pre&gt;

&lt;p&gt;修改 /etc/squid/squid.conf 後, 以:&lt;/p&gt;
&lt;p&gt;sudo systemctl restart squid 重新啟動.&lt;/p&gt;
&lt;p&gt;假如要讓 Virtualbox 虛擬主機與 Windows 10 host 啟動開啟虛擬代理主機, 可以設定使用 &lt;a href="https://github.com/onlyfang/VBoxVmService"&gt;VBoxVmService&lt;/a&gt;, 但是 5.X 的 Virtualbox 必須與 VBoxVmService  5.X 版配合, 而 6.X 的版本也必須互動升級配置.&lt;/p&gt;
&lt;p&gt;後記:&lt;/p&gt;
&lt;p&gt;42 是一台 HP ML 30 gen9 的機器,  2017 安裝的 Ubuntu 在前幾天停止運作後, 直接將 Host 裝上 Win 10, 因無法從 USB 安裝, 只能用 blueray  dvd 重新安裝, 然後外部設為 39, 然後將虛擬 proxy 伺服器設為 42,  目前仍然加入服役中.&lt;/p&gt;</content><category term="Network"></category><category term="Proxy"></category></entry><entry><title>高風險聯網設備</title><link href="https://mde.tw/lab/blog/high-risk-networking-devices.html" rel="alternate"></link><published>2020-06-04T11:00:00+08:00</published><updated>2020-06-04T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-06-04:/lab/blog/high-risk-networking-devices.html</id><summary type="html">&lt;p&gt;前幾天, 感謝校方送來一份通知, 列出系上共有 40 多台所謂的高風險聯網設備. 其中有 8 台 Linux 代理主機必須配合更新套件, 並且限定可連線管理的 IP 位址範圍.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;前幾天, 感謝校方送來一份通知, 列出系上共有 40 多台所謂的高風險聯網設備. 其中有 8 台 Linux 代理主機必須配合更新套件, 並且限定可連線管理的 IP 位址範圍.&lt;/p&gt;


&lt;h2&gt;Ubuntu 伺服器&lt;/h2&gt;
&lt;p&gt;設計系目前共有三台實體虛擬主機與一台虛擬代理主機, 四台符號名稱伺服器,  以及兩台虛擬的 WWW 伺服器主機. &lt;/p&gt;
&lt;p&gt;其中系上的符號名稱伺服器原先安裝 Ubuntu 18.04, 必須升級為 20.04, 四台符號名稱伺服器與 WWW 伺服器則需要限制 ssh 的連線範圍.&lt;/p&gt;
&lt;p&gt;針對非開發版本的 Ubuntu 18.04 可以參考 https://www.linuxtechi.com/upgrade-ubuntu-18-04-lts-to-ubuntu-20-04-lts/ 升級為 20.04.&lt;/p&gt;
&lt;p&gt;舊版的 nginx, 若要升級為較新版本, 則可參考 https://devopscraft.com/how-to-compile-nginx-from-source-on-ubuntu-20-04/ 自行編譯安裝.&lt;/p&gt;
&lt;h2&gt;ufw 防火牆&lt;/h2&gt;
&lt;p&gt;以代理主機而言, 除了限制可連線 ssh 的 IP 範圍外, 還需要讓同區段的電腦可以對 3128 埠號連線;&lt;/p&gt;
&lt;pre class="brush: js"&gt;
    sudo -s 
    ufw status
    ufw allow from your_ipv4_or_ipv6_ip
    ufw allow from 2001:288::/16 to any port 22
    ufw deny 22
    ufw allow from 2001:288::/16 to any port 3128
    ufw deny 3128
    ufw enable
&lt;/pre&gt;

&lt;p&gt;其次, 若要刪除原先 ufw 的設定可以使用 ufw reset, 若要暫時關閉 ufw, 採用 ufw disable.&lt;/p&gt;
&lt;p&gt;符號名稱的部分, 需要限制 port 22 連線外, 必須讓所有主機都能對 port 53 連線:&lt;/p&gt;
&lt;pre class="brush: js"&gt;
    sudo -s 
    ufw status
    ufw allow from your_ipv4_or_ipv6_ip
    ufw allow from 2001:288::/16 to any port 22
    ufw deny 22
    ufw allow 53
    ufw enable
&lt;/pre&gt;

&lt;p&gt;WWW 伺服器若採用 port 80 與 443 配置, 則需要對所有主機開放, port 5443 若執行 Fossil SCM, 也必須開放, 其他也是對 port 22 有連線範圍的限制.&lt;/p&gt;
&lt;pre class="brush: js"&gt;
    sudo -s 
    ufw status
    ufw allow from your_ipv4_or_ipv6_ip
    ufw allow from 2001:288::/16 to any port 22
    ufw deny 22
    ufw allow 80
    ufw allow 443
    ufw allow 5443
    ufw enable
&lt;/pre&gt;

&lt;p&gt;最後, 則是附上&lt;a href="https://github.com/mdecourse/wcms2018/issues/7"&gt;電腦輔助設計室電腦規劃&lt;/a&gt; 與 &lt;a href="http://www.linuxfromscratch.org/blfs/view/svn/postlfs/security.html"&gt;網路安全&lt;/a&gt; 參考資料.&lt;/p&gt;</content><category term="Network"></category><category term="Security"></category></entry><entry><title>網際內容管理 Ｗ13</title><link href="https://mde.tw/lab/blog/wcm-w13-ubuntu-and-blogs.html" rel="alternate"></link><published>2020-05-28T11:00:00+08:00</published><updated>2020-05-28T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-28:/lab/blog/wcm-w13-ubuntu-and-blogs.html</id><summary type="html">&lt;p&gt;之所以在機械設計工程系開設網際內容管理課程, 起源於多年前的所謂製商整合科技教育改進計畫, 當時參與的科系有機械設計系, 自動化工程系, 工業管理系與資訊管理系, 同時開設的課程還有協同產品設計實習, 基因演算與產品生命週期管理.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;之所以在機械設計工程系開設網際內容管理課程, 起源於多年前的所謂製商整合科技教育改進計畫, 當時參與的科系有機械設計系, 自動化工程系, 工業管理系與資訊管理系, 同時開設的課程還有協同產品設計實習, 基因演算與產品生命週期管理.&lt;/p&gt;


&lt;h2&gt;網際內容管理課程目標&lt;/h2&gt;
&lt;p&gt;這項計畫與其他所謂的跨領域學程的命運沒有太大的差異, 計畫補助經費結束, 大家各自回巢, 留下一堆陳年資訊系統設備, 還有這門網際內容管理與協同產品設計實習.&lt;/p&gt;
&lt;p&gt;網際內容管理課程開設在機械科系的主要任務, 是要鼓勵工程師善用全球資訊網的無遠弗屆, 與其他領域工程師執行協同設計, 自 2012 年起 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 已經成功在曾經開發 &lt;a href="https://www.solidworks.com/"&gt;Solidworks&lt;/a&gt; 的基礎上, 證明瀏覽器, 平板電腦與手機, 都可以是機械設計工程師開發產品的平台, 無需受限於單機安裝, 必須自行看顧版本更新, 徹底脫離沒有產品資料管理系統, 就無法協同進行產品開發的舊時代.&lt;/p&gt;
&lt;p&gt;當然, &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 雖然定位為電腦輔助機械設計與分析管理平台, 但是真正能夠編寫 Web based 程式前後端, 並且與 &lt;a href="https://en.wikipedia.org/wiki/Parasolid"&gt;Parasolid&lt;/a&gt; 核心程式庫進行圖形介面與觸控互動, 絕非出自通常只上過一門 [計算機程式] 課程的機械工程師, 而是來自一群號稱 Full stack web developers 的資訊科系研究工程師.&lt;/p&gt;
&lt;p&gt;儘管如此, 對於必須在 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 上利用 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;Featurescript&lt;/a&gt; 進行各種 2D 與 3D 零組件客製設計的機械工程師, 仍需具備一定程度的網際程式能力.&lt;/p&gt;
&lt;p&gt;因此, 在四技部的網際內容管理課程, 定位為接續計算機程式課程, 預計培養未來在電腦輔助設計實習與協同產品設計實習等課程, 負責建置實體與虛擬主機, 搭建網際機械設計管理系統的協同人員, 而五專部的網際內容管理課程, 則定位在承接計算機概論課程, 讓高一程度的學員, 能夠了解網際軟硬體的基本架構外, 也能夠利用分散式版次管理建立網站, 管理網誌並利用基本的程式方法, 讓 Google &lt;a href="https://www.blogger.com/"&gt;Blogger&lt;/a&gt; 與 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 中的 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 網誌內容同步.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;要讓兩套架構完全不同的網誌系統內容同步, 可以採取各種程式方法, 這裡是透過 &lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 大綱編輯程式中的節點按鈕與節點編輯特性完成.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 允許使用者透過不同的 &lt;a href="https://leoeditor.com/directives.html"&gt;節點指令&lt;/a&gt;, 進行特定文字檔案的編輯管理, 其中的 &lt;a href="https://leoeditor.com/directives.html#clean-path"&gt;clean&lt;/a&gt; 節點指令, 最適合用來編輯 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; Blog 的 &lt;a href="https://en.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; 文章內容, 因為 &lt;a href="https://leoeditor.com/directives.html#clean-path"&gt;clean&lt;/a&gt; 允許將一篇文章以從屬架構的節點內容分割, 當使用者利用 &lt;a href="https://leoeditor.com/customizing.html?highlight=button"&gt;button&lt;/a&gt; 中的 Python 程式段, 試圖將 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 網誌的文章從 &lt;a href="https://en.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; 格式,  轉為 &lt;a href="https://en.wikipedia.org/wiki/HTML"&gt;html&lt;/a&gt; 檔案, 並且通過 Google &lt;a href="https://www.blogger.com/"&gt;Blogger&lt;/a&gt; API 的 credential 認證, 將網誌的 &lt;a href="https://en.wikipedia.org/wiki/HTML"&gt;html&lt;/a&gt; 格式文章, 轉貼到對應的 &lt;a href="https://www.blogger.com/"&gt;Blogger&lt;/a&gt; 系統之後, 可以取得該網誌的 id, 並將此 id 儲存在該 &lt;a href="https://en.wikipedia.org/wiki/Markdown"&gt;Pelican&lt;/a&gt; 文章編輯大綱中, &lt;a href="https://leoeditor.com/directives.html#clean-path"&gt;clean&lt;/a&gt; 節點下層的最末端, 之後的內容改版, 就可以依據此一 &lt;a href="https://www.blogger.com/"&gt;Blogger&lt;/a&gt; 文章 id, 循相同的授權模式, 將改版內容送至 Google &lt;a href="https://www.blogger.com/"&gt;Blogger&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;按鈕程式所需模組&lt;/h2&gt;
&lt;p&gt;為了利用 &lt;a href="https://leoeditor.com/customizing.html?highlight=button"&gt;button&lt;/a&gt; 中的 Python 程式將文章發佈至 Google &lt;a href="https://www.blogger.com/"&gt;Blogger&lt;/a&gt;, 可攜程式系統需要安裝 &lt;a href="https://github.com/googleapis/google-api-python-client"&gt;google-api-python-client&lt;/a&gt; 與 &lt;a href="https://github.com/googleapis/oauth2client"&gt;oauth2client&lt;/a&gt; 模組.&lt;/p&gt;
&lt;p&gt;pip install google-api-python-client oauth2client&lt;/p&gt;
&lt;p&gt;接下來則是取得與所要同步的 Google &lt;a href="https://www.blogger.com/"&gt;Blogger&lt;/a&gt; 認證檔案.&lt;/p&gt;</content><category term="WCM"></category><category term="Pelican"></category><category term="Blogger"></category><category term="Ubuntu"></category></entry><entry><title>同步 Pelican 與 Blogger 網誌內容</title><link href="https://mde.tw/lab/blog/sync-pelican-and-blogger-content.html" rel="alternate"></link><published>2020-05-18T11:00:00+08:00</published><updated>2020-05-18T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-18:/lab/blog/sync-pelican-and-blogger-content.html</id><summary type="html">&lt;p&gt;在先前的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 架構中, 曾經設法讓 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt;, 相同的概念, 也可以在 &lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中, 讓 Pelican 的網誌文章與 Google Blogger 保持同步.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;在先前的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 架構中, 曾經設法讓 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt;, 相同的概念, 也可以在 &lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中, 讓 Pelican 的網誌文章與 Google Blogger 保持同步.&lt;/p&gt;


&lt;h2&gt;按鈕與節點標題&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 中可以設置按鈕執行 Python 程式, 其中搭配節點的標題內容存取, 可以應用在 Pelican 與 Blogger 的網誌內容同步.&lt;/p&gt;
&lt;p&gt;由於目前使用的 Pelican, 在 markdown 目錄中編寫 .md 檔案, 然後再設法以 Pelican 指令與設定檔, 將所有的 .md 檔案轉為 blog 目錄中的網誌內容. 其中, 若能將個別的 .md 檔案先轉為 html 後, 再利用 Google Blogger API 的 Python 程式將各網誌 html 檔案送至對應帳號下的 Blogger 網誌系統, 將可以將一份內容分別同步到 Pelican 與 Blogger.&lt;/p&gt;
&lt;h2&gt;新增 Blogger 文章&lt;/h2&gt;
&lt;p&gt;add_to_blogger 按鈕程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    # 但是只換第一個
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;', 1)
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    '''
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    '''
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    blog_id = blogs["items"][0]["id"]
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;h2&gt;編輯 Blogger 文章&lt;/h2&gt;
&lt;p&gt;edit_to_blogger 按鈕程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os

argv = ""
# 認證並建立服務
# name of the api is "blogger", version is "v3"
# description of the api is __doc__
# file name of the application: location of client_secrets.json
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, "./../../client_secrets.json",
  scope='https://www.googleapis.com/auth/blogger')


def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &amp;lt;h2&amp;gt;標題
content = content.replace("&amp;lt;h2&amp;gt;", "&amp;lt;h2&amp;gt;&amp;lt;font size='4'&amp;gt;")
content = content.replace("&amp;lt;/h2&amp;gt;", "&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;")
# g.es(content)

try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    blog_id = blogs["items"][0]["id"]
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")
&lt;/pre&gt;

&lt;h2&gt;從 Blogger 取回內容&lt;/h2&gt;
&lt;p&gt;在 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 與 Ｗordpress 的內容同步&lt;/a&gt; 中, 可以從 Wordpress 取回網誌內容, 然後新增到 Pelican, 在此因為網誌文章的建立以 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 倉儲中的 Pelican 網誌為主, Blogger 只是附屬備份網誌, 所以就不再從新增的 Google Blogger 取回網誌文章.&lt;/p&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developers.google.com/blogger"&gt;https://developers.google.com/blogger&lt;/a&gt;&lt;/p&gt;</content><category term="Weblog"></category><category term="Pelican"></category><category term="Blogger"></category></entry><entry><title>Virtualbox Ubuntu 虛擬主機網路設定</title><link href="https://mde.tw/lab/blog/virtualbox-ubuntu-nat-network.html" rel="alternate"></link><published>2020-05-16T12:00:00+08:00</published><updated>2020-05-16T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-16:/lab/blog/virtualbox-ubuntu-nat-network.html</id><summary type="html">&lt;p&gt;利用 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 建立 Ubuntu 20.04 伺服器的虛擬主機, 可以讓使用者透過便捷的網路設定, 了解不同主機連線配置的特性外, 也能同時測試跨操作系統平台套件在 Windows 與 Ubuntu 環境執行的差異.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;利用 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 建立 Ubuntu 20.04 伺服器的虛擬主機, 可以讓使用者透過便捷的網路設定, 了解不同主機連線配置的特性外, 也能同時測試跨操作系統平台套件在 Windows 與 Ubuntu 環境執行的差異.&lt;/p&gt;


&lt;p&gt;修課學員只要登入 ＠gm 帳號後, 就可下載 &lt;a href="https://drive.google.com/open?id=1Ff-mPk9kww_04RxkkiS0lb_2Y9z8Ek1Z"&gt;Ubuntu 20.04 虛擬主機&lt;/a&gt; (或下載 &lt;a href="https://drive.google.com/open?id=13Gqwyj0CGR6wa9dZg_BmlCLv5cNYWQJ_"&gt;Ubuntu 20.04 W12 虛擬主機&lt;/a&gt;), 並匯入 Windows 10 環境所安裝的 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;接下來就必須了解如何使用虛擬主機的 NAT Network 網路設定.&lt;/p&gt;
&lt;h2&gt;讓虛擬主機連上廣域網路&lt;/h2&gt;
&lt;p&gt;能直接讓 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 虛擬主機連上網路的設定, 可以選擇 NAT, NAT Network 與 Bridged 等三種設定. 詳細的說明可以參考 &lt;a href="https://drive.google.com/open?id=1U8hVabo24eBrkuau5Ev0Za8XC9k_Bzux"&gt;Virtualbox Network Setting&lt;/a&gt;, &lt;a href="https://drive.google.com/open?id=1xRxWmYOw4tQuRAFecsAEOlqu62xPUvMc"&gt;Virtualbox 5.1.22 User Manual&lt;/a&gt;, &lt;a href="https://drive.google.com/open?id=1MX1XT1hlOWYVIZ8bKbtlrTAWBCgRRnSL"&gt;Virtualbox 6.1.8 User Manual&lt;/a&gt; 中的說明.&lt;/p&gt;
&lt;p&gt;假如需要利用 Python 程式透過 COM 操控 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 中的虛擬主機, 則可以參考 &lt;a href="https://drive.google.com/open?id=1DsVpKWUoDHO-AWnuFxafQ-kYR53_kCT6"&gt;Virtualbox 5.1.22 Programming Guide&lt;/a&gt; 與 &lt;a href="https://drive.google.com/open?id=1jTmj2oWSO8aCpF6DW1rIAYz3iqYQtjPp"&gt;Virtualbox 6.1.8 Programming Guide&lt;/a&gt; 中的說明.&lt;/p&gt;
&lt;p&gt;在目前的網際內容管理與協同產品設計課程應用上, 以 NAT Network 的設置最合需求. 因為 Ubuntu 20.04 虛擬主機可以透過 Windows 10 Host 的 IPv4 或 IPv6 網路設定連外. 同時 Ｗindows 10 上的瀏覽器與 Python 程式可以透過內部網路對虛擬主機連線.&lt;/p&gt;
&lt;p&gt;使用 NAT Network 讓虛擬主機上網的另外一個好處是: Host 上 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 的網路設定可以動態生效, 亦即 Ubuntu 20.04 可以一直保持在開機狀態, 使用者在 Host 端更動 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 的 NAT Network 設定後, 即刻可以在 Ubuntu 虛擬主機上進行配合調適, 無需如 Bridged 或 Host Only 虛擬主機的網路設定, 必須關機後才能修改所使用的網路設定.&lt;/p&gt;
&lt;h2&gt;NAT Network 上的 IPv4 與 IPv6 設定&lt;/h2&gt;
&lt;p&gt;由於在電腦輔助設計室使用純 IPv6 協定上網, 因此採用 NAT Network 設定的 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 虛擬主機, 也必須能夠透過 IPv6 進行設定.&lt;/p&gt;
&lt;p&gt;NAT Network 的 DHCP 能同時支援 IPv4 與 IPv6, 但是在 GUI 介面只列出 IPv4 的 DHCP 內定使用 10.0.2.0/24 IP 位址, IPv6 的部分則需要透過指令才可列出:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
C:\Users\kmol2019&gt;"C:\Program Files\Oracle\VirtualBox\VBoxManage" list natnetworks
NetworkName:    NatNetwork
IP:             10.0.2.1
Network:        10.0.2.0/24
IPv6 Enabled:   Yes
IPv6 Prefix:    fd17:625c:f037:2::/64
DHCP Enabled:   Yes
Enabled:        Yes
loopback mappings (ipv4)
        127.0.0.1=2
&lt;/pre&gt;

&lt;p&gt;換言之, 在 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 採用 NAT Network 設定的虛擬主機, 其 IPv4 gateway 預設為 10.0.2.1, 而 IPv6 的 gateway 則為 fd17:625c:f037:2::1, 了解此一訊息之後, 使用者就可以利用 Ｗindows 10 中的批次檔案 setnatnetwork.bat 來設定後續的網路內容, 主要讓 &lt;a href="https://github.com/mdecourse/cd2020pj1.git"&gt;cd2020pj1&lt;/a&gt; 啟動後的 8443 與 7443 埠號伺服器, 能夠從 Host 瀏覽器中連線:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "ssh:tcp:[127.0.0.1]:22:[10.0.2.4]:22"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "coppeliasim:tcp:[127.0.0.1]:19999:[10.0.2.4]:19999"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "cmsimde1:tcp:[127.0.0.1]:8443:[10.0.2.4]:8443"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-4 "cmsimde2:tcp:[127.0.0.1]:7443:[10.0.2.4]:7443"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-6 "ssh:tcp:[::1]:22:[fd17:625c:f037:2:a00:27ff:fef6:9b8a]:22"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-6 "cmsimde1:tcp:[::1]:8443:[fd17:625c:f037:2:a00:27ff:fef6:9b8a]:8443"

"C:\Program Files\Oracle\VirtualBox\VBoxManage" natnetwork modify --netname NatNetwork --port-forward-6 "cmsimde2:tcp:[::1]:7443:[fd17:625c:f037:2:a00:27ff:fef6:9b8a]:7443"
&lt;/pre&gt;

&lt;p&gt;其中 Ubuntu 20.04 虛擬主機的 netplan 網路設定為:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
network:
    ethernets:
        enp0s3:
            dhcp4: true 
            dhcp6: true 
            nameservers:
                addresses:
                     - 2001:b000:168::1
    version: 2
&lt;/pre&gt;

&lt;p&gt;表示兩種網路協定都採用 DHCP, 但是 IPv6 必須設定 DNS 伺服器, 因為學校 DHCP6 所設定的 DNS 無法正確運作的緣故.&lt;/p&gt;</content><category term="ubuntu"></category><category term="Virtualbox"></category></entry><entry><title>gitlab 與 github 整合運用</title><link href="https://mde.tw/lab/blog/use-github-and-gitlab-pages.html" rel="alternate"></link><published>2020-05-16T11:00:00+08:00</published><updated>2020-05-16T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-16:/lab/blog/use-github-and-gitlab-pages.html</id><summary type="html">&lt;p&gt;由於 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 遲遲不推出支援 IPv6 網站的連線功能, 目前若要在電腦輔助設計室直接透過純 IPv6 網路連線使用 git 分散式版次管理系統, 可以將 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 上的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 網站, 同步一份倉儲資料到 &lt;a href="https://docs.gitlab.com/ee/user/project/pages/"&gt;Gitlab Pages&lt;/a&gt;.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;由於 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 遲遲不推出支援 IPv6 網站的連線功能, 目前若要在電腦輔助設計室直接透過純 IPv6 網路連線使用 git 分散式版次管理系統, 可以將 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 上的 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 網站, 同步一份倉儲資料到 &lt;a href="https://docs.gitlab.com/ee/user/project/pages/"&gt;Gitlab Pages&lt;/a&gt;.&lt;/p&gt;


&lt;h2&gt;機械設計工程師的網站&lt;/h2&gt;
&lt;p&gt;身為使用分散式版次管理系統的機械設計工程師團隊, 除了自行建立的 Linux 伺服器主機之外, &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 是目前用來建立靜態網頁的最佳平台. 但是截至目前只支援 IPv4 網路協定連線的 &lt;a href="https://github.com"&gt;github&lt;/a&gt;, 在上課時僅支援 IPv6 上線的情況下, 造成了許多不便. 因為所有的資料封包都必須透過雙支援的代理主機傳訊.&lt;/p&gt;
&lt;p&gt;為了讓使用者可以在純 IPv6 環境下, 將 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 的靜態網頁部署在廣域雲端平台上, 準備將倉儲資料同步一份到 &lt;a href="https://docs.gitlab.com/ee/user/project/pages/"&gt;Gitlab Pages&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;開放作風的 gitlab&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com"&gt;github&lt;/a&gt; 雖然比 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt; 早創立幾年, 但是 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt; 的開源與大器作風, 讓帳面價值達到 76 億美元的 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 失色許多.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 將用戶設定的靜態網頁資料分支, 以直覺但隱藏流程的方式進行, 導致許多情況下, 用戶無法就網頁資料轉檔流程進行除錯.&lt;/p&gt;
&lt;h2&gt;gitlab-ci.yml&lt;/h2&gt;
&lt;p&gt;而 &lt;a href="https://docs.gitlab.com/ee/user/project/pages/"&gt;Gitlab Pages&lt;/a&gt; 則選擇讓使用自行透過 gitlab-ci.yml 的 YAML 檔案, 自行控制網頁的轉檔流程.&lt;/p&gt;
&lt;p&gt;以 &lt;a href="https://github.com/mdecourse/cmsimde.git"&gt;CMSiMDE&lt;/a&gt; 網際內容管理中的靜態網頁而言, 只要在倉儲資料根目錄中, 加入一個 gitlab-ci.yml 檔案, 內容如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
pages:
  stage: deploy
  script:
  - mkdir .public
  - cp -r * .public
  - mv .public public
  artifacts:
    paths:
    - public
  only:
  - master
variables:
  GIT_SUBMODULE_STRATEGY: recursive
&lt;/pre&gt;

&lt;p&gt;就可以順利將倉儲資料中的主分支靜態網頁, 部署在 https://帳號.gitlab.io/倉儲名稱 網址中. 其中最重要的設定參數:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
GIT_SUBMODULE_STRATEGY: recursive
&lt;/pre&gt;

&lt;p&gt;就是表明要求 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt; 在將倉儲轉為網頁的過程, 同時以 recursive 的方式將其中的 submodule 目錄, 也納入網頁的內容.&lt;/p&gt;
&lt;h2&gt;git remote add&lt;/h2&gt;
&lt;p&gt;針對目前已經部署在 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 的靜態網頁倉儲, 使用者先在主分支的根目錄中, 新增提交推送一個上述的 gitlab-ci.yml 設定檔案, 然後建立與 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 帳號對應的 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt; 帳號之後, 新增一個與 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 倉儲的同名空專案, 也就是連 README.md 都不建立的 public 空倉儲, 然後在近端倉儲主分支工作目錄中, 以:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git remote add gitlab https://gitlab.com/帳號/同名倉儲.git
&lt;/pre&gt;

&lt;p&gt;新增一個網址代號 gitlab, 指到上述 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt; 系統中的空同名倉儲網址.&lt;/p&gt;
&lt;p&gt;接下來就可以透過:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git push gitlab
&lt;/pre&gt;

&lt;p&gt;將 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 倉儲中的主分支資料, 同步一份到 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt;, 並且在 gitlab-ci.yml 的設定導引下, 自動產生相應的 &lt;a href="https://docs.gitlab.com/ee/user/project/pages/"&gt;Gitlab Pages&lt;/a&gt; 靜態網頁. 而其網址就是: https://帳號.gitlab.io/倉儲名稱&lt;/p&gt;
&lt;p&gt;最後, 假如之後的倉儲改版以 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt; 為主, 只要在近端主分支的工作目錄中, 以:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git remote add github https://github.com/帳號/同名倉儲.git
&lt;/pre&gt;

&lt;p&gt;建立一個 github 代號倉儲連結, 就可以透過:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git push github
&lt;/pre&gt;

&lt;p&gt;將 &lt;a href="https://github.com"&gt;github&lt;/a&gt; 當作 &lt;a href="https://gitlab.com"&gt;gitlab&lt;/a&gt; 倉儲的備份網站.&lt;/p&gt;</content><category term="git"></category><category term="Github Pages"></category></entry><entry><title>打造 Windows 隨身程式系統</title><link href="https://mde.tw/lab/blog/create-portable-win-prog-sys.html" rel="alternate"></link><published>2020-05-12T11:00:00+08:00</published><updated>2020-05-12T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-12:/lab/blog/create-portable-win-prog-sys.html</id><summary type="html">&lt;p&gt;在 Windows 操作系統上開發套件, 不僅希望這個套件能夠在 Mac OS X 與 Linux 上運行, 而且整個程式環境都能放入一個 USB 隨身碟, 在任何一台乾淨的 64 位元 Windows 10 操作系統中都能正常運行. 不受限制, 因此需要打造一個隨身程式系統.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;在 Windows 操作系統上開發套件, 不僅希望這個套件能夠在 Mac OS X 與 Linux 上運行, 而且整個程式環境都能放入一個 USB 隨身碟, 在任何一台乾淨的 64 位元 Windows 10 操作系統中都能正常運行. 不受限制, 因此需要打造一個隨身程式系統.&lt;/p&gt;


&lt;h2&gt;啟動批次檔案&lt;/h2&gt;
&lt;p&gt;從以下這個 start.bat 批次啟動檔案, 大致可以看出此一可攜程式系統所包含的內容:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_no_proxy
set HomeDrive=%Disk%:\home_no_proxy
set Home=%Disk%:\home_no_proxy
set USERPROFILE=%Disk%:\home_no_proxy

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\Python38\DLLs;%Disk%:\Python38\Lib;%Disk%:\Python38\Lib\site-packages;
set PYTHONHOME=%Disk%:\Python38

REM for Java and Android SDK
set java_home=%Disk%:\java\jdk8u222-b10
set ANDROID_SDK_home=%Disk%:\home_no_proxy
set GRADLE_USER_home=%Disk%:\home_no_proxy
set ANDROID_SDK_ROOT=%Disk%:\android\sdk
set ANDROID_Home=%Disk%:\android\sdk
set REPO_OS_OVERRIDE=windows

REM 設定跟 Python 有關的命令搜尋路徑
set path_python=%Disk%:\Python38;%Disk%:\Python38\Scripts;
REM 設定跟Git 有關的命令搜尋路徑
set path_git=%Disk%:\portablegit\bin;
REM 設定 msys2 64 位元的執行路徑
set path_msys2=%Disk%:\msys64\mingw64\bin;
REM set for LaTeX
set path_miketex=%Disk%:\miktex-portable\texmfs\install\miktex\bin\x64;
REM Flutter path
set path_flutter=%Disk%:\flutter\bin;%java_home%\bin;%Disk%:\Android\sdk;%Disk%:\Android\sdk\tools;%Disk%:\Android\sdk\tools\bin;%Disk%:\Android\sdk\emulator;%Disk%:\Android\sdk\platform-tools;%Disk%:\flutter\bin\cache\dart-sdk\bin;%Disk%:\vscode;

path=%Disk%:;%path_python%;%path_git%;%path_msys2%;%path_miketex%;%path_flutter%;%path%;

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe

start /MIN %Disk%:\wScite\SciTE.exe
start /MIN %Disk%:\wScite\SciTE.exe

Exit
&lt;/pre&gt;

&lt;p&gt;關閉隨身系統的批次檔案 stop.bat, 只將 python, scite 與 dos 命令列關閉, 若需要關閉其他可能開啟的套件, 可以自行加入:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
@echo off
set Disk=y
path=%PATH%;

taskkill /IM python.exe /F
taskkill /IM pythonw.exe /F

taskkill /IM scite.exe /F

REM 終止虛擬硬碟與目錄的對應
subst %Disk%: /D
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F

EXIT
&lt;/pre&gt;

&lt;p&gt;此一隨身系統安裝配置以 &lt;a href="https://www.msys2.org/"&gt;MSYS2&lt;/a&gt; 與 &lt;a href="https://flutter.dev/"&gt;Flutter&lt;/a&gt; 較具挑戰性.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.msys2.org/"&gt;MSYS2&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先與 &lt;a href="https://www.msys2.org/"&gt;MSYS2&lt;/a&gt; 的代理主機設定位於 Y:\msys64\etc\wgetrc. 接下來為了可以編譯 C++ 程式, 必須安裝&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
pacman -S mingw-w64-x86_64-gcc
&lt;/pre&gt;

&lt;p&gt;與&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
pacman -S mingw-w64-x86_64-toolchain
&lt;/pre&gt;

&lt;p&gt;而列出 &lt;a href="https://www.msys2.org/"&gt;MSYS2&lt;/a&gt; 中所安裝的模組:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
pacman -Q
&lt;/pre&gt;

&lt;p&gt;為了編譯 [Range3], 必須額外安裝:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
pacman -S mingw-w64-x86_64-ffmpeg

pacman -S mingw-w64-x86_64-qt5

pacman -S mingw-w64-x86_64-qt5-static
&lt;/pre&gt;

&lt;h2&gt;編譯 Range3&lt;/h2&gt;
&lt;p&gt;git clone https://github.com/Range-Software/range3.git&lt;/p&gt;
&lt;p&gt;start Y:\msys64\mingw64.exe&lt;/p&gt;
&lt;p&gt;cd \y\tmp\fem_ex\range3&lt;/p&gt;
&lt;p&gt;./scripts/build.sh --clean &amp;amp;&amp;amp; ./scripts/create_package.sh&lt;/p&gt;
&lt;p&gt;而為了讓 svg 格式的 icons 能夠正確顯示, 必須納入 Qt5Svg.dll&lt;/p&gt;
&lt;h2&gt;Flutter&lt;/h2&gt;
&lt;p&gt;至於現階段 &lt;a href="https://flutter.dev/"&gt;Flutter&lt;/a&gt; 的安裝配置問題源自 &lt;a href="https://developer.android.com/studio"&gt;Android&lt;/a&gt; sdk 的最新版 tools 與最新版的 &lt;a href="https://flutter.dev/"&gt;Flutter&lt;/a&gt; 並不相容. 具體原因是: 目前的 &lt;a href="https://flutter.dev/"&gt;Flutter&lt;/a&gt; 必須使用舊版的 &lt;a href="https://developer.android.com/studio"&gt;Android&lt;/a&gt; sdk 中的舊版 tools.&lt;/p&gt;
&lt;p&gt;使用者若從 &lt;a href="https://developer.android.com/studio"&gt;Android&lt;/a&gt; 官方網站下載 tools 工具, 試圖與 &lt;a href="https://flutter.dev/"&gt;Flutter&lt;/a&gt; 配合, 將會在執行:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
flutter doctor
&lt;/pre&gt;

&lt;p&gt;時將出現 Android sdk licenses 尚未完成.  但是若再以:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
flutter doctor --android-licenses
&lt;/pre&gt;

&lt;p&gt;就會出現 Java setting 錯誤.&lt;/p&gt;
&lt;h2&gt;解決方案&lt;/h2&gt;
&lt;p&gt;處理上述 &lt;a href="https://flutter.dev/"&gt;Flutter&lt;/a&gt; 與最新版 &lt;a href="https://developer.android.com/studio"&gt;Android&lt;/a&gt; 無法相容的問題, 必須借助:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
sdkmanager --sdk_root=y:\android\sdk tools
&lt;/pre&gt;

&lt;p&gt;安裝舊版的 &lt;a href="https://developer.android.com/studio"&gt;Android&lt;/a&gt; sdk tools, 問題是 sdkmanager 工具就位於 tools 目錄中, 因此必須先將新版的 tools 目錄改名為 tools_new, 並配合將 tools_new/bin 設為 start.bat 中的 PATH, 可攜系統啟動後, 以:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
sdkmanager --sdk_root=y:\android\sdk tools
&lt;/pre&gt;

&lt;p&gt;安裝舊版的 &lt;a href="https://developer.android.com/studio"&gt;Android&lt;/a&gt; sdk tools 後, 再將 PATH 路徑改為舊版 tools/bin.&lt;/p&gt;
&lt;p&gt;之後再以&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
flutter doctor --android-licenses
&lt;/pre&gt;

&lt;p&gt;同意使用授權後, 就可以接續進行 Flutter 套件的開發.&lt;/p&gt;</content><category term="Windows"></category><category term="Portable_system"></category></entry><entry><title>倉儲資料維護與管理</title><link href="https://mde.tw/lab/blog/manage-your-cmsimde-site.html" rel="alternate"></link><published>2020-05-11T11:00:00+08:00</published><updated>2020-05-11T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-11:/lab/blog/manage-your-cmsimde-site.html</id><summary type="html">&lt;p&gt;&lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 是 2020 春季協同產品設計實習的課程網站, 而 &lt;a href="http://mde.tw/cd2020pj1"&gt;cd2020pj1&lt;/a&gt; 則是與協同設計課程相關的程式專案, 兩者都採用 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 建立網站. 其中 &lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 是典型的動態與網站架構, 而 &lt;a href="http://mde.tw/cd2020pj1"&gt;cd2020pj1&lt;/a&gt; 則除了網站還包含 Flask 協同產品設計程式的開發.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 是 2020 春季協同產品設計實習的課程網站, 而 &lt;a href="http://mde.tw/cd2020pj1"&gt;cd2020pj1&lt;/a&gt; 則是與協同設計課程相關的程式專案, 兩者都採用 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 建立網站. 其中 &lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 是典型的動態與網站架構, 而 &lt;a href="http://mde.tw/cd2020pj1"&gt;cd2020pj1&lt;/a&gt; 則除了網站還包含 Flask 協同產品設計程式的開發.&lt;/p&gt;


&lt;p&gt;當要從遠端 git clone &lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 倉儲時, 牽涉到系統使用何種協定連線, https 或 ssh?&lt;/p&gt;
&lt;p&gt;因為不同的連線協定有不同的設定檔案, 而且預計連線的主機並不一定就能提供服務, 因此能否順利完成 git clone 牽涉許多細節. 而這些細節並非一成不變, 而必須按照邏輯順序, 一一查驗才能得到期望中的結果.&lt;/p&gt;
&lt;p&gt;首先, 因為 &lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 網站的倉儲位於 https://github.com/mdecourse/cd2020.git, 其中帶有 cmsimde 子模組, 因此若要將此倉儲從遠端 git clone 到近端作為工作目錄, 最好的方式就是透過 --recurse-submodules 參數, 將子模組一起 clone 到近端.&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git clone --recurse-submodules https://github.com/mdecourse/cd2020.git
&lt;/pre&gt;

&lt;p&gt;由於 KMOLab 的課程鼓勵學員在 Windows 10 操作系統中, 使用隨身程式系統, 而不要被微軟綁定, 因為使用者必須了解所開發的程式必須能在 Mac OS X 與許多 Linux 操作系統執行, Windows 10 不應該是工程師唯一的操作系統.&lt;/p&gt;
&lt;p&gt;因此, 從隨身系統中的 start.bat 啟動後, Windows 10 就只是機械設計工程師的暫時宿主, 隨時都要準備離開, 所以啟動後必須注意所處的網路連線環境, 假如是在 IPv4 網路環境, 可以直接對 github.com 連線, 但是身處純 IPv6 網路環境中, 目前仍必須透過支援 IPv4 與 IPv6 的網路代理主機, 才能利用 git 或 ssh 對 github.com 連線.&lt;/p&gt;
&lt;p&gt;以 https 對 github.com 連線, 代理主機的設定是透過:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git config --global http.proxy=http://[2001::_your_ipv6_proxy]:3128
&lt;/pre&gt;

&lt;p&gt;假如採 ssh 對 github.com 連線, 則代理主機的設定必須檢查 putty.exe 中 github.com session 中 Connections - Proxy 的代理主機設定.&lt;/p&gt;
&lt;p&gt;一旦完成 &lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 網站倉儲的 git clone, 使用者就可以使用隨身系統中的命令列視窗, 進入 &lt;a href="http://mde.tw/cd2020"&gt;cd2020&lt;/a&gt; 倉儲中的 cmsimde 目錄, 以:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
python wsgi.py
&lt;/pre&gt;

&lt;p&gt;開啟動態網站系統, 並利用瀏覽器連線到 https://localhost:9443 進行動態網站內容的維護, 完成後再利用 generate pages 按鈕將動態網站中的 config/content.htm 轉為 content 目錄中的靜態網頁, 之後再新增, 提交, 推送到遠端, 以完成倉儲改版的流程.&lt;/p&gt;</content><category term="Github"></category><category term="CMSiMDE"></category></entry><entry><title>CMSiMDE 部署</title><link href="https://mde.tw/lab/blog/2020-lab-get-started.html" rel="alternate"></link><published>2020-05-09T11:00:00+08:00</published><updated>2020-05-09T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:mde.tw,2020-05-09:/lab/blog/2020-lab-get-started.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 所能伺服的內容包含網站, 網誌與簡報, 而網站又分為動態系統與靜態系統, 動態網站建置主要的目的在方便進行 html 文件的編輯, 而靜態網站系統則主要為了能在一般的 WWW 伺服器上進行部署. &lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 所能伺服的內容包含網站, 網誌與簡報, 而網站又分為動態系統與靜態系統, 動態網站建置主要的目的在方便進行 html 文件的編輯, 而靜態網站系統則主要為了能在一般的 WWW 伺服器上進行部署. &lt;/p&gt;


&lt;h2&gt;網站&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 的網站編輯採用 Flask 框架編寫, 目前所需要的模組包含 flask, flask_cors, lxml, bs4 與 markdown. 使用者可以選擇將 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 當作 submodule 或者單獨部署在倉儲內容中的 cmsimde 目錄後, 再將 cmsimde 目錄中的 up_dir 目錄內容複製到倉儲主目錄即可.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 倉儲資料包含引擎內容 (也就是 cmsimde 中的資料) 與使用者內容 (也就是 up_dir 中的資料) 等兩類, 許多的網際功能都是配合歷年上課時敲敲打打修改而成, 因此整體架構相當鬆散, 就所謂的網際內容管理功能而言, 只能算勉強堪用, 還有很大的修改空間.&lt;/p&gt;
&lt;h2&gt;網誌&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 的網誌系統採用 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt;, 編輯網誌的架構採用 &lt;a href="https://github.com/leo-editor/leo-editor"&gt;Leo Editor&lt;/a&gt; 管理, 而網誌專案檔位於 config 目錄中的 pelican.leo.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/leo-editor/leo-editor"&gt;Leo Editor&lt;/a&gt; 其實是一套值得大力推廣的整合開發系統與文件編輯器, 但可能因為曲高因此和寡, 真正能夠運用上手的全球用戶, 數量始終偏低. 但是其大綱編輯模式非常適合處理複雜的工程設計流程所產生的各種文字資料, 因此非常希望 Python 新手能夠以看懂 &lt;a href="https://github.com/leo-editor/leo-editor"&gt;Leo Editor&lt;/a&gt; 的設計架構與處理問題的細節作為遠大的目標.&lt;/p&gt;
&lt;h2&gt;簡報&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 的網誌簡報採用 &lt;a href="https://github.com/hakimel/reveal.js/"&gt;reveal.js&lt;/a&gt;. 而簡報的編輯檔案也是採用 &lt;a href="https://github.com/leo-editor/leo-editor"&gt;Leo Editor&lt;/a&gt;, 簡報專案位於 config 目錄中的 reveal.leo.&lt;/p&gt;
&lt;h2&gt;網站建構流程&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 的網站建構流程, 可以從建立初始的 &lt;a href="https://github.com"&gt;Github&lt;/a&gt; 倉儲開始. 亦即在 &lt;a href="https://github.com"&gt;Github&lt;/a&gt; 建立一個僅含 README.md 檔案的倉儲, 然後 git clone 該倉儲到近端後, 以命令列進入該倉儲後再以 &lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git submodule add https://github.com/mdecourse/cmsimde.git cmsimde
&lt;/pre&gt;

&lt;p&gt;將 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 倉儲內容納為子模組, 且命名為 cmsimde 目錄. 接下來將 cmsimde 目錄中, 名稱為 up_dir 的目錄內容, 複製到倉儲的根目錄中. 若近端隨身系統或操作系統已經安裝 Python3 與相應的 flask, flask_cors, lxml, bs4, markdown 等模組後, 就可以在命令列中, 進入 cmsimde 子目錄, 以:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
python wsgi.py
&lt;/pre&gt;

&lt;p&gt;假如是在 OS X 或 Linux 操作系統, 則必須使用 Python 3 指令:&lt;/p&gt;
&lt;p&gt;&lt;pre class="brush: jscript"&gt;
python3 wsgi.py
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;在近端啟動動態網站, 以瀏覽器 https://localhost:9443 開啟.&lt;/p&gt;
&lt;h2&gt;網站內容管理&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 的動態網際內容管理, 將所有網頁內容存入 config 目錄中的 content.htm 檔案, 而在每一次使用者儲存新檔案之前,  會將舊版的 content.htm 複製至 content_backup.htm, 之所以如此是因為 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 採用 &lt;a href="https://pypi.org/project/beautifulsoup4/"&gt;bs4&lt;/a&gt;, 對 config/content.htm 內容進行分頁, 而分頁是依據 content.htm 由上到下的 h1, h2 與 h3 標註內容而定. 並在將動態網站內容 content.htm 以動態編輯器中的 generate pages 功能 (使用 &lt;a href="https://pypi.org/project/lxml/"&gt;lxml&lt;/a&gt; 模組功能) 轉為 content 目錄中的各分頁內容時, 可能因分頁失敗而讓整個 content.htm 內容丟失 (這就是非常需要改進的地方之一), 所以才設計 content_backup.htm 的複製進行及時補救.&lt;/p&gt;
&lt;p&gt;另外, 在 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 將操作系統不允許作為檔案名稱的特殊符號自動移除之前 (例如 ":" 號), 使用者應該避免在 h1, h2 與 h3 等標題中使用特殊符號.&lt;/p&gt;
&lt;h2&gt;Github Pages&lt;/h2&gt;
&lt;p&gt;將 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 的動態系統轉為靜態後, 所有靜態頁面的內容存入 content 目錄, 使用者可以將此目錄內容部署到 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 上, 或其他能夠伺服 WWW html 檔案的系統即可完成網站的建立.&lt;/p&gt;
&lt;p&gt;但是一般為了方便, 通常將包含動態系統與靜態網站內容的整個倉儲資料, 直接交由 &lt;a href="https://github.com"&gt;Github&lt;/a&gt; 管理.  只要將倉儲的 master 分支設為 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 的根目錄, 就可以交由 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt;, 由倉儲主分支倉儲中的 index.html 進行網站導引.&lt;/p&gt;
&lt;p&gt;假如使用者將近端的動態網頁內容轉為靜態後, 希望在近端檢視靜態網站內容, 可以在近端倉儲根目錄利用:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
python http-server.py
&lt;/pre&gt;

&lt;p&gt;或在 OS X 及 Linux 操作系統中以:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
python3 http-server.py
&lt;/pre&gt;

&lt;p&gt;啟動 https://localhost:8444 近端的靜態網頁伺服系統.&lt;/p&gt;
&lt;h2&gt;Ubuntu 20.04 自架主機&lt;/h2&gt;
&lt;p&gt;上述利用 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 伺服 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 靜態網頁內容的配置流程非常簡單, 但若是要將 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 靜態網頁與動態網站系統部署在自架的 Ubuntu 20.04 主機, 則操作系統除了要安裝前述的 python3, flask, flask_cors, bs4, lxml, markdown 之外, 還需要運用 &lt;a href="https://nginx.org/en/"&gt;nginx&lt;/a&gt;, &lt;a href="https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html"&gt;uwsgi&lt;/a&gt;, &lt;a href="https://www.openssl.org/"&gt;openssl&lt;/a&gt; 進行配置.&lt;/p&gt;
&lt;p&gt;其中, &lt;a href="https://www.openssl.org/"&gt;openssl&lt;/a&gt; 用來建立網站認證用的 key 與 certificate, &lt;a href="https://nginx.org/en/"&gt;nginx&lt;/a&gt; 負責建立 WWW 伺服, 而 &lt;a href="https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html"&gt;uwsgi&lt;/a&gt; 則負責用來開機執行 &lt;a href="https://github.com/mdecourse/cmsimde"&gt;CMSiMDE&lt;/a&gt; 中的 wsgi.py 伺服程式.&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="https://www.openssl.org/"&gt;openssl&lt;/a&gt; 建立 cmsimde.key 與 cmsimde.crt 的指令如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout cmsimde.key -out cmsimde.crt
&lt;/pre&gt;

&lt;p&gt;與 &lt;a href="https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html"&gt;uwsgi&lt;/a&gt; 有關的 Ubuntu 系統安裝則包括:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
// 安裝 pip3
sudo apt install python3-pip
// 安裝 python 編譯開發系統
sudo apt install build-essential python3-dev
// 安裝 uwsgi 模組
sudo pip3 install uwsgi
// 安裝 nginx 伺服套件與 uwsgi python3 plugin 程式庫
sudo apt install nginx uwsgi-plugin-python3
&lt;/pre&gt;

&lt;p&gt;/etc/nginx/sites-available/default&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
# for lab.mde.tw static site, use nginx to serve
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    root /home/user_account/labmdetw;
    index index.html index.htm;
    server_name _;

    location /static {
            alias /home/user_account/labmdetw/cmsimde/static/;
        }
        location /downloads {
            alias /home/user_account/labmdetw/downloads/;
        }

        location /images {
            alias /home/user_account/labmdetw/images/;
        }

        location /blog {
            alias /home/user_account/labmdetw/blog/;
        }

        location /reveal {
            alias /home/user_account/labmdetw/reveal/;
        }

    location / {
        # First attempt to serve request as file, then
        # as directory, then fall back to displaying a 404.
        try_files $uri $uri/ =404;
    }

}

# https://lab.mde.tw use nginx to serve
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    root /home/user_account/labmdetw;
    index index.html index.htm;
    server_name _;

    location /static {
            alias /home/user_account/labmdetw/cmsimde/static/;
        }
        location /downloads {
            alias /home/user_account/labmdetw/downloads/;
        }

        location /images {
            alias /home/user_account/labmdetw/images/;
        }

        location /blog {
            alias /home/user_account/labmdetw/blog/;
        }

        location /reveal {
            alias /home/user_account/labmdetw/reveal/;
        }

    location / {
    # First attempt to serve request as file, then
    # as directory, then fall back to displaying a 404.
    try_files $uri $uri/ =404;
    }

    ssl_certificate /etc/nginx/nginx.crt;
    ssl_certificate_key /etc/nginx/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}

# dynamic https://lab.mde.tw:7443 use nginx for ssl and uwsgi for wsgi serving
server {

    listen 7443 ssl;
    listen [::]:7443 ssl;

    location /static {
        alias /home/user_account/labmdetw/cmsimde/static/;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:9443;
    }

    ssl_certificate /etc/nginx/nginx.crt;
    ssl_certificate_key /etc/nginx/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}
&lt;/pre&gt;

&lt;p&gt;uwsgi_ini/uwsgi.ini&lt;/p&gt;
&lt;pre class="brush:js;auto-links:false"&gt;
[uwsgi]
socket = 127.0.0.1:9443
uid = user_account
gid = user_account
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
master = true
process = 4
threads = 2
chdir = /home/user_account/labmdetw/cmsimde
wsgi-file = /home/user_account/labmdetw/cmsimde/wsgi.py
&lt;/pre&gt;

&lt;p&gt;啟動 uwsgi 指令, 將會逐一啟動 wsgi_ini 目錄中個別 .ini 檔案:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
sudo /usr/bin/uwsgi --emperor /home/user_account/wsgi_ini
&lt;/pre&gt;

&lt;p&gt;最後則設定 Ubuntu 系統服務, 用來啟動 uwsgi:&lt;/p&gt;
&lt;p&gt;/etc/systemd/system 的 cmsimde.service 服務啟動檔案內容:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
[Unit]
Description=uWSGI to serve CMSiMDE
After=network.target

[Service]
User=user_account
Group=user_account
WorkingDirectory=/home/user_account/uwsgi_ini
ExecStart=/usr/local/bin/uwsgi --emperor /home/user_account/uwsgi_ini

[Install]
WantedBy=multi-user.target
&lt;/pre&gt;

&lt;p&gt;接著將 cmsimde 服務設為隨系統開機啟動:&lt;/p&gt;
&lt;p&gt;sudo systemctl enable cmsimde&lt;/p&gt;
&lt;p&gt;若要取消 cmsimde 服務隨系統開機啟動:&lt;/p&gt;
&lt;p&gt;sudo systemctl disable cmsimde&lt;/p&gt;
&lt;p&gt;手動啟動 cmsimde.service 服務&lt;/p&gt;
&lt;p&gt;sudo systemctl start cmsimde&lt;/p&gt;
&lt;p&gt;手動停止 cmsimde.service 服務&lt;/p&gt;
&lt;p&gt;sudo systemctl stop cmsimde&lt;/p&gt;</content><category term="Github"></category><category term="Deployment"></category></entry></feed>