var tipuesearch = {"pages": [{'title': 'About', 'text': '這裡是國立虎尾科技大學機械設計工程系 (National Formosa University, Dept. of Mechanical Design Engineering, Taiwan)  KMOlab  所屬的網站. 主要提供與計算機程式, 網際內容管理, 電腦輔助設計與實習, 以及協同產品設計實習等課程相關資料. \n https://lab.mde.tw  是未來五年, 與  KMOlab  有關教學課程與研究方向的規劃網站,  KMOLab  是知識管理與最佳化應用實驗室 (Knowledge Management and Optimal utilization Laboratory) 的簡稱, 實驗室的目的在鼓勵技職體系學員, 透過長期的專題學習與研究履歷積累, 進行與機電資整合產品有關的設計工具開發 [ 1 ][ 2 ]. 並依此研究成果, 在國內外一流學府取得碩士以上學位. \n 網站 (Web site):  http://lab.mde.tw \n 網誌 (Web blog):  http://lab.mde.tw/blog \n 簡報 (Web presentation):  http://lab.mde.tw/reveal \n \n 網站部署 \n https://lab.mde.tw  目前部署在機械設計工程系工作站室中的  HP ProLiant  等級伺服器上, 並將倉儲與網站內容同步至  Fossil SCM  (Software Configuration Management),  Github  與  Gitlab  雲端倉儲中. \n', 'tags': '', 'url': 'About.html'}, {'title': 'Lab logo', 'text': 'KMOLab  logo images \n \n \n \n \n \n \n \n \n KMOLab  T-shirt \n \n \n \n \n', 'tags': '', 'url': 'Lab logo.html'}, {'title': '隨身程式系統', 'text': 'WCM2020_8g.7z  (登入 @gm 帳號後下載) \n KMOLab 所使用的 Windows 64 位元可攜程式系統包含下列工具: \n Python3 \n pip \n flask \n flask_cors \n lxml \n bs4 \n markdown \n leo \n sympy \n cv2 \n numpy \n scipy \n imutils \n Tiny C \n SciTE \n ShareX \n Process explorer \n Msys2 \n Solvespace \n Pyslvs-UI \n CoppeliaSim \n Webots \n Range3 \n GIMP \n Inkscape \n Dia \n OBS \n Dart sdk \n Flutter sdk \n Visual studio code \n Virtualbox \n Ubuntu \n Sketchbook', 'tags': '', 'url': '隨身程式系統.html'}, {'title': 'Github', 'text': 'Git Commands \n git add . \n git commit -m "commint message" \n git push \n git clone \n git clone --recurse-submodules url_of_repo \n git status \n git checkout \n git submodule add url_of_repo local_directory \n git submodule init \n git submodule update --recursive \n git branch \n git pull \n git merge \n git remote add name url_of_repo \n Github Pages \n Github Pages  為 Github 所提供的倉儲內容網頁伺服器. 使用者可以將倉儲主分支, gh-pages 分支或 docs 目錄中的 HTML, 利用 Github Pages 設定, 轉為以使用者帳號及倉儲名稱所組成的網站. \n 例如: 將 github_account 中名稱為 repo 的倉儲內容設為 Github Pages 網站後, 其網址為:  https://github_account.github.io/repo . \n 若使用者設為 Girhub Pages 之倉儲名稱為 github_account.github.io, 則所設定的 Github Pages 網站名稱將為: \n https://github_account.github.io \n Github SSH \n 使用者從近端將工作目錄中的資料推送到 Github, 可以選擇 Https 或 SSH 連線協定. \n 使用者提交 Github 倉儲內容改版之前, 必須利用 git config 進行身份與代理主機的設定. \n git config --edit --system \n git config --global user.name "github_account" \n git config --global user.email "your_github_account _register email" \n git config --global http.proxy=http://proxy_server:3128 \n 若設 IPv6 主機則使用: \n git config --global http.proxy=http://[2001::ip_address]:3128 \n --global 表示要存擋到啟動隨身碟 home 目錄中的 .gitconfig 設定檔 \n 若 git config 不使用 --global 表示該設定僅此命令 session 有效. \n 假如要在 Windows 10 操作系統中, 將倉儲設定使用 SSH 網路協定推送, 則需完成下列步驟: \n 1. 下載 Putty 工具組 \n 從\xa0 https://www.chiark.greenend.org.uk/~sgtatham/putty/ \xa0 下載一般版, 或從 \xa0 http://jakub.kotrla.net/putty/ \xa0 下載特殊的可攜版本. \n 2. 利用 y:\\portablegit\\bin\\sh.exe 進入 shell 命令環境後, 以  \n ssh-keygen -t rsa -b 4096 -C "使用者學號" \n 在 /y/home/.ssh 目錄下建立 id_rsa 與 id_rsa.pub 等 private key 與 public key \n 之後以 SciTE 開啟 id_rsa.pub 後, 將此 public key 的內容, 以新增添加到 Github.com 帳號下 personal settings -> SSH and GPG keys 頁面下. \n 3. 接下來要利用 puttygen.exe 將 id_rsa 轉為 Putty 可以解讀的 .ppk 格式, 並修改隨身系統的啟動批次檔案, 指定利用 putty 目錄下的 plink 執行 git 指令的網路代理設定. \n 修改啟動的 start.bat 加入下列設定: \n set GIT_HOME=%Disk%:\\portablegit\\bin\\\nset GIT_SSH=%Disk%:\\putty\\plink.exe \n \n \n \n 4. 利用 puttygen.exe 載入第二步驟所建立的 private key, 也就是 id_rsa. \n 開啟 puttygen 之後, 以右下方的 load 載入 id_rsa, 成功載入後, 利用 save private key 按鈕, 將已經轉為 putty 格式的 .ppk 存檔. 此一 .ppk 檔案必須在設定 putty 中 github.com session 時, 在 Connection->SSH->Auth 項目下, 將轉檔後的 .ppk 指向 private key file for authentication 欄位.\xa0 \n 並在 Connection->Proxy 項目下, 指定 Proxy type: HTTP, 並將 IPv6 代理主機設為 ::53 或 ::42 埠號設為 3128. \n 5. 之後確定 home 下的 .ssh 目錄中的 config 設定檔案為: \n # no proxy at home\n#ProxyCommand y:/PortableGit/mingw64/bin/connect.exe -H proxy.mde.nfu.edu.tw:3128 %h %p\n# set git_ssh=y:/putty/plink.exe with auth under putty github.com session setup\nProxyCommand y:/putty/plink.exe github.com %h %p\n  \nHost github.com\n    User git\n    Port 22\n    Hostname github.com\n     \n    # for connect.exe need openssh key format\n    #IdentityFile "y:\\home\\.ssh\\id_rsa_mdecourse"\n    # for plink.exe need rsa key format but set under putty github.com session\n    # plink.exe do not need the following setting\n    #IdentityFile "y:\\home\\.ssh\\mdecourse_putty_private.ppk"\n  \n    TCPKeepAlive yes\n    IdentitiesOnly yes \n \n \n \n 6. 最後再將 wcmj2020 倉儲中 .git 目錄下的 config 檔案中的連線協定, 由 https 改為採 ssh 連線: 範例如下: \n [core]\n    repositoryformatversion = 0\n    filemode = false\n    bare = false\n    logallrefupdates = true\n    symlinks = false\n    ignorecase = true\n[submodule]\n    active = .\n[remote "origin"]\n    #url = https://github.com/mdecourse/wcmj2020.git\n    url = git@github.com:mdecourse/wcmj2020.git\n    fetch = +refs/heads/*:refs/remotes/origin/*\n[branch "master"]\n    remote = origin\n    merge = refs/heads/master\n[submodule "cmsimde"]\n    url = https://github.com/mdecourse/cmsimde.git \n \n \n \n 之後就可以透過近端的 .ppk private key 與 Github.com 上的 public key 對應, 無需輸入帳號密碼就可以進行 git push.', 'tags': '', 'url': 'Github.html'}, {'title': 'Virtualbox', 'text': 'Ubuntu 20.04 for cd2020pj1.ova  ( W12 version)  (for @gm users only) \n Win10 comsol5.ova  (for @gm users only) \n Ｕbuntu 20.04 安裝 Chrome \n sudo apt install gdebi-core wget \n wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb \n sudo gdebi google-chrome-stable_current_amd64.deb \n google-chrome \n \xa0因為 Ubuntu 中的 Chrome 使用操作系統中的 Proxy 設定, 若採 IPv6 Proxy 使用 fe80::1 格式, 且無需前後加上中括號. 但若修改系統 Proxy 設定後, Chrome 必須重新啟動後才可生效.', 'tags': '', 'url': 'Virtualbox.html'}, {'title': 'Pyslvs', 'text': 'https://github.com/KmolYuan/Pyslvs-UI \n https://www.pyslvs.com/ \n 論壇:  https://gitter.im/pyslvs-ui/forum \n', 'tags': '', 'url': 'Pyslvs.html'}, {'title': 'Fossil SCM', 'text': 'http://mde.tw/cp2019/content/Fossil%20SCM.html \n Fossil SCM 是一套軟體組態管理 (Software Configuration Management) 系統, 其中包含分散式版次控管 (DVC, Distributed Version Control) 、Wiki 、Forum、Bug Tracking 與 Technote 等功能, 可以用來控制及追蹤軟體開發專案, 並且紀錄專案開發歷程. \n 安裝 Fossil SCM \n Windows \n 從  https://fossil-scm.org/home/uv/download.html  下載 Windows 64 位元 2.11 版, 解開壓縮檔案, 將 fossil.exe 放入隨身程式系統的 Y:\\ 即可在命令列利用: \n fossil version \n 查詢版本. \n MacOS \n 從  https://fossil-scm.org/home/uv/download.html  下載 MacOS 版本後, 自動解開壓縮取得 fossil 可執行檔案後, 以 env 查詢 PATH 路徑設定, 可以利用: \n cd \n cd Downloads \n sudo mv fossil /opt/local/bin \n 先更換目錄到帳號 home 之後, 進入 Downloads 目錄, 將 fossil 放到 /opt/local/bin 目錄中, 接著就可以利用: \n fossil version \n 查詢版本. \n 但若該 fossil 並沒有經由 Apple 公證 (notarized), 則必須至 System Preferences - Security & Privacy - General 中, 針對 "fossil" was blocked from use because it is not from an identified developer 項目, 選擇 "Allow Anyway". \n 截至 2020.05.23, Fossil SCM 的 MacOS 2.11 與 2.10 版都未經過 Apple 公證. \n Ubuntu \n 從  https://fossil-scm.org/home/uv/download.html  下載 Linux X64 版本後, 解開壓縮檔案後, 將 fossil 放到 /usr/bin 目錄後, 即可利用: \n fossil version \n 查詢版本. \n 或者利用 sudo apt install fossil 安裝. \n', 'tags': '', 'url': 'Fossil SCM.html'}, {'title': '配置 Fossil SCM', 'text': 'Ubuntu \n sudo apt install fossil stunnel \n 在 /etc/environment 檔案中加入: \n HTTPS=on \n 在 /etc/default/stunnel4 檔案中加入 \n ENABLED=1 \n 利用 \n sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout stunnel.key -out stunnel.crt \n 在 /etc/stunnel 目錄中建立 stunnel.key 與 stunnel.crt \n 接著建立 /etc/stunnel/stunnel.conf \n [https]\naccept=kmol2020:5443\naccept=:::5443\ncert=/etc/stunnel/stunnel.crt\nkey=/etc/stunnel/stunnel.key\nexec=/usr/bin/fossil\nexecargs=/usr/bin/fossil http /home/kmol2020/repository/ --https --nojail --notfound kmol2020 \n 在 /home/kmol2020/ 建立 repository 目錄, 以及 kmol2020.fossil 後, 以 /etc/init.d/stunnel4 restart 重新啟動伺服器. \n 管理者可以從  https://[::1]:5443  登入.', 'tags': '', 'url': '配置 Fossil SCM.html'}, {'title': '計算機程式', 'text': '計算機程式是工程師解決問題的工具之一, 而工程師希望利用計算機程式解決問題之前需要對電腦與其周遭環境相關的事項有所了解 \n 電腦基本軟硬體術語及功能 \n 電腦網路設定與應用 \n 電腦程式語言: \n Javascript \n Javascript course note.pdf \n https://javascript.info/ \n https://www.khanacademy.org/computing/computer-programming \n C \n https://modernc.gforge.inria.fr/  ( Modern C.pdf ) \n http://karadev.net/uroci/filespdf/files/Programming-in-ANSI-C.pdf  ( Programming-in-ANSI-C.pdf) \n Dart \n https://en.wikipedia.org/wiki/Dart_(programming_language) \n https://dartpad.github.io \n https://flutter.dev/web \n Python \n http://do1.dr-chuck.com/pythonlearn/EN_us/pythonlearn.pdf \n Python-for-everyone.pdf \n 資料結構 \n https://opendatastructures.org/ods-cpp.pdf  (C++) \n https://www.cs.auckland.ac.nz/compsci105s1c/resources/ProblemSolvingwithAlgorithmsandDataStructures.pdf \n 利用資料結構與演算法解題.pdf  (Python) \n', 'tags': '', 'url': '計算機程式.html'}, {'title': 'ＷＷＷ網頁', 'text': '你需要一個 World Wide Web Page, 帶有分門別類的標題與內容, 能夠紀錄日誌, 可以直接在瀏覽器上進行簡報, 無論是在廣域網路, 區域網路或單一電腦上. \n CMSiMDE  就是因應機械設計工程師需要建立上述 \n 網頁 (Web Page) \n 簡報 (Web Presentation) \n 網誌 (Web Blog) \n 而拼拼湊湊成的一套系統. \n', 'tags': '', 'url': 'ＷＷＷ網頁.html'}, {'title': 'Javascript', 'text': '一般建議是將 Javascript 放在 </body> 標註之前, 也就是所有頁面內容的最後面, 因為這樣會讓瀏覽用戶先看到整個頁面內容之後, 再下載執行頁面所需的 Javascript, 如此, 使用者會"感覺"頁面的資料擷取順暢, 不會頁面載入到中途, 因下載或執行 Javascript 程式碼而停頓. \n Beginning JavaScript (2019) \n https://link.springer.com/book/10.1007/978-1-4842-4395-4 \n for (var i=0; i<10; i++)\n    // 將原本列在 console 區的資料導引到下列程式執行輸出區\n    console.log(i + ": Hello, 開始學習 Javascript!"); \n 下列範例,\xa0 以\xa0 https://www.arc.id.au/CanvasGraphics.html \xa0繪圖程式庫中的程式碼為例. \n \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n<script type="text/javascript" src="./../cmsimde/static/ace/mode-python3.js"></script>\n<script type="text/javascript" src="./../cmsimde/static/ace/snippets/python.js"></script>\n \n  嘗試直接使用 ace.js 編寫 Javascript  \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["js_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n Filename:  .js   \n Run Output 清除輸出區 清除繪圖區 清除 html 區 Reload \n \n ROC Flag Plot Sin Plot Cos Excavator   Read Stud List Bouncing Ball Edit Curve Group Drag Involute Gear Gear Meshing Internal Gear Three.js Cube Canvas Draw Line \n \n \n', 'tags': '', 'url': 'Javascript.html'}, {'title': 'JQuery', 'text': 'JQuery 起源於  https://johnresig.com/blog/selectors-in-javascript/,  展示透過 CSS Selector 可以與 Javascript 的元件互動. \n CSS \n Document Object Model (DOM) \n Javascript elements', 'tags': '', 'url': 'JQuery.html'}, {'title': 'Html', 'text': '', 'tags': '', 'url': 'Html.html'}, {'title': 'Canvas', 'text': '', 'tags': '', 'url': 'Canvas.html'}, {'title': 'Dart', 'text': '下列影片說明如何利用 Javascript 建立按鈕, 讓\xa0 https://dartpad.github.io \xa0可以直接帶出存放在  downloads  目錄中的 Dart 程式範例. 所引用的程式包含 純 Dart 程式碼 , 包含 html 與 css 的 網際程式碼 , 以及  flutter 程式碼 等三種. \n \n  透過 getDart(dirname) 取位於 downloads/dart_ex/ 目錄中 dirname 目錄中的 Dart 程式碼  \n \n  取 Dart 程式的按鈕  \n 純 Dart 程式 \n Hello   For Loop   Sum   Runge-Kutta   RK ex1   Mass Spring Damping   Function   Function Parameter   Fat Arrow   Temp 1 \n Html 程式 \n 亂數分組   ROC Flag   rot ROC   USA Flag   Grid   X-Y Plot   Slithery   Tetris \n Flutter 程式 \n Flutter0   Flutter1   Flutter2   Flutter3   Flutter4   Flutter Counter   ROC Flag   踩地雷 1   踩地雷 2   踩地雷 3   踩地雷 4   Dropdown   Multiselect   Search   Login   溫度轉換   Tic-Tac-Toe   Calculator   Mouse1   Paint1 \n  內建放入的 Dart 原始碼  \n 放大   回復 \n', 'tags': '', 'url': 'Dart.html'}, {'title': 'WebGL', 'text': '', 'tags': '', 'url': 'WebGL.html'}, {'title': '學號抽點', 'text': '為了編寫能夠進行修課學員學號抽點的程式, 提出下列兩種可行方案: \n 將原本按照順序排列的學號次序弄亂, 然後按所需抽點的人數,\xa0 從已經弄亂的學號中一一取出 \n 依據所要抽點的人數, 建立一個由亂數組成的資料,\xa0 然後從順序排列的學號中抽出所要 \n 抽點的目的 \n 查核學員學習情況 \n 讓抽點學員回報學習狀況 \n 交付任務, 要求抽點出的學員執行任務, 並交付報告', 'tags': '', 'url': '學號抽點.html'}, {'title': '亂數分組', 'text': 'evenGrouping.dart \n import \'dart:html\';\n  \n  InputElement studListUrl = querySelector("#studListUrl");\n  String studUrl;\n  // 將 Label 改為 Textarea, 避免產生過程結果嵌入所在頁面\n  TextAreaElement output = querySelector("#output");\n  \nmain() {\n  querySelector("#submit").onClick.listen((e) => grouping());\n}\n  \ngrouping() {\n  output.innerHtml = "";\n  \n  if (studListUrl.value != "") {\n    studUrl = studListUrl.value;\n  } else {\n    studUrl = \'https://mde.tw/group/downloads/2019fall_cp_1a_list.txt\';\n  }\n  \n  // 組序由 1 開始\n  int gth = 1;\n  // 迴圈序號變數\n  int i;\n  int j;\n  int total;\n  int inc;\n  // 每組學員暫存數列\n  var gpList = [];\n  // 全班分組數列\n  var group = [];\n  // 各組人數數列\n  var numList = [];\n  var courseTitle = \'cd2020\';\n  \n  HttpRequest.getString(studUrl).then((String resp) {\n    // 利用 trim() 去除字串最後的跳行符號, 之後再利用 split() 根據 \\n 轉為數列\n    var studList = resp.trim().split("\\n");\n    // 數列利用 shuffle() 方法以隨機方法弄亂順序\n    studList.shuffle();\n    total = studList.length;\n    output.text += "全班總計" + total.toString() + " 人\\n";\n    numList = getNumList(studList.length);\n    inc = 0;\n    for (i in numList){\n      // 列印區隔符號\n      output.text += \'=\' * 20 + "\\n";\n      output.text += "group $gth 有 " + i.toString() + " 人: \\n";\n      gpList = [];\n      for (j = 0; j < i; j++){\n        output.text += studList[j+inc] + "\\n";\n        // 在各分組數列中加入將對應的學員學號\n        gpList.add(studList[j+inc]);\n      }\n      gth = gth + 1;\n      inc = inc + j;\n        //output.text += studList[j] + "\\n";\n        // 逐步將各組暫存的分組數列加入全班分組數列中\n      gpList.sort();\n      group.add(gpList);\n    }\n    // 列出全班分組數列\n    output.text += group.toString() + "\\n";\n    // 列出已經排序後的分組名單\n    output.text += \'=\' * 25 + "\\n";\n    output.text += \'以下為排序後的各組成員名單: \\n\';\n    gth = 1;\n    /*\n    404231\n    s4052\n    4062\n    s4072\n    4082\n    5072\n    5083\n    */\n    // 先列出純文字以 \\n 跳行組員資料\n    for (i=0; i < group.length; i++){\n      // 列印區隔符號\n      output.text += \'=\' * 20 + "\\n";\n      output.text += "group $gth \\n";\n      gpList = [];\n      for (j=0; j < group[i].length; j++){\n        output.text += group[i][j] + "\\n";\n      }\n      gth = gth + 1;\n    }\n     \n    gth = 1;\n    // 最後列出超文件以 <br\\> 跳行組員資料, 包含倉儲與網站\n    for (i=0; i < group.length; i++){\n      // 列印區隔符號\n      output.text += \'\\n\' + \'=\' * 30 + "<br \\>";\n      output.text += "group $gth <br \\>";\n      gpList = [];\n      for (j=0; j < group[i].length; j++){\n          if (group[i][j].startsWith(\'4052\') || group[i][j].startsWith(\'4072\')) {\n              output.text += "Repository: <a href=\'https://github.com/s" + \n                                      group[i][j] + "/" + courseTitle + "\'>" + group[i][j] + \n                                      "</a>" + " | Site: <a href=\'https://s" + group[i][j] + \n                                      ".github.io/" + courseTitle + "\'>" + group[i][j] + \n                                      "</a><br \\>";\n          }\n          else {\n              output.text += "Repository: <a href=\'https://github.com/" + \n                                      group[i][j] + "/" + courseTitle +"\'>" + group[i][j] + \n                                      "</a>" + " | Site: <a href=\'https://" + group[i][j] + \n                                      ".github.io/" + courseTitle + "\'>" + group[i][j] + \n                                      "</a><br \\>";\n          }\n      }\n      gth = gth + 1;\n    }\n  });\n}\n  \nList getNumList(int total){\n  // total student number\n  // int total = 65;\n  // initial each group expect to be "eachGrp" number of people\n  int eachGrp = 10;\n  // may divide into "grpNum" number of group\n  int grpNum = total ~/ eachGrp;\n  // vacant list\n  var splits = [];\n  // find remainder when total number divid into "grpNum" number of group\n  int remainder = total % grpNum;\n  // number of people in one group by calculation\n  int calGrp = total ~/ grpNum;\n  \n  for (int i = 0; i < grpNum; i++) {\n    splits.add(calGrp);\n  }\n  //print(splits);\n  \n  for (int i = 0; i < remainder; i++) {\n    splits[i] += 1;\n  }\n  //print(splits);\n  return splits;\n } \n index.html \n <h1>亂數分組:</h1>\n學員名單 URL: <input type="text" id="studListUrl" size="50" value="https://mde.tw/wcm2020/downloads/2020spring_wcm_1a_list.txt"><br />\n<input type="submit" value="開始分組" id="submit"><br />\n<textarea id="output" cols="80" rows="10"></textarea> \n style.css \n body {\n  color: white;\n  font-size: 20px;\n}\n \ninput, select, textarea {\nfont-size: 100%;\n} \n get_student.py \n from flask import Flask, request \nfrom flask_cors import CORS\n \nimport requests\nimport bs4\nimport ssl\n \n\'\'\'\nhttps://s1.mde.nfu.edu.tw:7443/?semester=1082&courseno=0767\ncd\n2a 1082/0767\n2b 1082/0780\n \n2a 1072/0777\n2b 1072/0790\n2a 1062/0788\n2a 1062/0802\n \nwcm\n1082/0744\n \n1072/0754\n1062/0765\n \nwcmj\n1082/2418\n\'\'\'\n \napp = Flask(__name__)\nCORS(app)\n \n@app.route(\'/studlist\')\n@app.route(\'/\')\ndef studlist():\n    semester = request.args.get(\'semester\')\n    courseno = request.args.get(\'courseno\')\n    if semester == None:\n        semester = \'1082\'\n    if courseno == None:\n        courseno = \'0744\'\n     \n    url = \'https://osa.nfu.edu.tw/query/studlist_ajax.php\'\n    post_var = {\'pselyr\': semester, \'pseqno\': courseno}\n \n    result = requests.post(url, data = post_var)\n \n    soup = bs4.BeautifulSoup(result.content, \'lxml\')\n    table = soup.find(\'table\', {\'class\': \'tbcls\'})\n    data = []\n    rows = table.find_all(\'tr\')\n    for row in rows:\n        cols = row.find_all(\'td\')\n        cols = [ele.text.strip() for ele in cols]\n        data.append([ele for ele in cols if ele]) # Get rid of empty values\n    output = ""\n    for i in data[2:]:\n        #print(i[0])\n        output +=i[0] + "\\n"\n    return output\n    #return  str(pselyr) + " + " +str(pseqno)\n \n# 即使在近端仍希望以 https 模式下執行\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\ncontext.load_cert_chain(\'localhost.crt\', \'localhost.key\')\n \n# 取 flaskapp.py 中的 uwsgi 變數設定\nuwsgi = False\nif uwsgi:\n    # 表示程式在雲端執行\n    application = app\nelse:\n    # 表示在近端執行, 以 python3 wsgi.py 執行\n    app.run(host=\'127.0.0.1\', port=5443, debug=True, ssl_context=context) \n nginx sites-available/default settings: \n server {\n    listen 8000;\n    server_name s1.mde.nfu.edu.tw;\n    charset utf-8;\n     \n    listen 7443 ssl;\n  \n    location /static {\n        alias /home/kmol2019/course_studlist/static/;\n    }\n  \n    location / {\n        include uwsgi_params;\n        uwsgi_pass  127.0.0.1:8087;\n    }\n     \n    ssl_certificate /etc/stunnel/localhost.crt;\n    ssl_certificate_key /etc/stunnel/localhost.key;\n    ssl_session_timeout 5m;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";\n    ssl_prefer_server_ciphers on;\n    try_files $uri $uri/ =404;\n} \n uwsgi7.ini \n uwsgi]\nsocket = 127.0.0.1:8087\nuid = kmol2019\ngid = kmol2019\nplugins-dir = /usr/lib/uwsgi/plugins/\nplugin = python3\nmaster = true\nlogto = /var/log/uwsgi/emperor.log\nlogfile-chown = kmol2019:kmol2019\nprocesses = 4\nthreads = 2\nchdir = /home/kmol2019/course_studlist\nwsgi-file = /home/kmol2019/course_studlist/get_student.py \n /etc/systemd/system/cmsimfly.service \n [Unit]\nDescription=uWSGI to serve CMSimfly\nAfter=network.target\n \n[Service]\nUser=kmol2019\nGroup=kmol2019\nWorkingDirectory=/home/kmol2019/uwsgi_ini\nExecStart=/usr/local/bin/uwsgi --emperor /home/kmol2019/uwsgi_ini\n \n[Install]\nWantedBy=multi-user.target \n random_select.dart \n import \'dart:html\';\nimport \'dart:convert\';\n \nSelectElement studListUrl = querySelector("#RstudListUrl");\nString grpList;\nInputElement numOfStud = querySelector("#RnumOfStud");\nint num;\n// 將 Label 改為 Textarea, 避免產生過程結果嵌入所在頁面\nTextAreaElement output = querySelector("#Routput");\n \nmain() {\n  querySelector("#Rsubmit").onClick.listen((e) => randomSelect());\n}\n \nrandomSelect() {\n  output.innerHtml = "";\n \n  if (studListUrl.value != "") {\n    grpList = studListUrl.value;\n  } else {\n    grpList = \'https://mde.tw/cd2020/downloads/2a_group_list.txt\';\n  }\n \n  if (numOfStud.value != "") {\n    num = int.parse(numOfStud.value);\n  } else {\n    num = 2;\n  }\n \n  HttpRequest.getString(grpList).then((String resp) {\n    final replaced = resp.replaceAll("\'", \'\');\n    List studList = jsonDecode(replaced);\n    for (int i = 0; i < studList.length; i++) {\n      // shuffle studList element\n      studList[i].shuffle();\n      // draw num of member from each group\n      output.text += "-" * 20 + "\\n";\n      for (int j = 0; j < num; j++) {\n        output.text += "group ${i + 1}:" + studList[i][j].toString() + "\\n";\n      }\n    }\n  });\n} \n index.html \n <h1>每組隨機抽選:</h1>\n學員名單 URL: \n<select id="RstudListUrl">\n  <option value="https://mde.tw/cd2020/downloads/2a_group_list.txt" selected>2a</option>\n  <option value="https://mde.tw/cd2020/downloads/2b_group_list.txt">2b</option>\n</select><br />\n每組抽選人數: <input type="text" id="RnumOfStud" size="2" value="1"><br />\n<input type="submit" value="開始" id="Rsubmit"><br />\n<textarea id="Routput" cols="80" rows="10"></textarea> \n main.css \n body {\n  color: white;\n  font-size: 20px;\n}\n \ninput, select, textarea {\nfont-size: 100%;\n} \n 利用 Python 進行亂數分組: \n randomw6.py \n import random\nimport requests\n \n# getNumList 主要在每組最低人數下, 將不足 10 人的分組\n# 平均分配至各組\ndef getNumList(total, eachGrp=10):\n    # total is the number of students\n    # each group at least 10 students\n    #eachGrp = 10;\n    # may divide into "grpNum" number of group\n    grpNum = total // eachGrp;\n    # check grpNum\n    #print(grpNum)\n    # vacan list\n    splits = []\n    # find remainder when total number divid into "grpNum" number of group\n    remainder = total % grpNum\n    # number of people in one group by calculation\n    calGrp = total // grpNum\n     \n    for i in range(grpNum):\n        splits.append(calGrp)\n         \n    # check first splits\n    #print(splits)\n   \n    for i in range(remainder):\n        splits[i] += 1\n     \n    # check final splits\n    #print(splits);\n    return splits;\n \n# 儲存學生名單資料的 url\ntarget_url = "http://mde.tw/cd2020/downloads/2020spring_cd_2a_list.txt"\n# 利用 requests 讀取 url 中的資料\nf = requests.get(target_url)\n# get student list from target_url\n# 利用 splitlines() 將資料放入數列 studList\nstudList = f.text.splitlines()\n# 每組預計分組的最低人數\nnum_in_one_group = 10\n# 每組學員暫存數列\ngpList = []\n# 全班分組數列\ngroup = []\n# 各組人數數列\nnumList = []\n# get numList\nnumList = getNumList(len(studList), num_in_one_group)\n# check numList\n# 列出已經補齊的各組人數數列\nprint("預計各組人數數列:" + str(numList))\n \noutput = ""\ngth = 1\ninc = 0\n \n# 弄亂 studList\nrandom.shuffle(studList)\noutput += "以下為尚未排序前的各組學員學號: \\n"\nfor i in numList:\n    # 列印區隔符號\n    output += \'=\' * 20 + "\\n";\n    output += "group " + str(gth) + " 有 " + str(i) + " 人: \\n"\n    # 每組學員暫存數列, 在此 reset\n    gpList = []\n    for j in range(i):\n        output += studList[j+inc] + "\\n"\n        # 在各分組數列中加入將對應的學員學號\n        gpList.append(studList[j+inc])\n       \n    gth = gth + 1\n    inc = inc + j\n    # 將各組學員數列依照學號排序\n    gpList.sort()\n    group.append(gpList)\n \n# 列出尚未排序前的分組結果\nprint(output)\n# 列出已經完成排序的分組數列\nprint("已經排序後的分組數列:" + str(group))\n \noutput = ""\n# 列出已經排序後的分組名單\noutput += \'=\' * 25 + "\\n"\noutput += \'以下為排序後的各組成員名單:\\n\'\ngth = 1\n \n# 先列出純文字以 \\n 跳行組員資料\nfor i in range(len(group)):\n    # 列印區隔符號\n    output += \'=\' * 20 + "\\n"\n    output += "group" + str(gth) + "\\n"\n    gpList = []\n     \n    for j in range(len(group[i])):\n        output += str(group[i][j]) + "\\n"\n       \n    gth = gth + 1\n     \nprint(output) \n', 'tags': '', 'url': '亂數分組.html'}, {'title': '隨機與基因演算', 'text': 'http://lab.kmol.info/blog/2015-cadp-w16.html \n https://github.com/DEAP/deap \n A genetic algorithm for bin packaging.pdf \n An_Efficient_Algorithm_for_3D_Rectangular_Box_Packing.pdf \n RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算. \n # https://github.com/flukeskywalker/PyRGA\n# 原始程式為 Python2 修改為 Python3 格式\n# 除了原先的最大化適應值外, 增加最小化方法設定\nimport numpy as np\nimport random\nimport math\n\n# 請注意各代族群數必須為 4 的倍數\nclass GA: # popsize must be multiple of 4\n    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):\n        self.EPSILON = 10e-6\n        self.INFINITY = 10e6\n        self.pop = []\n        self.fits = []\n        self.obj = obj\n        self.dim = dim\n        self.popsize = popsize\n        self.ngen = ngen\n        self.pc = pc\n        self.pm = pm\n        self.etac = etac\n        self.etam = etam\n        # min = 1 表最小化, min = -1 表最大化\n        self.min = min\n        self.RIGID = 0\n        self.lowb = -self.INFINITY*np.ones(self.dim)\n        self.highb = self.INFINITY*np.ones(self.dim)\n        self.tourneylist = range(0, self.popsize)\n        self.tourneysize = 2 # works for 2 for now\n        self.bestmemyet = np.zeros(self.dim)\n        # 若是求最大值\n        if self.min == -1:\n            self.bestfityet = -np.inf\n        else:\n        # 若是求最小值\n            self.bestfityet = np.inf\n        self.pop_init()\n\n    def pop_init(self):\n        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]\n        for member in self.pop:\n            for i in range(self.dim):\n                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])\n        self.fits = [self.obj(member) for member in self.pop]\n        #self.pop_print()\n        return\n\n    def setbounds(self, lows, highs):\n        for i in range(self.dim):\n            self.lowb[i] = lows[i]\n            self.highb[i] = highs[i]\n        self.pop_init()\n        return\n\n    def run(self):\n        for gen in range(self.ngen):\n            print("Generation ", gen)\n            self.pop = self.getnewpop()\n            self.eval_pop()\n            #self.pop_print()\n        return [self.bestmemyet, self.bestfityet]\n\n    def getnewpop(self):\n        newpop = []\n        #self.tourneylist = range(0, self.popsize)\n        random.shuffle(list(self.tourneylist))\n        self.tourneypos = 0\n        for i in range(0, self.popsize, 2):\n            [p1, p2] = self.getparents() #return parents, not just indices\n            [c1, c2] = self.xover(p1, p2) #return children, not just indices\n            c1 = self.mutate(c1)\n            c2 = self.mutate(c2)\n            newpop.append(c1)\n            newpop.append(c2)\n        return newpop\n\n    def getparents(self):\n        if (self.popsize - self.tourneypos) < self.tourneysize:\n            random.shuffle(list(self.tourneylist))\n            self.tourneypos = 0\n        if self.min == -1:\n            if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):\n                p1 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p1 = self.pop[self.tourneylist[self.tourneypos+1]]\n        else:\n            if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):\n                p1 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p1 = self.pop[self.tourneylist[self.tourneypos+1]]\n        self.tourneypos += self.tourneysize\n\n        if self.min == -1:\n            if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):\n                p2 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p2 = self.pop[self.tourneylist[self.tourneypos+1]]\n        else:\n            if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):\n                p2 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p2 = self.pop[self.tourneylist[self.tourneypos+1]]\n        self.tourneypos += self.tourneysize\n        return [p1, p2]\n\n    def xover(self, p1, p2): # Here p1 and p2 are pop members\n        c1 = np.zeros_like(p1)\n        c2 = np.zeros_like(p2)\n        if random.random()<=self.pc: # do crossover\n            for i in range(p1.size):\n                if random.random()<0.5: # 50% variables crossover\n                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])\n                else:\n                    [c1[i], c2[i]] = [p1[i], p2[i]]\n        else:\n            c1 = p1\n            c2 = p2\n        return [c1, c2]\n\n    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables\n        if p1>p2:\n            p1, p2 = p2, p1 # p1 must be smaller\n        mean = (p1+p2)*0.5\n        diff = (p2-p1)\n        dist = max(min(p1-low, high-p2), 0)\n        if (self.RIGID and diff > self.EPSILON):\n            alpha = 1.0 + (2.0*dist/diff)\n            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))\n            seed = umax*random.random()\n        else:\n            seed = random.random()\n        beta = self.getbeta(seed)\n        if (abs(diff*beta) > self.INFINITY):\n            beta = self.INFINITY/diff\n        c2 = mean + beta*0.5*diff\n        c1 = mean - beta*0.5*diff\n        c1 = max(low, min(c1, high))\n        c2 = max(low, min(c2, high))\n        return [c1, c2]\n\n    def getbeta(self, seed):\n        if (1 - seed) < self.EPSILON:\n            seed = 1 - self.EPSILON\n        seed = max(0.0, seed)\n        if seed < 0.5:\n            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))\n        else:\n            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))\n        return beta\n\n    def getdelta(self, seed, delta_low, delta_high):\n        if seed >= 1.0 - (self.EPSILON/1e3):\n            return delta_high\n        if seed <= (self.EPSILON/1e3):\n            return delta_low\n        if seed <= 0.5:\n            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))\n            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0\n        else:\n            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))\n            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))\n        return delta\n\n    def mutate(self, member):\n        mut_member = np.zeros_like(member)\n        for i in range(member.size):\n            low = self.lowb[i]\n            high = self.highb[i]\n            if random.random() <= self.pm: # pm is simply the prob of a variable to mutate\n                if self.RIGID:\n                    value = member[i]\n                    delta_low = max((low-value)/(high-low), -1.0)\n                    delta_high = min((high-value)/(high-low), 1.0)\n                    if abs(delta_low)<abs(delta_high):\n                        delta_high = -delta_low\n                    else:\n                        delta_low = -delta_high\n                else:\n                    delta_low = -1.0\n                    delta_high = 1.0\n                seed = random.random()\n                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)\n                mut_member[i] = max(low, min(member[i] + delta, high))\n            else:\n                mut_member[i] = member[i]\n        return mut_member\n\n    def eval_pop(self):\n        self.fits = [self.obj(member) for member in self.pop]\n        # 若是最大化適應值題目者\n        if self.min == -1:\n            # 將所有適應值中最大者, 指向 bestindex\n            bestindex = np.argmax(self.fits)\n        else:\n            # 將所有適應值中最大者, 指向 bestindex\n            bestindex = np.argmin(self.fits)\n        bestmember = self.pop[bestindex]\n        bestfitness = self.fits[bestindex]\n        # self.min = -1 for maximization, self.min = 1 for minimization\n        if self.min == -1:\n            # 若是在族群中的最佳適應值大於目前為止最佳的適應值\n            if bestfitness > self.bestfityet:\n                # 則將此最大適應值指為目前為止最佳適應值\n                self.bestfityet = bestfitness\n                # 並且將最佳族群成員指向目前最佳成員\n                self.bestmemyet = bestmember\n        else:\n            if bestfitness < self.bestfityet:\n                self.bestfityet = bestfitness\n                self.bestmemyet = bestmember\n        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)\n\n    def pop_print(self):\n        for i in range(self.popsize):\n            print(self.pop[i], self.fits[i])\n        return\n\n# 若單獨存在則需導入 GA 所有方法\n#import GA\n#from GA import *\nimport numpy as np\n\ndef square(x):\n    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)\n    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)\n    term3 = term1+term2\n    return term3\n\n# 最大化體積題目\ndef volume(x):\n    surface = 80.0\n    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))\n    volume = x[0]*x[1]*z\n    return volume\n\n\ndef miniex1(x):\n    \'\'\'Minimizing Beale\'s function (optimal value f(3, 0.5) = 0):\n    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)\n    ga.setbounds(np.zeros(10), 10*np.ones(10))\n    \'\'\'\n    term1 = 1.5 - x[0] + x[0]*x[1]\n    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]\n    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]\n    return term1*term1 + term2*term2 + term3*term3\n\ndef miniex2(x):\n    \'\'\'Schaffer function #2. Minimium at (0,0), equal to 0\n    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)\n    ga.setbounds(np.zeros(10), 10*np.ones(10))\n    \'\'\'\n    return 0.5 + (math.pow(math.sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/math.pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)\n\n#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)\n# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化\n#ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)\nga=GA(miniex1, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)\nga.setbounds(np.zeros(10), 10*np.ones(10))\n#ga.setbounds(-10*np.ones(10), 10*np.ones(10))\n#ga.pop_init()\nprint(ga.run()) \n 利用 C 與 Differential Evolution 解上述相同問題的原始碼: \n // 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散??\n \n/***************************************************************\n**                                                            **\n**        D I F F E R E N T I A L     E V O L U T I O N       **\n**                                                            **\n** Program: de.c                                              **\n** Version: 3.6                                               **\n**                                                            **\n** Authors: Dr. Rainer Storn                                  **\n**          c/o ICSI, 1947 Center Street, Suite 600           **\n**          Berkeley, CA 94707                                **\n**          Tel.:   510-642-4274 (extension 192)              **\n**          Fax.:   510-643-7684                              **\n**          E-mail: storn@icsi.berkeley.edu                   **\n**          WWW: http://http.icsi.berkeley.edu/~storn/        **\n**          on leave from                                     **\n**          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **\n**          D-81739 Muenchen, Germany                         **\n**          Tel:    636-40502                                 **\n**          Fax:    636-44577                                 **\n**          E-mail: rainer.storn@zfe.siemens.de               **\n**                                                            **\n**          Kenneth Price                                     **\n**          836 Owl Circle                                    **\n**          Vacaville, CA 95687                               **\n**          E-mail: kprice@solano.community.net               ** \n**                                                            **\n** This program implements some variants of Differential      **\n** Evolution (DE) as described in part in the techreport      **\n** tr-95-012.ps of ICSI. You can get this report either via   **\n** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **\n** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*\n** A more extended version of tr-95-012.ps is submitted for   **\n** publication in the Journal Evolutionary Computation.       ** \n**                                                            **\n** You may use this program for any purpose, give it to any   **\n** person or change it according to your needs as long as you **\n** are referring to Rainer Storn and Ken Price as the origi-  **\n** nators of the the DE idea.                                 **\n** If you have questions concerning DE feel free to contact   **\n** us. We also will be happy to know about your experiences   **\n** with DE and your suggestions of improvement.               **\n**                                                            **\n***************************************************************/\n/**H*O*C**************************************************************\n**                                                                  **\n** No.!Version! Date ! Request !    Modification           ! Author **\n** ---+-------+------+---------+---------------------------+------- **\n**  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **\n**    +      +       +         + included                  +        **\n**  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **\n**  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **\n**  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **\n**  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **\n**  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **\n**    +      +       +         + initialization            +        **\n**  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **\n**  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **\n**  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **\n**  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **\n**  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **\n**  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **\n**  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **\n**  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **\n**                                                                  **\n***H*O*C*E***********************************************************/\n \n#include "stdio.h"\n#include "stdlib.h"\n#include "math.h"\n#include "memory.h"\n#include <time.h>\n \n// 最大族群數, NP\n#define MAXPOP  5000\n// 最大向量維度, D\n#define MAXDIM  35\n#define MAXIMAPROBLEM 0\n#define PENALITY 1000\n \n/*------Constants for rnd_uni()--------------------------------------------*/\n \n#define IM1 2147483563\n#define IM2 2147483399\n#define AM (1.0/IM1)\n#define IMM1 (IM1-1)\n#define IA1 40014\n#define IA2 40692\n#define IQ1 53668\n#define IQ2 52774\n#define IR1 12211\n#define IR2 3791\n#define NTAB 32\n#define NDIV (1+IMM1/NTAB)\n#define EPS 1.2e-7\n#define RNMX (1.0-EPS)\n \n// 與機構合成相關的常數定義\n#define PI 3.1415926\n#define degree PI/180.0\n#define mech_loop -1\n#define NUM_OF_POINTS 10\n \n/*------------------------Macros----------------------------------------*/\n \n/*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */\n                                                           /* works only for small  */\n                                                           /* arrays, but is faster.*/\n \n/*------------------------Globals---------------------------------------*/\n \nlong  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */\ndouble c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];\ndouble (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];\n \n/*---------Function declarations----------------------------------------*/\n \nvoid  assignd(int D, double a[], double b[]);\ndouble rnd_uni(long *idum);    /* uniform pseudo random number generator */\ndouble extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */\n \n// 與機構合成相關的函式宣告\ndouble distance(double x0, double y0, double x1, double y1);\ndouble rr(double L1, double dd, double theta);\nstruct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt);\nvoid mechanism(double x0, double y0, double x1, double y1, double L1,\n  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);\ndouble error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);\n \nstruct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);\n \n/*---------Function definitions-----------------------------------------*/\n// 指定向量 b 為 a\nvoid  assignd(int D, double a[], double b[])\n/**C*F****************************************************************\n**                                                                  **\n** Assigns D-dimensional vector b to vector a.                      **\n** You might encounter problems with the macro ASSIGND on some      **\n** machines. If yes, better use this function although it\'s slower. **\n**                                                                  **\n***C*F*E*************************************************************/\n{\n   int j;\n   for (j=0; j<D; j++)\n   {\n      a[j] = b[j];\n   }\n}\n \n// 產生 0 ~ 1 間的亂數\ndouble rnd_uni(long *idum)\n/**C*F****************************************************************\n**                                                                  **\n** SRC-FUNCTION   :rnd_uni()                                        **\n** LONG_NAME      :random_uniform                                   **\n** AUTHOR         :(see below)                                      **\n**                                                                  **\n** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **\n**                 dom number in the interval [0,1]. For further    **\n**                 reference see Press, W.H. et alii, Numerical     **\n**                 Recipes in C, Cambridge University Press, 1992.  **\n**                                                                  **\n** FUNCTIONS      :none                                             **\n**                                                                  **\n** GLOBALS        :none                                             **\n**                                                                  **\n** PARAMETERS     :*idum    serves as a seed value                  **\n**                                                                  **\n** PRECONDITIONS  :*idum must be negative on the first call.        **\n**                                                                  **\n** POSTCONDITIONS :*idum will be changed                            **\n**                                                                  **\n***C*F*E*************************************************************/\n{\n  long j;\n  long k;\n  static long idum2=123456789;\n  static long iy=0;\n  static long iv[NTAB];\n  double temp;\n \n  if (*idum <= 0)\n  {\n    if (-(*idum) < 1) *idum=1;\n    else *idum = -(*idum);\n    idum2=(*idum);\n    for (j=NTAB+7;j>=0;j--)\n    {\n      k=(*idum)/IQ1;\n      *idum=IA1*(*idum-k*IQ1)-k*IR1;\n      if (*idum < 0) *idum += IM1;\n      if (j < NTAB) iv[j] = *idum;\n    }\n    iy=iv[0];\n  }\n  k=(*idum)/IQ1;\n  *idum=IA1*(*idum-k*IQ1)-k*IR1;\n  if (*idum < 0) *idum += IM1;\n  k=idum2/IQ2;\n  idum2=IA2*(idum2-k*IQ2)-k*IR2;\n  if (idum2 < 0) idum2 += IM2;\n  j=iy/NDIV;\n  iy=iv[j]-idum2;\n  iv[j] = *idum;\n  if (iy < 1) iy += IMM1;\n  if ((temp=AM*iy) > RNMX) return RNMX;\n  else return temp;\n \n}/*------End of rnd_uni()--------------------------*/\n \n// 將上下限轉為全域變數\ndouble inibound_h;      /* upper parameter bound              */\ndouble inibound_l;      /* lower parameter bound              */\n// 與機構合成相關的全域變數\n// 宣告一個座標結構\nstruct Coord {\n    double x;\n    double y;\n  // 這裡保留 double z;\n};\n \nmain(int argc, char *argv[])\n/**C*F****************************************************************\n**                                                                  **\n** SRC-FUNCTION   :main()                                           **\n** LONG_NAME      :main program                                     **\n** AUTHOR         :Rainer Storn, Kenneth Price                      **\n**                                                                  **\n** DESCRIPTION    :driver program for differential evolution.       **\n**                                                                  **\n** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **\n**                 fopen(), fclose(), fscanf().                     **\n**                                                                  **\n** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **\n**                                                                  **\n** PARAMETERS     :argc            #arguments = 3                   **\n**                 argv            pointer to argument strings      **\n**                                                                  **\n** PRECONDITIONS  :main must be called with three parameters        **\n**                 e.g. like de1 <input-file> <output-file>, if     **\n**                 the executable file is called de1.               **\n**                 The input file must contain valid inputs accor-  **\n**                 ding to the fscanf() section of main().          **\n**                                                                  **\n** POSTCONDITIONS :main() produces consecutive console outputs and  **\n**                 writes the final results in an output file if    **\n**                 the program terminates without an error.         **\n**                                                                  **\n***C*F*E*************************************************************/\n \n{\n   char  chr;             /* y/n choice variable                */\n   char  *strat[] =       /* strategy-indicator                 */\n   {\n            "",\n            "DE/best/1/exp",\n            "DE/rand/1/exp",\n            "DE/rand-to-best/1/exp",\n            "DE/best/2/exp",\n            "DE/rand/2/exp",\n            "DE/best/1/bin",\n            "DE/rand/1/bin",\n            "DE/rand-to-best/1/bin",\n            "DE/best/2/bin",\n            "DE/rand/2/bin"\n   };\n \n   int   i, j, L, n;      /* counting variables                 */\n   int   r1, r2, r3, r4;  /* placeholders for random indexes    */\n   int   r5;              /* placeholders for random indexes    */\n   int   D;               /* Dimension of parameter vector      */\n   int   NP;              /* number of population members       */\n   int   imin;            /* index to member with lowest energy */\n   int   refresh;         /* refresh rate of screen output      */\n   int   strategy;        /* choice parameter for screen output */\n   int   gen, genmax, seed;   \n \n   long  nfeval;          /* number of function evaluations     */\n \n   double trial_cost;      /* buffer variable                    */\n   // 將上下限轉為全域變數, 可能要根據各變數加以設定\n   //double inibound_h;      /* upper parameter bound              */\n   //double inibound_l;      /* lower parameter bound              */\n   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */\n   double cost[MAXPOP];    /* obj. funct. values                 */\n   double cvar;            /* computes the cost variance         */\n   double cmean;           /* mean cost                          */\n   double F,CR;            /* control variables of DE            */\n   double cmin;            /* help variables                     */\n \n   FILE  *fpin_ptr;\n   FILE  *fpout_ptr;\n \n// 計算執行過程所需時間起點, 需要導入 time.h\n  clock_t start = clock();\n \n/*------Initializations----------------------------*/\n \n //if (argc != 3)                                 /* number of arguments */\n //{\n    //printf("\\nUsage : de <input-file> <output-file>\\n");\n    //exit(1);\n //}\n \n// 將結果寫入 out.dat\n fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */\n                                          /* to see whether it already exists */\n /*\n if ( fpout_ptr != NULL )\n {\n    printf("\\nOutput file %s does already exist, \\ntype y if you ",argv[2]);\n    printf("want to overwrite it, \\nanything else if you want to exit.\\n");\n    chr = (char)getchar();\n    if ((chr != \'y\') && (chr != \'Y\'))\n    {\n      exit(1);\n    }\n    fclose(fpout_ptr);\n }\n*/\n \n/*-----Read input data------------------------------------------------*/\n \n //fpin_ptr   = fopen(argv[1],"r");\n/*\n if (fpin_ptr == NULL)\n {\n    printf("\\nCannot open input file\\n");\n    exit(1);\n }*/\n \n //fscanf(fpin_ptr,"%d",&strategy);       /*---choice of strategy-----------------*/\n //fscanf(fpin_ptr,"%d",&genmax);         /*---maximum number of generations------*/\n //fscanf(fpin_ptr,"%d",&refresh);        /*---output refresh cycle---------------*/\n //fscanf(fpin_ptr,"%d",&D);              /*---number of parameters---------------*/\n //fscanf(fpin_ptr,"%d",&NP);             /*---population size.-------------------*/\n //fscanf(fpin_ptr,"%lf",&inibound_h);    /*---upper parameter bound for init-----*/\n //fscanf(fpin_ptr,"%lf",&inibound_l);    /*---lower parameter bound for init-----*/\n //fscanf(fpin_ptr,"%lf",&F);             /*---weight factor----------------------*/\n //fscanf(fpin_ptr,"%lf",&CR);            /*---crossing over factor---------------*/\n //fscanf(fpin_ptr,"%d",&seed);           /*---random seed------------------------*/\n// 目前已經採用 strategy 3 可以得到最佳結果\n  strategy = 3;\n  genmax = 2000;\n  refresh = 100;\n  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值\n  D = 19;\n  NP = 200;\n  inibound_h = 50.;\n  inibound_l = 0.;\n/*得到最佳解\n  F = 0.85;\nCR 必須介於 0 to 1. 之間\n  CR = 1.;\n*/\n  F = 0.85;\n  CR = 1.;\n  seed = 3;\n \n //fclose(fpin_ptr);\n \n/*-----Checking input variables for proper range----------------------------*/\n \n  if (D > MAXDIM)\n  {\n     printf("\\nError! D=%d > MAXDIM=%d\\n",D,MAXDIM);\n     exit(1);\n  }\n  if (D <= 0)\n  {\n     printf("\\nError! D=%d, should be > 0\\n",D);\n     exit(1);\n  }\n  if (NP > MAXPOP)\n  {\n     printf("\\nError! NP=%d > MAXPOP=%d\\n",NP,MAXPOP);\n     exit(1);\n  }\n  if (NP <= 0)\n  {\n     printf("\\nError! NP=%d, should be > 0\\n",NP);\n     exit(1);\n  }\n  if ((CR < 0) || (CR > 1.0))\n  {\n     printf("\\nError! CR=%f, should be ex [0,1]\\n",CR);\n     exit(1);\n  }\n  if (seed <= 0)\n  {\n     printf("\\nError! seed=%d, should be > 0\\n",seed);\n     exit(1);\n  }\n  if (refresh <= 0)\n  {\n     printf("\\nError! refresh=%d, should be > 0\\n",refresh);\n     exit(1);\n  }\n  if (genmax <= 0)\n  {\n     printf("\\nError! genmax=%d, should be > 0\\n",genmax);\n     exit(1);\n  }\n  if ((strategy < 0) || (strategy > 10))\n  {\n     printf("\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n",strategy);\n     exit(1);\n  }\n  if (inibound_h < inibound_l)\n  {\n     printf("\\nError! inibound_h=%f < inibound_l=%f\\n",inibound_h, inibound_l);\n     exit(1);\n  }\n \n \n/*-----Open output file-----------------------------------------------*/\n \n   //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */\n \n   //if (fpout_ptr == NULL)\n   //{\n      //printf("\\nCannot open output file\\n");\n      //exit(1);\n   //}\n \n \n/*-----Initialize random number generator-----------------------------*/\n \n rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */\n nfeval       =  0;  /* reset number of function evaluations */\n \n \n \n/*------Initialization------------------------------------------------*/\n/*------Right now this part is kept fairly simple and just generates--*/\n/*------random numbers in the range [-initfac, +initfac]. You might---*/\n/*------want to extend the init part such that you can initialize-----*/\n/*------each parameter separately.------------------------------------*/\n \n   for (i=0; i<NP; i++)\n   {\n      for (j=0; j<D; j++) /* spread initial population members */\n      {\n        c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l);\n      }\n      cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */\n   }\n   cmin = cost[0];\n   imin = 0;\n   for (i=1; i<NP; i++)\n   {\n     if(MAXIMAPROBLEM == 1)\n     {\n       // 改為最大化\n        if (cost[i]>cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n      else\n      {\n        // 最小化問題\n        if (cost[i]<cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n   }\n \n   assignd(D,best,c[imin]);            /* save best member ever          */\n   assignd(D,bestit,c[imin]);          /* save best member of generation */\n \n   pold = &c; /* old population (generation G)   */\n   pnew = &d; /* new population (generation G+1) */\n \n/*=======================================================================*/\n/*=========Iteration loop================================================*/\n/*=======================================================================*/\n \n   gen = 0;                          /* generation counter reset */\n   while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */\n   {                                            /* is accepted by compiler    */\n      gen++;\n      imin = 0;\n \n      for (i=0; i<NP; i++)         /* Start of loop through ensemble  */\n      {\n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 2 !!!     */\n       r1 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while(r1==i);            \n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 3 !!!     */\n       r2 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r2==i) || (r2==r1));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 4 !!!     */\n       r3 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r3==i) || (r3==r1) || (r3==r2));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 5 !!!     */\n       r4 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));\n \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 6 !!!     */\n       r5 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));\n \n \n/*=======Choice of strategy===============================================================*/\n/*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/\n/*=======DE :  stands for Differential Evolution==========================================*/\n/*=======x  :  a string which denotes the vector to be perturbed==========================*/\n/*=======y  :  number of difference vectors taken for perturbation of x===================*/\n/*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/\n/*                                                                                        */\n/*=======There are some simple rules which are worth following:===========================*/\n/*=======1)  F is usually between 0.5 and 1 (in rare cases > 1)===========================*/\n/*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/\n/*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/\n/*           happens.                                                                     */\n/*=======4)  If you increase NP, F usually has to be decreased============================*/\n/*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/\n \n \n/*=======EXPONENTIAL CROSSOVER============================================================*/\n \n/*-------DE/best/1/exp--------------------------------------------------------------------*/\n/*-------Our oldest strategy but still not bad. However, we have found several------------*/\n/*-------optimization problems where misconvergence occurs.-------------------------------*/\n     if (strategy == 1) /* strategy DE0 (not in our paper) */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/1/exp-------------------------------------------------------------------*/\n/*-------This is one of my favourite strategies. It works especially well when the-------*/\n/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/\n/*-------as a first guess.---------------------------------------------------------------*/\n     else if (strategy == 2) /* strategy DE1 in the techreport */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/\n/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/\n/*-------If you get misconvergence try to increase NP. If this doesn\'t help you----------*/\n/*-------should play around with all three control variables.----------------------------*/\n     else if (strategy == 3) /* similiar to DE2 but generally better */\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                       \n         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/\n     else if (strategy == 4)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/\n     else if (strategy == 5)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n \n/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/\n \n/*-------DE/best/1/bin--------------------------------------------------------------------*/\n     else if (strategy == 6) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/1/bin-------------------------------------------------------------------*/\n     else if (strategy == 7) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/\n     else if (strategy == 8) \n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/best/2/bin--------------------------------------------------------------------*/\n     else if (strategy == 9)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/2/bin--------------------------------------------------------------------*/\n     else\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n \n \n/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/\n \n     trial_cost = evaluate(D,tmp,&nfeval);  /* Evaluate new vector in tmp[] */\n   if(MAXIMAPROBLEM == 1)\n   {\n    // 改為最大化\n       if (trial_cost >= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost>cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n    else\n    {\n          // 最小化問題\n       if (trial_cost <= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost<cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n \n      }   /* End mutation loop through pop. */\n \n      assignd(D,bestit,best);  /* Save best population member of current iteration */\n \n      /* swap population arrays. New generation becomes old one */\n \n      pswap = pold;\n      pold  = pnew;\n      pnew  = pswap;\n \n/*----Compute the energy variance (just for monitoring purposes)-----------*/\n \n      cmean = 0.;          /* compute the mean value first */\n      for (j=0; j<NP; j++)\n      {\n         cmean += cost[j];\n      }\n      cmean = cmean/NP;\n \n      cvar = 0.;           /* now the variance              */\n      for (j=0; j<NP; j++)\n      {\n         cvar += (cost[j] - cmean)*(cost[j] - cmean);\n      }\n      cvar = cvar/(NP-1);\n \n \n/*----Output part----------------------------------------------------------*/\n \n      if (gen%refresh==1)   /* display after every refresh generations */\n      { /* ABORT works only if conio.h is accepted by your compiler */\n    printf("\\n\\n                         PRESS ANY KEY TO ABORT"); \n    printf("\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n",cmin);\n \n    for (j=0;j<D;j++)\n    {\n      printf("\\n best[%d]=%-15.10g",j,best[j]);\n    }\n    printf("\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n    printf("\\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\\n",\n               NP,F,CR,cvar);\n      }\n \n      fprintf(fpout_ptr,"%ld   %-15.10g\\n",nfeval,cmin);\n   }\n/*=======================================================================*/\n/*=========End of iteration loop=========================================*/\n/*=======================================================================*/\n \n/*-------Final output in file-------------------------------------------*/\n \n \n   fprintf(fpout_ptr,"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n",cmin);\n \n   for (j=0;j<D;j++)\n   {\n     fprintf(fpout_ptr,"\\n best[%d]=%-15.10g",j,best[j]);\n   }\n   fprintf(fpout_ptr,"\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n   fprintf(fpout_ptr,"\\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\\n",\n           NP,F,CR,cvar); \n \n  fclose(fpout_ptr);\n \n  /* Code you want timed here */\n  printf("Time elapsed: %f\\n", ((double)clock() - start) / CLOCKS_PER_SEC);\n   return(0);\n}\n \n/*-----------End of main()------------------------------------------*/\n \n// 適應函式 fittness function (cost function)\ndouble evaluate(int D, double tmp[], long *nfeval)\n{\n  // 先處理通過 5 個點的四連桿問題\n  // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]\n  // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]\n  // L1 為第一桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[4]\n  // L2 為第二桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[5]\n  // L3 為第三桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[6]\n  // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)\n  // L5, L6 必須 > 0, 且小於 100 - 設為 tmp[7], tmp[8]\n  // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33\n  // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]\n  // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值\n  // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化\n  /* void mechanism(double x0, double y0, double x1, double y1, double L1,\n  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/\n  struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];\n  double input_angles[NUM_OF_POINTS], result;\n  int i;\n \n  (*nfeval)++;\n \n  target_points[0].x = 1.0;\n  target_points[0].y = 1.0;\n \n  target_points[1].x = 2.0;\n  target_points[1].y = 2.0;\n \n  target_points[2].x = 3.0;\n  target_points[2].y = 3.0;\n \n  target_points[3].x = 4.0;\n  target_points[3].y = 4.0;\n \n  target_points[4].x = 5.0;\n  target_points[4].y = 5.0;\n \n  target_points[5].x = 6.0;\n  target_points[5].y = 6.0;\n \n  target_points[6].x = 7.0;\n  target_points[6].y = 7.0;\n \n  target_points[7].x = 8.0;\n  target_points[7].y = 8.0;\n \n  target_points[8].x = 9.0;\n  target_points[8].y = 9.0;\n \n  target_points[9].x = 10.0;\n  target_points[9].y = 10.0;\n \n  // 輸入角度值與 tmp[] 的設定\n  for(i = 0; i < NUM_OF_POINTS; i++)\n  {\n    input_angles[i] = tmp[i + 9];\n  }\n  // 呼叫 mechanism() 以便計算 output_points[]\n  mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);\n \n  // for debug\n  /*\n  if(*nfeval%3000 == 0)\n  {\n    for(i = 0; i < NUM_OF_POINTS; i++)\n    {\n      printf("%-15.10g : %-15.10g\\n", output_points[i].x, output_points[i].y);\n    }\n    printf("#####################################\\n");\n  }\n  */\n  // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost\n  result = error_function(output_points, target_points);\n  // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result\n \n  // x0 與 x1 點位於 -500 與 500 中間\n    for(i = 0; i < 4; i++)\n  {\n    if(tmp[i] < -50 || tmp[i] > 50){\n      return PENALITY;\n    }\n  }\n \n  // 三個連桿值, 一定要為正\n    for(i = 4; i < 7; i++)\n  {\n    if(tmp[i] < 0 || tmp[i] > 50){\n      return PENALITY;\n    }\n  }\n \n    // L5 L6 可以為 0 或負值\n    for(i = 7; i < 9; i++)\n  {\n    if(tmp[i] < -50 || tmp[i] > 50){\n      return PENALITY;\n    }\n  }\n \n  // 角度值一定要大於 0\n \n  for(i = 1; i <= NUM_OF_POINTS; i++)\n  {\n    if((tmp[D-i] < 0)){\n      return PENALITY;\n    }\n  }\n \n  return result;\n \n  /*\n   double result=0, surface = 80.0, z, volume, penality;\n   (*nfeval)++;\n   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));\n   volume = tmp[0]*tmp[1]*z;\n \n  if(volume <= 0){\n    return PENALITY;\n  }\n \n  if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){\n    return PENALITY;\n  }\n \n  if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){\n    return PENALITY;\n  }\n  // volume must >0 and max volume\n  // 目前為最小化問題\n   return 1+1/(volume*volume);\n   */\n}\n \nstruct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)\n{\n    struct Coord tip_coord;\n \n    if (localt>=0 && localt <PI)\n    {\n        // 目前蓋掉的式子為利用手動代換出來的版本\n        //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;\n        // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.\n        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+\n    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+\n    pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;\n    }\n    else\n    {\n        // 目前蓋掉的式子為利用手動代換出來的版本\n        //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;\n        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+\n    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+\n    pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+\n    pow(x1-x0,2))/2)+x0;\n    }\n \n// 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.\n    if (localt>=0 && localt <PI)\n    {\n        tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(\n                fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)\n                /(4*(pow((y1-y0),2)+pow((x1-x0),2)))\n                ))\n                +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))\n                +y0;*/\n                // 利用 sqrtt 居中進行代換所得到的式子\n                pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+\n    pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+\n    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;\n \n    }\n    else\n    {\n        tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(\n                fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)\n                /(4*(pow((y1-y0),2)+pow((x1-x0),2)))\n                ))\n                +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))\n                +y0;*/\n                pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+\n    pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+\n    pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;\n    }\n \n  return tip_coord;\n}\n \ndouble distance(double x0, double y0, double x1, double y1)\n{\n    double distance_value;\n    distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));\n    return distance_value;\n}\n \ndouble rr(double L1, double dd, double theta)\n{\n    double rr_value;\n    rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta));\n    return rr_value;\n}\n \n// 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]\nvoid mechanism(double x0, double y0, double x1, double y1, double L1,\n  double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])\n{\n  // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置\n  // 以下為可能的處理變數宣告\n  // 這裡希望能夠定義一個 struct 來處理座標點\n  double rr_length, dd_length, angle;\n  struct Coord link1_tip, link2_tip, triangle_tip;\n    double angle2, angle3;\n  int i;\n \n  // 開始進行三角形頂點座標的計算\n  // 以下變數由每一個體向量提供\n  /*\n    x0 = 0.0;\n    y0 = 0.0;\n    x1 = 10.0;\n    y1 = 0.0;\n    L1 = 5.0;\n    L2 = 20;\n    L3 = 10;\n    L5 = 10;\n    L6 = 10;\n  */\n  dd_length = distance(x0, y0, x1, y1);\n  /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */\n  angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));\n \n  for(i = 0; i < NUM_OF_POINTS; i++)\n  {\n    // 先建立第一點座標, 即 i=0 者\n    // i=0;\n    // angle = i*degree;\n    /*\n    // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準\n    if(i > 0)\n    {\n      input_angles[i] = input_angles[i] + input_angles[i-1];\n    }\n    */\n    angle = input_angles[i]*degree;\n    rr_length = rr(L1, dd_length, angle);\n    // 第一次三角形疊代\n    link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);\n    // 第二次三角形疊代\n    /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */\n    angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));\n    link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);\n    // 第三次三角形疊代\n    //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);\n    // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);\n    // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負\n    output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);\n  }\n}\n \ndouble error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])\n{\n  double error = 0.0;\n  int i;\n  for(i = 0; i < NUM_OF_POINTS; i++)\n  {\n    error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));\n  }\n  return error;\n}\n \nstruct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)\n{\n  struct Coord tip3_coord;\n  double theta3, theta4, length3, length4;\n  length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));\n  length4 = sqrt(pow(r1,2) + pow(r2,2));  \n  theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);\n  theta4 = acos(r1 / length4);\n  tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);\n  tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);\n \n  return tip3_coord;\n} \n https://www.analyzemath.com/calculus/Problems/maximum_volume_problem.html \n 使用  Deap 程式庫 解紙盒最大體積設計題目: \n https://github.com/DEAP/deap \n import random\nimport array\nfrom deap import base\nfrom deap import benchmarks\nfrom deap import creator\nfrom deap import tools\nimport numpy\n# Problem dimension, 最大化紙箱 volume\nNDIM = 2\n# minimization problem\n# create(name, base, attributes)\n\'\'\'\nThe weights are used in the fitness comparison. They are shared among all fitnesses of the same type. \nWhen subclassing Fitness, the weights must be defined as a tuple where each element is associated\n to an objective. A negative weight element corresponds to the minimization of the associated \n objective and positive weight to the maximization.\n\'\'\'\n# weights 為 1.0 表示最大化 fitness\ncreator.create("FitnessMax", base.Fitness, weights=(1.0,))\n\'\'\'\nEvolution strategies individuals are slightly different as they contain generally two list, \none for the actual individual and one for its mutation parameters. This time instead of using \nthe list base class we will inherit from an array.array for both the individual and the strategy. \nSince there is no helper function to generate two different vectors in a single object we must \ndefine this function our-self. The initES() function receives two classes and instantiate them \ngenerating itself the random numbers in the intervals provided for individuals of a given size.\n\'\'\'\ncreator.create("Individual", array.array, typecode=\'d\', fitness=creator.FitnessMax)\ntoolbox = base.Toolbox()\n# for sphere\n#toolbox.register("attr_float", random.uniform, -3, 3)\n\'\'\'\ntoolbox.register("attr_int", random.randint, INT_MIN, INT_MAX)\ntoolbox.register("attr_flt", random.uniform, FLT_MIN, FLT_MAX)\ntoolbox.register("individual", tools.initCycle, creator.Individual,\n                 (toolbox.attr_int, toolbox.attr_flt), n=N_CYCLES)\n\'\'\'\ntoolbox.register("attr_float", random.uniform, 0, 5)\ntoolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM)\ntoolbox.register("population", tools.initRepeat, list, toolbox.individual)\n# selection method\ntoolbox.register("select", tools.selRandom, k=3)\n# fitness function is benchmarks.sphere\n# for sphere\n#toolbox.register("evaluate", benchmarks.sphere)\n\'\'\'\nSURFACE = 80, 最大化 volume\nz =(SURFACE - x*y)/(2.*(x+y));\n    volume=x*y*z;\n\'\'\'\ndef evalVolume(individual):\n    SURFACE = 80.0\n    x = individual[0]\n    y = individual[1]\n    # 確保 x 與 y 都是正值\n    if x < 0 or y < 0:\n        return -1000,\n    z =(SURFACE - x*y)/(2.0*(x+y))\n    volume = x*y*z\n    return volume,\n\n#toolbox.register("evaluate", benchmarks.ackley)\ntoolbox.register("evaluate", evalVolume)\n\ndef main():\n    # Differential evolution parameters\n    CR = 0.25\n    F = 1 \n    MU = 300\n    NGEN = 100\n     \n    pop = toolbox.population(n=MU);\n    hof = tools.HallOfFame(1)\n    stats = tools.Statistics(lambda ind: ind.fitness.values)\n    stats.register("avg", numpy.mean)\n    stats.register("std", numpy.std)\n    stats.register("min", numpy.min)\n    stats.register("max", numpy.max)\n     \n    logbook = tools.Logbook()\n    logbook.header = "gen", "evals", "std", "min", "avg", "max"\n    \n    # Evaluate the individuals\n    fitnesses = toolbox.map(toolbox.evaluate, pop)\n    for ind, fit in zip(pop, fitnesses):\n        ind.fitness.values = fit\n    \n    record = stats.compile(pop)\n    logbook.record(gen=0, evals=len(pop), **record)\n    print(logbook.stream)\n     \n    for g in range(1, NGEN):\n        for k, agent in enumerate(pop):\n            a,b,c = toolbox.select(pop)\n            y = toolbox.clone(agent)\n            index = random.randrange(NDIM)\n            for i, value in enumerate(agent):\n                if i == index or random.random() < CR:\n                    y[i] = a[i] + F*(b[i]-c[i])\n            y.fitness.values = toolbox.evaluate(y)\n            if y.fitness > agent.fitness:\n                pop[k] = y\n        hof.update(pop)\n        record = stats.compile(pop)\n        logbook.record(gen=g, evals=len(pop), **record)\n        print(logbook.stream)\n    print ("Best individual is ", hof[0], hof[0].fitness.values[0])\n     \nif __name__ == "__main__":\n    main() \n 紙盒最大體積化題目以 RGA 實數基因演算法解題: \n # https://github.com/flukeskywalker/PyRGA\n# 原始程式為 Python2 修改為 Python3 格式\n# 除了原先的最大化適應值外, 增加最小化方法設定\nimport numpy as np\nimport random\nimport math\n\n# 請注意各代族群數必須為 4 的倍數\nclass GA: # popsize must be multiple of 4\n    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):\n        self.EPSILON = 10e-6\n        self.INFINITY = 10e6\n        self.pop = []\n        self.fits = []\n        self.obj = obj\n        self.dim = dim\n        self.popsize = popsize\n        self.ngen = ngen\n        self.pc = pc\n        self.pm = pm\n        self.etac = etac\n        self.etam = etam\n        # min = 1 表最小化, min = -1 表最大化\n        self.min = min\n        self.RIGID = 0\n        self.lowb = -self.INFINITY*np.ones(self.dim)\n        self.highb = self.INFINITY*np.ones(self.dim)\n        self.tourneylist = range(0, self.popsize)\n        self.tourneysize = 2 # works for 2 for now\n        self.bestmemyet = np.zeros(self.dim)\n        # 若是求最大值\n        if self.min == -1:\n            self.bestfityet = -np.inf\n        else:\n        # 若是求最小值\n            self.bestfityet = np.inf\n        self.pop_init()\n\n    def pop_init(self):\n        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]\n        for member in self.pop:\n            for i in range(self.dim):\n                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])\n        self.fits = [self.obj(member) for member in self.pop]\n        #self.pop_print()\n        return\n\n    def setbounds(self, lows, highs):\n        for i in range(self.dim):\n            self.lowb[i] = lows[i]\n            self.highb[i] = highs[i]\n        self.pop_init()\n        return\n\n    def run(self):\n        for gen in range(self.ngen):\n            print("Generation ", gen)\n            self.pop = self.getnewpop()\n            self.eval_pop()\n            #self.pop_print()\n        return [self.bestmemyet, self.bestfityet]\n\n    def getnewpop(self):\n        newpop = []\n        #self.tourneylist = range(0, self.popsize)\n        random.shuffle(list(self.tourneylist))\n        self.tourneypos = 0\n        for i in range(0, self.popsize, 2):\n            [p1, p2] = self.getparents() #return parents, not just indices\n            [c1, c2] = self.xover(p1, p2) #return children, not just indices\n            c1 = self.mutate(c1)\n            c2 = self.mutate(c2)\n            newpop.append(c1)\n            newpop.append(c2)\n        return newpop\n\n    def getparents(self):\n        if (self.popsize - self.tourneypos) < self.tourneysize:\n            random.shuffle(list(self.tourneylist))\n            self.tourneypos = 0\n        if self.min == -1:\n            if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):\n                p1 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p1 = self.pop[self.tourneylist[self.tourneypos+1]]\n        else:\n            if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):\n                p1 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p1 = self.pop[self.tourneylist[self.tourneypos+1]]\n        self.tourneypos += self.tourneysize\n\n        if self.min == -1:\n            if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):\n                p2 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p2 = self.pop[self.tourneylist[self.tourneypos+1]]\n        else:\n            if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):\n                p2 = self.pop[self.tourneylist[self.tourneypos]]\n            else:\n                p2 = self.pop[self.tourneylist[self.tourneypos+1]]\n        self.tourneypos += self.tourneysize\n        return [p1, p2]\n\n    def xover(self, p1, p2): # Here p1 and p2 are pop members\n        c1 = np.zeros_like(p1)\n        c2 = np.zeros_like(p2)\n        if random.random()<=self.pc: # do crossover\n            for i in range(p1.size):\n                if random.random()<0.5: # 50% variables crossover\n                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])\n                else:\n                    [c1[i], c2[i]] = [p1[i], p2[i]]\n        else:\n            c1 = p1\n            c2 = p2\n        return [c1, c2]\n\n    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables\n        if p1>p2:\n            p1, p2 = p2, p1 # p1 must be smaller\n        mean = (p1+p2)*0.5\n        diff = (p2-p1)\n        dist = max(min(p1-low, high-p2), 0)\n        if (self.RIGID and diff > self.EPSILON):\n            alpha = 1.0 + (2.0*dist/diff)\n            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))\n            seed = umax*random.random()\n        else:\n            seed = random.random()\n        beta = self.getbeta(seed)\n        if (abs(diff*beta) > self.INFINITY):\n            beta = self.INFINITY/diff\n        c2 = mean + beta*0.5*diff\n        c1 = mean - beta*0.5*diff\n        c1 = max(low, min(c1, high))\n        c2 = max(low, min(c2, high))\n        return [c1, c2]\n\n    def getbeta(self, seed):\n        if (1 - seed) < self.EPSILON:\n            seed = 1 - self.EPSILON\n        seed = max(0.0, seed)\n        if seed < 0.5:\n            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))\n        else:\n            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))\n        return beta\n\n    def getdelta(self, seed, delta_low, delta_high):\n        if seed >= 1.0 - (self.EPSILON/1e3):\n            return delta_high\n        if seed <= (self.EPSILON/1e3):\n            return delta_low\n        if seed <= 0.5:\n            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))\n            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0\n        else:\n            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))\n            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))\n        return delta\n\n    def mutate(self, member):\n        mut_member = np.zeros_like(member)\n        for i in range(member.size):\n            low = self.lowb[i]\n            high = self.highb[i]\n            if random.random() <= self.pm: # pm is simply the prob of a variable to mutate\n                if self.RIGID:\n                    value = member[i]\n                    delta_low = max((low-value)/(high-low), -1.0)\n                    delta_high = min((high-value)/(high-low), 1.0)\n                    if abs(delta_low)<abs(delta_high):\n                        delta_high = -delta_low\n                    else:\n                        delta_low = -delta_high\n                else:\n                    delta_low = -1.0\n                    delta_high = 1.0\n                seed = random.random()\n                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)\n                mut_member[i] = max(low, min(member[i] + delta, high))\n            else:\n                mut_member[i] = member[i]\n        return mut_member\n\n    def eval_pop(self):\n        self.fits = [self.obj(member) for member in self.pop]\n        # 若是最大化適應值題目者\n        if self.min == -1:\n            # 將所有適應值中最大者, 指向 bestindex\n            bestindex = np.argmax(self.fits)\n        else:\n            # 將所有適應值中最大者, 指向 bestindex\n            bestindex = np.argmin(self.fits)\n        bestmember = self.pop[bestindex]\n        bestfitness = self.fits[bestindex]\n        # self.min = -1 for maximization, self.min = 1 for minimization\n        if self.min == -1:\n            # 若是在族群中的最佳適應值大於目前為止最佳的適應值\n            if bestfitness > self.bestfityet:\n                # 則將此最大適應值指為目前為止最佳適應值\n                self.bestfityet = bestfitness\n                # 並且將最佳族群成員指向目前最佳成員\n                self.bestmemyet = bestmember\n        else:\n            if bestfitness < self.bestfityet:\n                self.bestfityet = bestfitness\n                self.bestmemyet = bestmember\n        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)\n\n    def pop_print(self):\n        for i in range(self.popsize):\n            print(self.pop[i], self.fits[i])\n        return\n\n# 若單獨存在則需導入 GA 所有方法\n#import GA\n#from GA import *\nimport numpy as np\n\ndef square(x):\n    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)\n    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)\n    term3 = term1+term2\n    return term3\n\n# 最大化體積題目\ndef volume(x):\n    surface = 80.0\n    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))\n    volume = x[0]*x[1]*z\n    return volume\n\n\ndef miniex1(x):\n    \'\'\'Minimizing Beale\'s function (optimal value f(3, 0.5) = 0):\n    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)\n    ga.setbounds(np.zeros(10), 10*np.ones(10))\n    \'\'\'\n    term1 = 1.5 - x[0] + x[0]*x[1]\n    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]\n    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]\n    return term1*term1 + term2*term2 + term3*term3\n\ndef miniex2(x):\n    \'\'\'Schaffer function #2. Minimium at (0,0), equal to 0\n    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)\n    ga.setbounds(np.zeros(10), 10*np.ones(10))\n    \'\'\'\n    return 0.5 + (math.pow(math.sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/math.pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)\n\n#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)\n# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化\nga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)\n#ga=GA(miniex1, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)\nga.setbounds(np.zeros(10), 10*np.ones(10))\n#ga.setbounds(-10*np.ones(10), 10*np.ones(10))\n#ga.pop_init()\nprint(ga.run()) \n', 'tags': '', 'url': '隨機與基因演算.html'}, {'title': '隨機與機器學習', 'text': '隨機森林', 'tags': '', 'url': '隨機與機器學習.html'}, {'title': '調查表單', 'text': '現成工具 \n Ｇoogle Form 與 Sheet - 學習如何使用 \n 如何取出 Sheet 資料, 加值再利用或進行其他處理？ \n 能否自行建置調查表單, 該如何進行? 不同方法, 各有何優缺點? \n 網際表單? \n', 'tags': '', 'url': '調查表單.html'}, {'title': '學習功課表', 'text': '既有工具 \n 學校所提供的功課表？ \n 利用 Google Calendar 建立自己的行事曆 \n 如何針對既有工具所提供的資料再變化 (臨時調課) 或利用 (找出多人可用的共同時段) - Google Calendar 安排會議的衝突檢查 \n Google Calendar API \n 活動排程 (Scheduling) \n 自己從學校主機撈出與課程相關的歷史資料, 建立統計數據表, 提供之後的選課參考', 'tags': '', 'url': '學習功課表.html'}, {'title': '解微積分', 'text': '計算機程式協助解微積分問題\xa0 - 利用圖表協助了解問題 \n 計算機程式解數學問題 - 利用圖表了解問題與解題意義 \n https://www.math.wisc.edu/~angenent/Free-Lecture-Notes/ \n https://blog.gtwang.org/useful-tools/sympy-python-library-for-symbolic-mathematics/3/ \n https://betterexplained.com/articles/a-gentle-introduction-to-learning-calculus/ \n https://towardsdatascience.com/taking-derivatives-in-python-d6229ba72c64 \n https://in.pycon.org/cfp/workshops-2019/proposals/learning-calculus-with-python~av3gb/ \n first semester calculus.pdf \n second semester calculus.pdf \n programming_and_mathematical_thinking_python.pdf \n computational_physics_python.pdf', 'tags': '', 'url': '解微積分.html'}, {'title': '活動管理', 'text': '寄送活動通知 - 利用 Gmail API 收發信件 \n https://blog.mailtrap.io/send-emails-with-gmail-api/   \n 活動照片彙整 - 現存工具與自建工具 \n Google + Domain API 與 Oauth2 登入管理系統 \n 將活動相關的檔案與照片, 透過 Google Drive API 直接上傳至 Google Drive \n 活動報到與座位安排', 'tags': '', 'url': '活動管理.html'}, {'title': 'GDrive API', 'text': 'Enable Google Drive API \n Reference:  https://github.com/chingjunetao/medium-article/blob/master/google-drive-with-python/google-drive-with-python.py \n 需要設定 Google Drive API credential 並取得 client_secrets.json \n 利用 \n pip install pydrive \n 安裝所需模組, 以下程式將會至 client_secrets.json 所對應帳號下的 Google Drive, 列出所有目錄與檔案, 並將 file_to_upload.pdf 上傳至 Google Drive 中的 uploaded 目錄. \n from pydrive.auth import GoogleAuth\nfrom pydrive.drive import GoogleDrive\n\ngauth = GoogleAuth()\ngauth.LocalWebserverAuth() # client_secrets.json need to be in the same directory as the script\ndrive = GoogleDrive(gauth)\n\n\n# View all folders and file in your Google Drive\nfileList = drive.ListFile({\'q\': "\'root\' in parents and trashed=false"}).GetList()\nfor file in fileList:\n  print(\'Title: %s, ID: %s\' % (file[\'title\'], file[\'id\']))\n  # Get the folder ID that you want\n  if(file[\'title\'] == "uploaded"):\n      fileID = file[\'id\']\n\nfile1 = drive.CreateFile({"mimeType": "application/pdf", "parents": [{"kind": "drive#fileLink", "id": fileID}]})\nfile1.SetContentFile("file_to_upload.pdf")\nfile1.Upload() # Upload the file.\nprint(\'Created file %s with mimeType %s\' % (file1[\'title\'], file1[\'mimeType\']))    \n For example, you might want to integrate your existing website with Drive API. In that case, you can customize authentication flow as follwing: 1. Get authentication Url from GetAuthUrl(). 2. Ask users to visit the authentication Url and grant access to your application. Retrieve authentication code manually by user or automatically by building your own oauth2callback. 3. Call Auth(code) with the authentication code you retrieved from step 2. Your settings.yaml will work for your customized authentication flow, too. \n from pydrive.auth import GoogleAuth\n\ngauth = GoogleAuth()\nauth_url = gauth.GetAuthUrl() # Create authentication url user needs to visit\ncode = AskUserToVisitLinkAndGiveCode(auth_url) # Your customized authentication flow\ngauth.Auth(code) # Authorize and build service from the code \n', 'tags': '', 'url': 'GDrive API.html'}, {'title': '網際內容管理', 'text': 'Leo Editor:  https://leoeditor.com/ \n Leo Editor 簡介:  https://kaleguy.github.io/leovue/#dashboard', 'tags': '', 'url': '網際內容管理.html'}, {'title': '網際 PDF 檔案管理', 'text': 'wcm2020 pypdf page', 'tags': '', 'url': '網際 PDF 檔案管理.html'}, {'title': '網際圖檔管理', 'text': '圖檔管理 \n 影像辨識 \n Learn Computer Vision using OpenCV.pdf  (登入 @gm 後下載) \n Practicle OpenCV.pdf  (登入 @gm 後下載) \n Pro Processing for Images and Computer Vision with OpenCV.pdf  (登入 @gm 後下載) \n', 'tags': '', 'url': '網際圖檔管理.html'}, {'title': '線上會議', 'text': 'https://github.com/jitsi/jitsi-meet   \n https://github.com/jitsi/docker-jitsi-meet   \n', 'tags': '', 'url': '線上會議.html'}, {'title': '電腦輔助設計與實習', 'text': '', 'tags': '', 'url': '電腦輔助設計與實習.html'}, {'title': '產品設計繪圖', 'text': 'Solvespace \n OnShape \n FreeCAD \n SolidWorks \n cad2019 Solidworks page \n NX \n cad2019 下載 NX 套件 \n cad2019 NX12 page \n NX12 for engineering design.pdf \n nxopen_getting_started_v12.pdf \n http://nxjournaling.com/ \n Setup_Eclipse_for_NXOpenPythonScripting.pdf \n run_journal 指令可以直接執行外部的 NXOpen Python Journal 程式 \n AutoDesk Inventor \n 參考資料: \n http://www.josh-ua.co/blog/2019/2/13/solidworks-vs-siemens-nx-vs-onshape', 'tags': '', 'url': '產品設計繪圖.html'}, {'title': '產品設計分析', 'text': 'Digital Products: \n Computational Intelligence Techniques for New Product Design.pdf  (登入 @gm 後下載) \n Digital Products.pdf  (登入 @gm 後下載) \n Computer aided engineering: \n https://github.com/Range-Software/range3 \xa0', 'tags': '', 'url': '產品設計分析.html'}, {'title': '機電資整合控制', 'text': 'Mechatronic System Design \n Login to your gm email account and download  MSModelingAndTFApproaches.pdf . \n (Can we build online tools to facilitate these processes?) \n Mechatronic Systems \n Mathematical Modeling \n Transfer Function Approaches \n Login to your gm email account and download  MechatronicDesignCases.pdf . \n DC Motor Velocity and Position Control \n Balancing Robot Control \n Magnetic Levitation System \n', 'tags': '', 'url': '機電資整合控制.html'}, {'title': '產品生命週期管理', 'text': 'https://github.com/odoo/odoo \n https://www.odoo.com/documentation/user/13.0/ \n odoo-development-readthedocs-io-en-20200518.pdf  (for @gm users only) \n Download PLM ebooks  (for @gm users only) \n', 'tags': '', 'url': '產品生命週期管理.html'}, {'title': '協同產品設計實習', 'text': '參考資料: \n Digital Twin \n 2019 Twin Control.pdf  - A Digital Twin Approach to Improve MachineTools Lifecycle (for @gm users only) \n 2015 Mac Protocol for Cyber-Physical Systems.pdf  (for @gm users only) \n https://colab.research.google.com/notebooks/intro.ipynb   \n 以未來科技家庭中的先進產品開發為例 \n 可折疊與拼裝組合的各種用途桌椅 \n 可折疊與方便居家儲藏與吊掛的家庭成員自行車 \n 多功能居家隔音與空氣濾清門窗組 \n 家庭遊樂設備, 機電整合多功能櫥櫃 \n 集手足球, 撞球與彈珠台於一身的組合式遊樂中心 \n STEM 導向機電資整合式運動遊樂器 \n 智慧功能機器人 \n 能克服障礙物並爬樓梯的激動玩具車 \n 折疊省力多功能搬運推車 \n 推高自走玩具車 \n 自走式自動充電吸塵機器人 \n S — Science（科學） T — Technology（技術） E — Engineering（工程） M — Mathematics（數學） \n', 'tags': '', 'url': '協同產品設計實習.html'}, {'title': '兩人一組產品開發', 'text': '兩人共同快速 (一週) 開發一組產品設計與實作 (分組自評與互評, 說明遭遇問題與解決方法) \n 報告與檢討 (一週) \n', 'tags': '', 'url': '兩人一組產品開發.html'}, {'title': '四人一組產品開發', 'text': '四人共同快速 (兩週) 開發一組產品設計與實作 \n 報告與檢討 (一週) \n', 'tags': '', 'url': '四人一組產品開發.html'}, {'title': '八人一組產品開發', 'text': '八人共同快速 (三週) 開發一組產品設計與實作 \n 報告與檢討 (一週) 期中考週 \n', 'tags': '', 'url': '八人一組產品開發.html'}, {'title': '十六人一組產品開發', 'text': '十六人共同快速 (三週) 開發一組產品設計與實作 \n 報告與檢討 (一週) \n', 'tags': '', 'url': '十六人一組產品開發.html'}, {'title': '三十二人一組產品開發', 'text': '三十二人共同快速 (四週) 開發一組產品設計與實作 \n 報告與檢討 (一週) 期末考週', 'tags': '', 'url': '三十二人一組產品開發.html'}]};